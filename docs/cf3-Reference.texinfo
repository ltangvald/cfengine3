\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CfengineLogo}
@c *********************************************************************
@c
@c  This is an AUTO_GENERATED TEXINFO file. Do not submit patches against it.
@c  Refer to the the component .texinfo files instead when patching docs.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf3-reference.info
@settitle Cfengine reference manual
@setchapternewpage odd
@c %** end of header
@titlepage
@title Cfengine Reference Manual
@subtitle Auto generated, self-healing knowledge
@subtitle Documentation for core version 3.0.2
@subtitle Contains Nova extensions at version 1.0.5

@author cfengine.com
@c @smallbook
@fonttextsize 10
@page
@vskip 0pt plus 1filll
@cartouche
Under no circumstances shall Cfengine AS be liable for errors or omissions
in this document. All efforts have been made to ensure the correctness of
the information contained herein.
@end cartouche
Copyright @copyright{} from 2008 to the year of issue Cfengine AS
@end titlepage
@c *************************** File begins here ************************
@ifinfo
@dircategory Cfengine Training
@direntry
* cfengine Reference:
                        Cfengine is a language based framework
                        designed for configuring and maintaining
                        Unix-like operating systems attached
                        to a TCP/IP network.
@end direntry
@end ifinfo
@ifnottex
@node Top, Getting started, (dir), (dir)
@top Cfengine-AutoReference
@end ifnottex
@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>
@end html
@end ifhtml
@iftex
@contents
@end iftex
@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@menu
* Getting started::             
* A simple crash course::       
* How to run cfengine 3 examples::  
* A complete configuration::    
* Control Promises::            
* Bundles for common::          
* Bundles for agent::           
* Bundles for server::          
* Bundles for knowledge::       
* Bundles for monitor::         
* Special functions::           
* Special Variables::           
* Logs and records::            
@end menu

@node Getting started, A simple crash course, Top, Top
@chapter Cfengine 3.0.2 -- Getting started

@*

Cfengine is a suite of programs for integrated autonomic management of
either individual or networked computers. It has existed as as
software suite since 1993 and this version published under the GNU
Public License (GPL v3) and a Commercial Open Source License (COSL).
Cfengine is Copyright by @b{Cfengine AS}, a company founded by cfengine
author Mark Burgess.

This document describes version 3 of cfengine, which is a radical
departure from earlier versions. It is both simpler and more powerful.
Cfengine 3 will exist in four versions, each of which adds to the fo

@itemize
@item @b{Community Edition} - a free and gratis core of the software (available now).
@item @b{Nova} - a commercial enhanced version for basic enterprise needs (available now).
@item @b{Constellation} - a commercial enhancement for larger enterprises (coming 2010).
@item @b{Galaxy} - the ultimate commerical enhancement for global enterprises (coming 2011).
@end itemize

Cfengine 3 has been changed to be both a more powerful tool and a much
simpler tool. Cfengine 3's language interface is not backwards
compatible with the cfengine 2 configuration language, but it
interoperates with cfengine 2 so that it is "run-time compatible".
This means that you can change over to version 3 slowly, with low risk
and at your own speed.

With cfengine 3 you can install, configure and maintain computers
using powerful hands-free tools. You can also integrate knowledge
management and diagnosis into the processes.

Cfengine differs from most management systems in being

@itemize
@item Open software (GPL or COSL).
@item Lightweight and generic.
@item Non-reliant on a working network to function correctly.
@item Capable of making each and every host autonomous
@end itemize


Cfengine 3 consists of a number of components:

@table @code
@item cf-agent     
Active agent
@item cf-execd     
Scheduler
@item cf-graph     
Graph data extractor
@item cf-know      
Knowledge modelling agent
@item cf-monitord  
Passive monitoring agent
@item cf-promises  
Promise validator
@item cf-runagent  
Remote run agent
@item cf-serverd   
Server agent
@item cf-report
Self-knowledge extractor
@end table


The starred components are new. The daemon formally called
@code{cfenvd} in previous versions of cfengine is now called
@code{cf-monitord}.


Unlike previous versions of cfengine, which had no consistent model
for its features, you can recognize @i{everything} in cfengine 3
from just a few concepts.

@table @i
@item Promise
A statement about the state we desire to maintain.
@item Promise bundles
A collection of promises.
@item Promise bodies
A part of a promise which details and constrains its nature.
@item Data types
An interpretation of a scalar value: string, integer or real number.
@item Variables
An association of the form "LVALUE @i{represents} RVALUE", where rval may be a scalar value or a list of scalar values.
@item Functions
Built-in parameterized rvalues.
@item Classes
Cfengine's boolean classifiers that describe context.
@end table


If you have used cfengine before then the most visible part of
cfengine 3 will be its new language interface.  Although it has been
clear for a long time that the organically grown language used in
cfengine 1 and 2 developed many problems, it was not immediately
clear exactly what would be better. It has taken years of research to
simplify the successful features of cfengine to a single overarching
model. To understand the new cfengine, it is best to set aside any
preconceptions about what cfengine is today. Cfengine 3 is a genuine
"next generation" effort, which is will be a springboard into the
future of system management.


@menu
* A renewed cfengine::          
* Installation::                
* Work directory::              
* Hard classes::                
* Global and local classes::    
* Filenames and paths::         
* Upgrading from cfengine 2::   
* Testing as a non-privilieged user::  
* The bare necessities of a cfengine 3::  
* Familiiarizing yourself::     
* Remote access troubleshooting::  
@end menu

@node A renewed cfengine, Installation, Getting started, Getting started
@section A renewed cfengine


Cfengine 3 is a significant rewrite of underlying cfengine technology
which preserves the core principles and methodology of cfengine's
tried and tested approach.  It comes with a new, improved language,
with a consistent syntax and powerful pattern expression features that
display the intent behind cfengine code more clearly. The main goal in
changing the language is to simplify and improve the robustness and
functionality without sacrificing the basic freedoms and self-repairing
concepts.

Cfengine 3's new language is a direct implementation of a model
developed at Oslo University College over the past four years, known
colloquially as "Promise Theory".  Promises were originally introduced
by Mark Burgess as a way to talk about cfengine's model of autonomy
and have since become a powerful way of modelling cooperative systems
-- not just computers, but humans too. 

@quotation

@i{   ``The biggest challenge of implementing cfengine in our organization@*
     was not technical but political -- getting everyone to agree.@*
     Promise theory was a big help in understand this.''}

@end quotation

Cfengine 3 is a generic implementation of the language of promises
that allows all of the aspects of configuration and change management to be
unified under a single umbrella.

Why talk about promises instead of simply talking about changes? After
all, the trend in business and IT management today is to talk about
Change Management (with capital letters), e.g. in the IT
Infrastructure Library (ITIL) terminology.  This comes from a long
history of process management thinking. But we are not really
interested in change -- we are interested in avoiding it, i.e. being
in a state where we don't need to make any changes. In other words we
want to be able to promise that the system is correct, verify this and
only make changes if our promises are not kept. If you want
to think ITIL, think of this as a service that cfengine provides.

To put it another way, cfengine is not really a @i{change
management} system, it is a @i{maintenance system}. Maintenance
is the process of making small changes or corrections to a model. A
`model' is just another word for a template or a specification of how
we want the system to work. Cfengine's model is based on the idea of
promises, which means that it focuses on what is stable and lasting
about a system -- not about what is changing.


This is an important philosophical shift. It means we are focused
mainly on what is right and not on what is wrong. By saying what
"right" is (the ideal state of our system) we are focused on the
actual behaviour. If we focus too much on the changes, i.e. the
differences between now and the future, we might forget to verify that what
we assume is working now in fact works.


Models that talk about change management tend to forget that after
every change there is a litany of @i{incidents} during which it is
necessary to repair the system or return it to its intended state.
But if we know what we have promised, it is easy to verify whether the
promise is kept.
This means that it is the @i{promises} about how the system should
be that are most important, not the actual changes that are made in
order to keep them.




@node Installation, Work directory, A renewed cfengine, Getting started
@section Installation

In order to install cfengine, you should first ensure that the following
packages are installed.

@table @r
@item @b{OpenSSL}
Open source Secure Sockets Layer for encryption.@*URL: @url{http://www.openssl.org}
@item @b{BerkeleyDB} (version 3.2 or later)
Light-weight flat-file database system.@*URL: @url{http://www.oracle.com/technology/products/berkeley-db/index.html}

@item @b{In addition...} 
It is recommended to make the Perl Compatible Regular Expression
(PCRE) library available as this is a significant improvement over the
more standard POSIX libraries. This documentation assumes the use of
PCRE

@item
On Windows machines, you need to install the basic Cygwin DLL from @url{http://www.cygwin.com}
in order to run cfengine. 
@end table

Additional functionality becomes available if other libraries are present, e.g.
OpenLDAP, client libraries for MySQL and PostgreSQL, etc. It is possible to run
cfengine without these, but related functionality will be missing.

Unless you have purchased ready-to-run binaries, or are using a
package distribution, you will need to compile cfengine. For this you
will also need a build environment tools: @code{gcc}, @code{flex}, @code{bison}.

@noindent
The preferred method of installation is then

@smallexample
tar zxf cfengine-x.x.x.tar.gz
cd cfengine-x.x.x
./configure
make
make install
@end smallexample

@noindent
This results in binaries being installed in @file{/usr/local/sbin}.
Since this is not necessarily a local file system on all hosts, users
are encouraged to keep local copies of the binaries on each host, inside
the cfengine trusted work directory.


@node Work directory, Hard classes, Installation, Getting started
@section The work directory

In order to achieve the desired simplifications, it was decided to
reserve a private work area for the cfengine tool-set. 
@c chew begin Work directory

@cartouche
In cfengine 1.x, the administrator could choose the locations of
configuration files, locks, and logging data independently. In
cfengine 2.x, this diversity has been simplified to a single directory
which defaults to @file{/var/cfengine} (similar to @file{/var/cron}), and in
cfengine 3.x this is preserved.
@end cartouche

@w{}
@smallexample
/var/cfengine
/var/cfengine/bin
/var/cfengine/inputs
/var/cfengine/outputs
@end smallexample
@c chew end Work directory

The installation location
@file{/usr/local/sbin} is not necessarily a local file system, and cannot
therefore be trusted to a) be present, and b) be authentic on an
arbitrary system.

Similarly, a trusted cache of the input files must now be maintained
in the @file{inputs} subdirectory. When cfengine is invoked by the
scheduler, it reads only from this directory. It is up to the user to
keep this cache updated, on each host. This simplifies and
consolidates the cfengine resources in a single place. 

Unlike cfengine 2, cfengine 3 does not recognize the
@code{CFINPUTS} environment variable.

The @file{outputs} directory is now a record of spooled run-reports. These
are often mailed to the administrator by @code{cf-execd}, or can be copied
to another central location and viewed in an alternative browser.


@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Hard classes, Global and local classes, Work directory, Getting started
@section Cfengine hard classes

Cfengine runs on every computer individually and each time it wakes up
the underlying generic agent platform discovers and classifies
properties of the environment or context in which it runs.  This information
is cached and may be used to make decisions about configuration@footnote{There are
no if-then-else statements in cfengine; all decisions are made with classes.}.

Classes fall into hard (discovered) and soft (defined) types.  A
single class can be one of several things:

@c chew start Hard classes

@itemize @bullet

@item The name of an operating system architecture e.g.  @code{ultrix}, @code{sun4}, etc.

@item The unqualified name of a particular host. If your system returns a fully
qualified domain name for your host, cfengine truncates it at the first dot.

@item The name of a user-defined group of hosts.

@item A day of the week (in the form @code{Monday, Tuesday, Wednesday, ..}).

@item An hour of the day, current time zone (in the form @code{Hr00, Hr01 ... Hr23}).

@item An hour of the day GMT (in the form @code{GMT_Hr00, GMT_Hr01 ... GMT_Hr23}).
This is consistent the world over, in case you need virtual simulteneity of change
coordination.

@item Minutes in the hour (in the form @code{Min00, Min17 ... Min45}).

@item A five minute interval in the hour (in the form @code{Min00_05, Min05_10 ... Min55_00})

@item A day of the month (in the form @code{Day1, Day2, ... Day31}).

@item A month (in the form @code{January, February, ... December}).

@item A year (in the form @code{Yr1997, Yr2004}).

@item A shift in @code{Night,Morning,Afternoon,Evening}, which fall into six hour blocks
starting at 00:00 hours.

@item A `lifecycle index', which is the year number modulo 3 (used in long term resource memory).

@item An arbitrary user-defined string.

@item The IP address octets of any active interface (in the form @code{@w{ipv4_192_0_0_1}},
@code{@w{ipv4_192_0_0}}, @code{@w{ipv4_192_0}}, @code{@w{ipv4_192}}).

@end itemize

@c chew end Hard classes

To see all of the classes define on a particular host, run

@smallexample
host# cf-promises -v
@end smallexample
as a privileged user. Note that some of the classes are set only
if a trusted link can be established with cfenvd, i.e. if both
are running with privilege, and the @file{/var/cfengine/state/env_data}
file is secure. More information about classes can be found in connection with
@code{allclasses}.

@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Global and local classes, Filenames and paths, Hard classes, Getting started
@section Global and local classes

Classes are defined in bundles. Bundles of type @code{common} yield classes that
are global in scope, whereas in all other bundle types classes are local.
Classes are evaluated when the bundle is evaluated.
Consider the following example.

@verbatim

body common control
{
bundlesequence => { "g","tryclasses_1", "tryclasses_2" };
}

#################################

bundle common g
{
classes:

  "one" expression => "any";

}

#################################

bundle agent tryclasses_1
{
classes:

  "two" expression => "any";
}

#################################

bundle agent tryclasses_2
{
classes:

  "three" expression => "any";

reports:

  one.three.!two::

    "Success";
}

@end verbatim

Here we see that class @samp{one} is global while classes @samp{two} and @samp{three} are local.
The report `Success' result is therefore true because only @samp{one} and @samp{three} are in scope.

@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Filenames and paths, Upgrading from cfengine 2, Global and local classes, Getting started
@section Filenames and paths

@c chew start Unix filenames

Filenames in Unix-like operating systems use the forward slash
@samp{/} character for their directory separator . All references to
file locations must be absolute pathnames in cfengine, i.e. they must
begin with a complete specification of which directory they are
in. For example:

@smallexample
/etc/passwd
/usr/local/masterfiles/distfile
@end smallexample
@noindent
The only place where it makes sense to refer to a file without a complete
directory specification is when searching through directories for different
kinds of file, e.g. in pattern matching

@verbatim

leaf_name => { "tmp_.*", "output_file", "core" };

@end verbatim

@noindent 
Here, one can write @file{core} without a path, because one is looking for any
file of that name in a number of directories.
@c chew end Unix filenames

@c chew start Windows filenames
The Windows operating systems traditionally use a different filename
convention.  The following are all valid absolute file names under
Windows:

@smallexample
 c:\winnt
 c:/winnt
 /var/cfengine/inputs
 //@var{fileserver}/share2/dir
@end smallexample
The `drive' name ``C:'' in Windows refers to a partition or device. Unlike Unix,
Windows does not integrate these seamlessly into a single file-tree.
This is not a valid absolute filename:

@smallexample
\var\cfengine\inputs
@end smallexample
Paths beginning with a backslash are assumed to be win32 paths.  They
must begin with a drive letter or double-slash server name.
@c chew end Windows filenames

Note in recent versions of Cygwin you can decide to use the
@code{/cygdrive} to specify a path to windows file E.g
@file{/cygdrive/c/myfile} means @file{c:\myfile} or you can do it straight away in
cfengine as @code{c:\myfile}.

@c ---------------------------------------------------------------------------
@node Upgrading from cfengine 2, Testing as a non-privilieged user, Filenames and paths, Getting started
@section Upgrading from cfengine 2

Cfengine 3 has a completely new syntax, designed to solve the issues
brought up from 15 years of experience with configuration
management. Rather than clutter cfengine 3 with buggy
backward-compatability issues, it was decided to make no compromises
with cfengine 3 and instead allow cfengine 2 and cfengine 3 to
coincide in a cooperative fashion for the foreseeable future.  This
means that users can upgrade at their own pace, in the classic
cfengine incremental fashion. We expect that cfengine 2 installations
will be around for years to come so this upgrade path seems the most
defensible.

The daemons and support services are fully interoperable between
cfengine 2 and cfengine 3, so it does not matter whether you run
@code{cfservd} (cf2) together with @code{cf-agent} (cf3) or
@code{cf-serverd} (cf3) together with @code{cfagent} (cf2). You can
change the servers at your own pace.

Cfengine 3's @code{cf-execd} replaces cfengine 2's @code{cfexecd} and
it is designed to work optimally with @code{cf-agent} (cf3). Running
this daemon has no consequences for access control, only for
scheduling @code{cf-agent}. You can (indeed should) replace
@code{cfexecd} with @code{cf-execd} immediately. You will want to
alter your @file{crontab} file to run the new component instead of the
old. The sample cfengine 3 input files asks @code{cf-agent} to do
this automatically, simply replacing the string.

The sample @file{inputs} files supplied with cfengine 3 contain
promises to integrate cfengine 2 as described. What can you do to
upgrade? Here is a simple recipe that assumes you have a standardized
cfengine 2 setup, running @code{cfexecd} in @file{crontabs} and possibly
running @code{cfservd} and @code{cfenvd} as daemons.

@enumerate

@item Install the cfengine 3 software on a host.

@item Go to the @file{inputs/} directory in the source and copy these
files to your master update repository, i.e.  where you will publish
policies for distribution.

@item Remove any self-healing rules to reinstall cfengine 2, especially
rules to add @code{cfexecd} or @code{cfagent} to @file{crontabs} etc. Cfengine 3
will handle this from now on and encapsulate old cfengine 2 scripts.

@item Move to this inputs directory: @code{cd @var{your-path}/inputs}.

@item Set the location of this master update directory in the @file{update.cf} 
file to the location of the master directory.

@item Set the email options for the executor in @file{promises.cf}.

@item Run @code{cf-agent --bootstrap} as the root or privileged user. This will install
cfengine 3 in place of cfengine 2, integrate your old cfengine 2
configuration, and warn you about any rules that need to be removed
from your old cfengine configuration.

@item You should now be running cfengine 3. You can now add new rules to the files
in your own time, or convert the old cfengine 2 rules and gradually comment them
out of the cfengine 2 files.

@item Make sure there are no rules in your old cfengine 2 configuration to activate
cfengine 2 components, i.e. rules that will fight against cfengine 3.
Then, when you are ready, convert @file{cfservd.conf} into a server bundle e.g. in @file{promises.cf}
and remove all rules to run @code{cfservd} and replace them with rules to run
@code{cf-serverd} at your own pace.

@end enumerate


@c ---------------------------------------------------------------------------
@node Testing as a non-privilieged user, The bare necessities of a cfengine 3, Upgrading from cfengine 2, Getting started
@section Testing as a non-privilieged user

One of the practical advantages of cfengine is that you can test it
without the need for root or administrator privileges. This is
recommended for all new users of cfengine 3.

Cfengine operates with the notion of a work-directory. The default
work directory for the @code{root} user is @file{/var/cfengine}
(except on Debian Linux and various derivatives which prefer
@file{/var/lib/cfengine}).  For any other user, the work directory
lies in the user's home directory, named @file{~/.cfagent}. Cfengine
prefers you to keep certain files here.  You should not resist this
too strongly or you will make unnecessary trouble for yourself.  The
decision to have this `known directory' was made to simplify a lot of
configuration.

To test cfengine as an ordinary user, do the following:

@itemize
@item Compile and make the software.
@item Copy the binaries into the work directory:
@smallexample
host$ mkdir -p ~/.cfagent/inputs
host$ mkdir -p ~/.cfagent/bin
host$ cd src
host$ cp cf-* ~/.cfagent/bin
host$ cd ../inputs
host$ cp *.cf ~/.cfagent/inputs
@end smallexample
@end itemize

You can test the software and play with configuration files by editing the basic get-started files
directly in the @file{~/.cfagent/inputs} directory. For example, try the following:

@smallexample
host$ ~/.cfagent/bin/cf-promises
host$ ~/.cfagent/bin/cf-promises --verbose
@end smallexample

This is always the way to start checking a configuration in cfengine
3. If a configuration does not pass this check/test, you will not be
allowed to use it, and @file{cf-agent} will look for the file
@file{failsafe.cf}.

Notice that the cfengine 3 binaries have slightly different names than the cfengine
2 binaries. They all start with the @file{cf-} prefix.
@smallexample
host$ ~/.cfagent/bin/cf-agent
@end smallexample


@c ---------------------------------------------------------------------------
@node The bare necessities of a cfengine 3, Familiiarizing yourself, Testing as a non-privilieged user, Getting started
@section The `bear' necessities of a cfengine 3

Here is the simplest `Hello world' program in cfengine 3:

@verbatim

body common control
{
bundlesequence  => { "test" };
}

bundle agent test
{
reports:

 Yr2009::
    "Hello world";
}

@end verbatim

@noindent If you try to process this using the @code{cf-promises} command, you will
see something like this:

@smallexample
atlas$ ~/LapTop/Cfengine3/trunk/src/cf-promises -r -f ./unit_null_config.cf 
Summarizing promises as text to ./unit_null_config.cf.txt
Summarizing promises as html to ./unit_null_config.cf.html
@end smallexample

@noindent The @samp{-r} option produces a report. Examine the files produced:

@smallexample
cat ./unit_null_config.cf.txt
firefox ./unit_null_config.cf.html
@end smallexample

You will see a summary of how cfengine interprets the files, either in
HTML or text. By default, the cfengine components also dump a debugging
file, e.g. @file{promise_output_agent.html}, @file{promise_output_agent.txt}
with an expanded view.

@c ---------------------------------------------------------------------------
@node Familiiarizing yourself, Remote access troubleshooting, The bare necessities of a cfengine 3, Getting started
@section Familiarizing yourself


To familiarize yourself with cfengine 3, type or paste in the following example text:

@verbatim
########################################################
#
# Simple test execution
#
########################################################

body common control

{
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
vars:

  "size" int => "46k";
  "rand" int => randomint("33","$(size)");

commands:

  "/bin/echo" 
     args => "Hello world - $(size)/$(rand)",
     contain => standard,
     classes => cdefine("followup","alert");

  followup::
 
     "/bin/ls" 
       contain => standard;

reports:

  alert::

     "What happened?";

}

######################################################################

body contain standard

{
exec_owner => "mark";
useshell => "true";
}

######################################################################

body classes cdefine(class,alert)

{
promise_repaired => { "$(class)" };
repair_failed => { "$(alert)" };
}
@end verbatim

This example shows all of the main features of cfengine: bundles,
bodies, control, variables, and promises.  To the casual eye it might
look complex, but that is because it is explicit about all of the
details. Fortunately it is easy to hide many of these details to
make the example simpler without sacrificing any functionality.


The first thing to try with this example is to verify it -- did we
make any mistakes? Are there any inconsistencies? To do this we use
the new cfengine program @code{cf-promises}. Let's assume that you
typed this into a file called @file{test.cf} in the current directory.

@smallexample
cf-promises -f ./test.cf
@end smallexample

If all is well, typing this command shows no output. Try now running the
command with verbose output.

@smallexample
cf-promises -f ./test.cf -v
@end smallexample

Now you see a lot of information

@smallexample
Reference time set to Sat Aug  2 11:26:06 2008

cf3 Cfengine - 3.0.0
Free Software Foundation 1994-
Donated by Mark Burgess, Oslo University College, Norway
cf3 ------------------------------------------------------------------------
cf3 Host name is: atlas
cf3 Operating System Type is linux
cf3 Operating System Release is 2.6.22.18-0.2-default
cf3 Architecture = x86_64
cf3 Using internal soft-class linux for host linux
cf3 The time is now Sat Aug  2 11:26:06 2008
cf3 ------------------------------------------------------------------------
cf3 Additional hard class defined as: 64_bit
cf3 Additional hard class defined as: linux_2_6_22_18_0_2_default
cf3 Additional hard class defined as: linux_x86_64
cf3 Additional hard class defined as: linux_x86_64_2_6_22_18_0_2_default
cf3 GNU autoconf class from compile time: compiled_on_linux_gnu
cf3 Interface 1: lo
cf3 Trying to locate my IPv6 address
cf3 Looking for environment from cfenvd...
cf3 Unable to detect environment from cfMonitord
---------------------------------------------------------------------
Loading persistent classes
---------------------------------------------------------------------

---------------------------------------------------------------------
Loaded persistent memory
---------------------------------------------------------------------
cf3   > Parsing file ./test.cf
---------------------------------------------------------------------
Agent's basic classified context
---------------------------------------------------------------------


Defined Classes = ( any Saturday Hr11 Min26 Min25_30 Q2 Hr11_Q2 Day2
August Yr2008 linux atlas 64_bit linux_2_6_22_18_0_2_default x86_64
linux_x86_64 linux_x86_64_2_6_22_18_0_2_default
linux_x86_64_2_6_22_18_0_2_default__1_SMP_2008_06_09_13_53_20__0200
compiled_on_linux_gnu net_iface_lo )

Negated Classes = ( )

Installable classes = ( )
cf3 Wrote expansion summary to promise_output_common.html
cf3 Inputs are valid
@end smallexample


The last two lines of this are of interest. Each time a component of
cfengine 3 parses a number of promises, it summarizes the information
in an HTML file called generically @code{promise_output_@i{component-type}.html}.
In this case the @code{cf-promises} command represents all possible promises,
by the type "common". You can view this output file in a suitable web browser
to see exactly what cfengine has understood by the configuration.
The non-verbose output of the script when run in the cfengine 3 directory looks something like this:

@verbatim
host$ ./cf-agent -f ../tests/units/unit_exec_in_sequence.cf
Q ".../bin/echo Hello": Hello world - 46k/219
 -> Last 1 QUOTEed lines were generated by "/bin/echo Hello world - 46k/219"
Q ".../bin/ls": agent.c
Q ".../bin/ls": agentdiagnostic.c
Q ".../bin/ls": agentdiagnostic.o
Q ".../bin/ls": agent.o
Q ".../bin/ls": args.c
Q ".../bin/ls": args.lo
Q ".../bin/ls": args.o
...
Q ".../bin/ls": verify_reports.o
Q ".../bin/ls": verify_storage.c
Q ".../bin/ls": verify_storage.o
 -> Last 288 QUOTEed lines were generated by "/bin/ls"
atlas$
@end verbatim



@c ---------------------------------------------------------------------------
@node Remote access troubleshooting,  , Familiiarizing yourself, Getting started
@section Remote access troubleshooting

@menu
* Server connection::           
* Key exchange::                
* Time windows::                
* Other users than root::       
* Encryption::                  
@end menu

@node Server connection, Key exchange, Remote access troubleshooting, Remote access troubleshooting
@subsection Server connection

When setting up @code{cf-serverd}, you might see the error message

@verbatim
  Unspecified server refusal
@end verbatim

This means that @code{cf-serverd} is unable or is unwilling to
authenticate the connection from your client machine. The message is
generic: it is deliberately non-specific so that anyone attempting to
attack or exploit the service will not be given information which
might be useful to them. There is a simple checklist for curing this
problem:

@enumerate
@item 
Make sure that the domain variable is set in the configuration files read by both client
and server; alternatively use @code{skipidentify} and @code{skipverify} to decouple DNS from the
the authentication.

@item 
Make sure that you have granted access to your client in the server body

@smallexample

body server control
@{
allowconnects         => @{ "127.0.0.1" , "::1" @var{...etc} @};
allowallconnects      => @{ "127.0.0.1" , "::1" @var{...etc} @};
trustkeysfrom         => @{ "127.0.0.1" , "::1" @var{...etc} @};
@}

@end smallexample

@item 
Make sure you have created valid keys for the hosts using @code{cf-key}.
@item 
If you are using secure copy, make sure that you have created a key
file and that you have distributed and installed it to all
participating hosts in your cluster.
@end enumerate

@noindent Always remember that you can run cfengine in verbose or
debugging modes to see how the authentication takes place:

@verbatim
cf-agent -v 
cf-serverd -v
@end verbatim

@code{cf-agent} reports that access is denied regardless of the nature
of the error, to avoid giving away information which might be used by
an attacker. To find out the real reason for a denial, use verbose @samp{-v} or
even debugging mode @samp{-d2}.


@node Key exchange, Time windows, Server connection, Remote access troubleshooting
@subsection Key exchange

The key exchange model used by cfengine is based on that used by
OpenSSH. It is a peer to peer exchange model, not a central
certificate authority model. This means that there are no scalability
bottlenecks (at least by design, though you might introduce your own
if you go for an overly centralized architecture).

The problem of key distribution is the conundrum of every public key
infrastructure. Key exchange is handled automatically by cfengine and all you
need to do is to decide which keys to trust.

When public keys are offered to a server, they could be accepted
automatically on trust because no one is available to make a decision
about them. This would lead to a race to be the first to submit a key
claiming identity. 

Even with DNS checks for correct name/IP address correlation (turned
off with @code{skipverify}), it might be possible to submit a false
key to a server. 

The server @code{cf-serverd} blocks the acceptance of unknown keys by
default. In order to accept such a new key, the IP address of the
presumed client must be listed in the @code{trustkeysfrom} stanza. Once a key
has been accepted, it will never be replaced with a new key, thus no
more trust is offered or required.
   
Once you have arranged for the right to connect to the server, you
must decide which hosts will have access to which files. This is done
with @code{access} rules.

@verbatim

bundle server access_rules()

{
access:

  "/path/file"

    admit   => { "127.0.0.1", "127.0.0.2", "127.0.0.3" },
    deny    => { "192.*" };
}

@end verbatim

On the client side, i.e. @code{cf-runagent} and @code{cf-agent}, there are three issues:

@enumerate
@item 
Choosing which server to connect to.
@item 
Trusting the identity of any previously unknown servers, i.e. trusting
the server's public key to be its and no one else's. (The issues here are
the same as for the server.)
@item 
Choosing whether data transfers should be encrypted (with @code{encrypt}). 
@end enumerate

Because there are two clients for connecting to @code{cf-serverd}
(@code{cf-agent} and @code{cf-runagent}), there are also two ways on
managing trust of server keys by a client. One is an automated option, setting the option
@code{trustkey} in a @code{copy_from} stanza, e.g.

@verbatim

body copy_from example
     {
     # .. other settings ..
     trustkey => "true";
     }

@end verbatim

Another way is to run @code{cf-runagent} in interactive mode. When you run @code{cf-runagent}, unknown
server keys are offered to you interactively (as with @code{ssh}) for you to
accept or deny manually:

@smallexample

WARNING - You do not have a public key from host ubik.iu.hio.no = 128.39.74.25
          Do you want to accept one on trust? (yes/no)
-->

@end smallexample

@node Time windows, Other users than root, Key exchange, Remote access troubleshooting
@subsection Time windows (races)

Once public keys have been exchanged from client to server and from
server to client, the issue of trust is solved according to public key
authentication schemes. You only need to worry about trust when one side
of a connection has never seen the other side before.

Often you will have a central server and many client satellites. Then
the best way to transfer all the keys is to set the @code{trustkey}
flags on server and clients sides to coincide with a time at which you
know that @code{cf-agent} will be run, and when a spoofer is unlikely
to be able to interfere.

This is a once-only task, and the chance of an attacker being able to
spoof a key-transfer is small. It would require skill and
inside-information about the exchange procedure, which would tend to
imply that the trust model was already broken.

Another approach would be to run @code{cf-runagent} against all the hosts
in the group from the central server and accept the keys one by one,
by hand, though there is little to be gained from this.

Trusting a host for key exchange is unavoidable. There is no clever
way to avoid it. Even transferring the files manually by diskette, and
examining every serial number of the computers you have, the host has
to trust the information you are giving it. It is all based on
assertion. You can make it almost impossible for keys to be faked
or attacked, but you cannot make it absolutely impossible. Security is
about managing reasonable levels of risk, not about magic.

All security is based on a moment of trust at some point in
time. Cryptographic key methods only remove the need for a repeat of
the trust decision. After the first exchange, trust is no longer needed,
because they keys allow identity to be actually verified.

Even if you leave the trust options switched on, you are not blindly
trusting the hosts you know about. The only potential insecurity lies
in any new keys that you have not thought about. If you use wildcards
or IP prefixes in the trust rules, then other hosts might be able to
spoof their way in on trust because you have left open a hole for them
to exploit. That is why it is recommended to return the system to the
default state of zero trust immediately after key transfer, by
commenting out the trust options.


It is possible, though somewhat laborious to transfer the keys out of
band, by copying @file{/var/cfengine/ppkeys/localhost.pub} to
@code{/var/cfengine/ppkeys/user-aaa.bbb.ccc.mmm} (assuming IPv4) on
another host. e.g.

@smallexample

localhost.pub -> root-128.39.74.71.pub

@end smallexample

This would be a silly way to transfer keys between nearby hosts that you
control yourself, but if transferring to long distance, remote hosts
it might be an easier way to manage trust.

@node Other users than root, Encryption, Time windows, Remote access troubleshooting
@subsection Other users than root

Cfengine normally runs as user "root" (except on Windows which does
not normally have a root user), i.e. a privileged administrator. If other users
are to be granted access to the system, they must also generate a key
and go through the same process. In addition, the users must be added
to the server configuration file.

@node Encryption,  , Other users than root, Remote access troubleshooting
@subsection Encryption

Cfengine provides encryption for keeping file contents private during
transfer. It is assumed that users will use this judiciously. There is
nothing to be gained by encrypting the transfer of public files --
overt use of encryption just contributes to global warming, burning
unnecessary CPU cycles without offering any security.

The main role for encryption in configuration management is for
authentication. Cfengine always uses encrypted for authentication, so
none of the encryption settings affect the security of authentication.




@c ---------------------------------------------------------------------------
@node A simple crash course, How to run cfengine 3 examples, Getting started, Top
@chapter  A simple crash course in concepts

@menu
* Rules are promises::          
* Best practice for writing promises::  
* Containers::                  
* When and where are promises made?::  
* Types in cfengine 3::         
* Datatypes in cfengine 3::     
* Variable expansion in cfengine 3::  
* Normal ordering::             
* Loops and lists in cfengine 3::  
* Pattern matching and referencing::  
* Distributed discovery::       
* Developer structures::        
@end menu

@node Rules are promises, Best practice for writing promises, A simple crash course, A simple crash course
@section Rules are promises

Everything in cfengine 3 can be interpreted as a promise. Promises can
be made about all kinds of different subjects, from file attributes,
to the execution of commands, to access control decisions and
knowledge relationships.

This simple but powerful idea allows a very practical uniformity in
cfengine syntax.  There is only one grammatical form for statements in
the language that you need to know and it looks generically like this:

@smallexample

 type:

   classes::

    "promiser" -> @{ "promisee1", "promisee2", ... @}

       attribute_1 => value_1,
       attribute_2 => value_2,
       ...
       attribute_n => value_n;

@end smallexample

@noindent
We speak of a promiser (the abstract object making the promise), the promisee
is the abstract object to whom the promise is made, and them there is a list
of associations that we call the `body' of the promise, which together with the
promiser-type tells us what it is all about.

Not all of these elements are necessary every time. Some promises contain a lot
of implicit behaviour. In other cases we might want to be much more explicit.
For example, the simplest promise looks like this:

@smallexample

commands:

  "/bin/echo hello world";

@end smallexample

@noindent
This promise has default attributes for everything except the `promiser', i.e. the
command string that promises to execute.
A more complex promise contains many attributes:

@smallexample

files:

  "/home/mark/tmp/test_plain" -> "system blue team",

       comment => "This comment follows the rule for knowledge integration",
       perms   => users("@@(usernames)"),
       create  => "true";

@end smallexample
The list of promisees is not used by cfengine except for documentation, just
as the comment attribute (which can be added to any promise) has no actual function
other than to provide more information to the user in error tracing and auditing.

You see several kinds of object in this example. All literal strings
(e.g. @code{"true"}) in cfengine 3 must be quoted. This provides
absolute consistency and makes type-checking easy and error-correction
powerful. All function-like objects (e.g. @code{users("..")}) are either builtin
special functions or parameterized templates which contain the `meat' of the right hand
side.

The words @code{commands}, and @code{files} are built-in promise
types. Promise types generally belong each to a particular component
of cfengine, as the components are designed to keep different kinds of
promises.  A few types, such as @code{vars}, @code{classes} and
@code{reports} are common to all the different component bundles. You
will find a full list of the promise types that can be made by the
different components in the `bundles' chapters that follow.

@c -----------------------------------------------------------------------
@node Best practice for writing promises, Containers, Rules are promises, A simple crash course
@section Best practice for writing promises

When writing promises, get into the habit of giving every promise a comment
that explains its intention.

Also, give related promises @i{handles}, or labels that can be used to
refer to them by.

@verbatim

files:

  "/var/cfengine/inputs" 

    handle => "update_policy",

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;
   
@end verbatim
If a promise affects another promise is some way, you can make the affected
promise one of the promisees, like this:

@verbatim

access:

  "/master/cfengine/inputs" -> { "update_policy", "other_promisee" },

    handle  => "serve_updates",

    admit   => { "217.77.34.*" };

@end verbatim

Conversely, if a promise might depend on another in some (even indirect) way, document this too.

@verbatim

files:

  "/var/cfengine/inputs" 

    handle     => "update_policy",
    depends_on => "serve_updates",

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;


@end verbatim

Get into the habit of adding the cause-effect lines of influence.
Enterprise editions of cfengine will track the dependencies between these
promises and map out impact analyses.

@c -----------------------------------------------------------------------
@node Containers, When and where are promises made?, Best practice for writing promises, A simple crash course
@section Containers

Cfengine allows you to group multiple promise statements
    into containers called bundles.
@smallexample

bundle agent identifier

@{
commands:

  "/bin/echo These commands are a silly way to use cfengine";
  "/bin/ls -l";
  "/bin/echo But they illustrate a point";  

@}

@end smallexample

Bundles serve two purposes: they allow us to collect related promises under a
single heading, like a subroutine, and they allow us to mix configuration for different
parts of cfengine in the same file. The type of a bundle is the name of the component
of cfengine for which it is intended.

For instance, we can make a self-contained example agent-server
configuration by labelling the bundles:

@smallexample

#
# Not a complete example
#

bundle agent testbundle

@{
files:

  "/home/mark/tmp/testcopy" 

    copy_from    => mycopy("/home/mark/LapTop/words","127.0.0.1"),
    perms        => system,
    depth_search => recurse("inf");

@}

#

bundle server access_rules

@{
access:

  "/home/mark/LapTop"

    admit   => @{ "127.0.0.1" @};
@}

@end smallexample

Another type of container in cfengine 3 is a `body' part. Body parts
exist to hide complex parameter information in reusable containers.
The right hand side of some attribute assignments use body containers
to reduce the amount of in-line information and preserve readability.
You cannot choose where to use bodies: either they are used or they
are not used for a particular kind of attribute. What you can choose, however, is
the name and number of parameters for the body; and you can make as many of them as you like:
For example:

@smallexample

body copy_from mycopy(from,server)

@{
source      => "$(from)";
servers     => @{ "$(server)" @};
copy_backup => "true";

special_class::

  purge       => "true";
@}

@end smallexample

Notice also that classes can be used in bodies as well as parameters so that
you can hide environmental adaptations in these bodies also. The classes used
here are effectively ANDed with the classes under which the calling promise
is defined.


@c -----------------------------------------------------------------------
@node When and where are promises made?, Types in cfengine 3, Containers, A simple crash course
@section When and where are promises made?

When you type a promise into a cfengine bundle, the promise will be
read by every cf-agent that reads the file, each time it is
called into being. For some promises this is okay, but for others
you only want to verify the promise once in a while, e.g. once per day
or once per hour. There are two ways to say when and where a promise
applies in cfengine:

@table @i
@item Classes
Classes are the double-colon decision syntax in cfengine. They
determine in what context a promise is made, i.e. when and
where. Recall the basic syntax of a promise:
@smallexample

 @var{promise-type}:

    @var{class-expression}::

       @var{promiser} -> @var{promisee}

          @var{attribute} => @var{body},
               ifvarclass => @var{other-class-expression};

@end smallexample
The class expression may contain words like @samp{Hr12}, meaning
from 12:00 p.m - 13:00 p.m., or @samp{Hr12&Min05_10}, meaning
between 12:05 and 12:10. Classes may also have spatial descriptors
like @samp{myhost} or @samp{solaris}, which decide which hosts
in the namespace, or @samp{ipv4_192_168_1_101} which decides the location
in IPv4 address space. 

If the class expression is true, the promise can be considered made
for the duration of the current execution.

Cfengine 3 has a new class predicate @code{ifvarclass} which is
ANDed with the normal class expression, and which is evaluated
together with the promise. It may contain variables as long as the
resulting expansion is a legal class expression.
@cindex ifvarclass

@item Locks
Locks determine how often a promise is verified.
@end table

Cfengine is controlled by a series of locks which prevent it from
checking promises too often, and which prevent it from spending too
long trying to verify promises it already verified recently. The locks
work in such a way that you can start several cfengine processes
simultaneously without them interfering with each other. You can
control two things about each kind of action in the action sequence:

@table @samp

@item ifelapsed
The minimum time which should have passed since the last time
that promise was verified. It will not be executed again until
this amount of time has elapsed. 
(Default time is 1 minute.)

@item expireafter
The maximum amount of time cf-agent should wait for an old
instantiation to finish before killing it
and starting again. (Default time is 120 minutes.)

@end table

@noindent
You can set these values either globally (for all
actions) or for each action separately. If you
set global and local values, the local values override
the global ones. All times are written in units
of @emph{minutes}. Global setting is in the control body:

@verbatim

body agent control
{
ifelapsed => "60";
}

@end verbatim

@noindent
or locally in the transaction bodies:


@verbatim

body action example
{
ifelapsed => "60";
}

@end verbatim

These locks do not prevent the whole of cf-agent from running, only
atomic promise checks. Several different atoms can be run concurrently
by different cf-agents.  The locks ensure that atoms will never be
started by two cf-agents at the same time, or too soon after a
verification, causing contention and wasting CPU cycles.


@c -----------------------------------------------------------------------
@node Types in cfengine 3, Datatypes in cfengine 3, When and where are promises made?, A simple crash course
@section Types in cfengine 3

A key difference in cfengine 3 compared to earlier versions is the
presence of data types. Data types are a mechanism for associating
values and checking consistency in a language. Once again, there is a 
simple pattern to types in cfengine.

The principle is very simple: types exist in order to match like a
plug-socket relationship. In the examples above, you can see two places
where types are used to match templates:

@itemize
@item Matching bundles to components:
@smallexample

bundle TYPE name  # matches TYPE to running agent
@{
@}

@end smallexample

@item Match bodies templates to lvalues in @code{lvalues => rvalue} constraints:

@smallexample

body TYPE name    # matches TYPE => name in promise
@{
@}

@end smallexample
@end itemize

Check these by identifying the words @samp{agent} and @samp{copy_from}
in the examples above. Types are there to make configuration more robust.

@c -----------------------------------------------------------------------
@node Datatypes in cfengine 3, Variable expansion in cfengine 3, Types in cfengine 3, A simple crash course
@section Datatypes in cfengine 3

Cfengine variables have two meta-types: scalars and lists. A scalar is a single value,
a list is a collection of scalars. Each scalar may have one of three types: 
@code{string}, @code{int} or @code{real}. Typing is dynamic, so these are
interchangable in many instances. However arguments to special functions check legal
type for consistency.

Integer constants may use suffixes to represent large numbers.

@itemize
  @item 'k'
          times 1000.

  @item 'K':
          times 1024.

  @item 'm':
          times 1000^2
  @item 'M':
          times 1024^2
  @item 'g':
          times 1000^3
  @item 'G':
          times 1024^3

  @item '%'
    meaning percent, in limtied contexts

@item inf
A constant representing an unlimited value.
@end itemize

@c -----------------------------------------------------------------------
@node Variable expansion in cfengine 3, Normal ordering, Datatypes in cfengine 3, A simple crash course
@section Variable expansion in cfengine 3

Cfengine 3 has some simple rules for variable expansion. These make
a couple of restrictions that enforce discipline of clarity and
allow automatic dependency tracking in enterprise versions of cfengine.

@menu
* Scalar variable expansion::   
* List variable substitution and expansion::  
* Arrays in cfengine 3::        
@end menu

@node Scalar variable expansion, List variable substitution and expansion, Variable expansion in cfengine 3, Variable expansion in cfengine 3
@subsection Scalar variable expansion

Scalar variables are written @samp{$(name)} and they represent
a single value at a time.

@itemize
@item Scalars that are written without a context, e.g. @samp{$(myvar)}
are local to the current bundle.

@item Scalars are globally available everywhere provided one
uses the context to verify them e.g. @samp{$(context.myvar)}
may be written to access the variable `myvar' in bundle `context'.

@end itemize

@c -----------------------------------------------------------------------
@node List variable substitution and expansion, Arrays in cfengine 3, Scalar variable expansion, Variable expansion in cfengine 3
@subsection List variable substitution and expansion

@itemize

@item Scalar references to @i{local} list variables imply iteration, e.g.
suppose we have local list variable @samp{@@(list)}, then the
scalar @samp{$(list)} implies an iteration over every value of the
list.


@item Lists can be passed around in their entirety in any context
where a list is expected as @samp{@@(list)}., e.g.

@verbatim

 vars:

   "longlist" slist => { @(shortlist), "plus", "plus" };
  
   "shortlist" slist => { "you", "me" }; 

@end verbatim

@item Only local lists can be expanded directly. Thus @samp{$(list)}
can be expanded but not @samp{$(context.list)}. See below for the
explanation.

@end itemize

During list expansion, only local lists can be expanded, thus global
list references have to be mapped into a local context if you want to
use them for iteration. Instead of doing this in some
arbitrary way, with possibility of name collisions, cfengine
asks you to make this explicit. There are two possible approaches.

The first uses parameterization to map a global list into a local
context.
@verbatim

#
# Show access of external lists.
#
# - to pass lists globally, use a parameter to dereference them
#

body common control
{
bundlesequence => { hardening(@(va.tmpdirs)) };
}

#########################################################

bundle common va 
{
vars:
 
 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

} 

##########################################################

bundle agent hardening(x)
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
} 

@end verbatim

This alternative uses a direct `short-circuit' approach to map the global
list into the local context.

@verbatim
#
# Show access of external lists.
#

body common control
{
bundlesequence => { hardening };
}

#########################################################

bundle common va 
{
vars:
 
 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

} 

##########################################################

bundle agent hardening
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };
 "x"        slist => { @(va.tmpdirs) };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
} 
@end verbatim

@c ----------------------------------------------------------------------- 
@node Arrays in cfengine 3,  , List variable substitution and expansion, Variable expansion in cfengine 3
@subsection Arrays in cfengine 3

Arrays variables are written with @samp{[} and @samp{]} brackets, e.g.

@verbatim

bundle agent example

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-execd]" string => "The executor, not executionist";

commands:

   "/bin/echo $(component) is"

            args => "$(array[$(component)])";

}

@end verbatim

Arrays are associative and may be of type scalar or list. Enumerated
arrays are simply treated as a special case of associative arrays, since
there are no numerical loops in cfengine. Special functions exist to
extract lists of keys from array variables for iteration purposes.

Thus one could have written the example above in the form of the
following example:

@verbatim

bundle agent array

{
vars:

  "v[index_1]" string => "value_1";
  "v[index_2]" string => "value_2";

  "parameter_name" slist => getindices("v");

reports:

  Yr2008::

   "Found index: $(parameter_name)";

}

@end verbatim

@c -----------------------------------------------------------------------
@node Normal ordering, Loops and lists in cfengine 3, Variable expansion in cfengine 3, A simple crash course
@section Normal ordering

Ordering of promise verification within cfengine takes a pragmatic approach.
In the absence of dependencies (independent) promises can be checked in any
order. However, one can encode both implicit and explicit ordering dependency.

Cfengine takes a pragmatic point of view to ordering, since certain
data structures require ordering to be preserved, e.g. editing in
files. The rules are as follows:

@enumerate
@item 
Cfengine executes promise bundles in the strict order defined by
the @code{bundlesequence}.
@item
Within a bundle, the promise types are executed in a round-robin
fashion according to so-called `normal ordering' (essentially deletion
first followed by creation). The actual sequence continues for up to three
iterations of the following:
@verbatim

   vars
   classes
   interfaces
   processes
   storage
   packages
   commands
   methods
   files
   reports

@end verbatim
Within line_editing bundles, the normal ordering is:
@verbatim
   vars
   classes
   delete_lines
   field_edits
   insert_lines
   replace_patterns
   reports
@end verbatim

@item 
The order of promises within one of the above types follows their
top-down ordering within the bundle itself.

@item
The order may be overridden by making a promise depend on a class
that is set by another promise.

@end enumerate

@c -----------------------------------------------------------------------
@node Loops and lists in cfengine 3, Pattern matching and referencing, Normal ordering, A simple crash course
@section Loops and lists in cfengine 3

There are no explicit loops in cfengine, instead there are lists.
To make a loop, you simply refer to a list as a scalar and cfengine
will assume a loop over all items in the list.

For example, in the excepts below the list @code{component} has three
elements. The list as a whole may be referred to as
@code{@@(component)}, in order to pass the whole list to a promise
where a list is expected. However, if we write @code{$(component)},
i.e. the scalar variable, then cfengine assumes that it should substitute
each scalar from the list in turn, and thus iterate over the list
elements using a loop.

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "new_list" slist => { "cf-know", @(component) };

processes:

  "$(component)" restart_class => canonify("start_$(component)");

commands:

   "/bin/echo /var/cfengine/bin/$(component)"

       ifvarclass => canonify("start_$(component)");
}

@end verbatim

If a variable is repeated, its value is tied throughout
the expression; so the output of:

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-execd]" string => "The executor, not executionist";

commands:

   "/bin/echo $(component) is"

            args => "$(array[$(component)])";
}

@end verbatim

@noindent is as follows:

@verbatim

Q ".../bin/echo cf-mo": cf-monitord is The monitor
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-monitord is The monitor"
Q ".../bin/echo cf-se": cf-serverd is The server
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-serverd is The server"
Q ".../bin/echo cf-ex": cf-execd is The executor, not executionist
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-execd is The executor, not executionist"

@end verbatim


@c -----------------------------------------------------------------------
@node Pattern matching and referencing, Distributed discovery, Loops and lists in cfengine 3, A simple crash course
@section Pattern matching and referencing

One of the strengths of cfengine 3 is the ability to recognize and
exploit patterns.  All string patterns in cfengine 3 are matched using
regular expressions. The preferred regular expression library is the
Perl Compatible Regular Expression library. This is more powerful and
more reliable than the default POSIX regular expression code and all
users should make the PCRE library available during compilation if
possible.

Cfengine has the ability to extract back-references from pattern matches.
This makes sense in two cases. Back references are fragments of a string
that match parenethetic expressions. For instance, suppose we have the string:

@smallexample

 Mary had a little lamb ...

@end smallexample

@noindent and apply the regular expression

@smallexample

 "Mary ([^l]+)little (.*)"

@end smallexample
The pattern matches the entire string, and it
contains two parentheses, which respectively match
the fragments `has a ' and `lamb ...'. The regular
expression libraries assign three matches to this
result, labelled 0, 1 and 2. 

The zeroth value is the entire string matched by the
total expression. The first value is the fragment matched
by the first parenthesis, and so on.

Each time cfengine matches a string, these values are
assigned to a special variable context @code{$(match.@var{n})}.
The fragments can be referred to in the remainder of the promise.
There are two places where this makes sense. One is in pattern replacement
during file editing, and the other is in searching for files.

Consider the examples below:
@verbatim

bundle agent testbundle

{
files:

  # The back reference in a path only applies to the last link
  # of the pathname, so the (tmp) gets ignored

  "/home/mark/(tmp)/(cf3)_(.*)"
       create    => "true",
       edit_line => myedit("second $(match.2)");


  # but ...

  "/home/mark/(tmp)/cf3_test"
       create    => "true",
       edit_line => myedit("second $(match.1)");


}

@end verbatim
If there were to exist a file @file{/home/mark/tmp/cf3_test},
then we would have:

@table @samp
@item $(match.0)
equal to `/home/mark/tmp/cf3_test'
@item $(match.1)
equal to `tmp'
@item $(match.2)
equal to `cf3'
@item $(match.3)
equal to `test'
@end table

Now look at the edit bundle. This uses back references to
replace shell comment lines with C comment lines. (The same
approach is used to hash-comment lines in files).

@verbatim

bundle edit_line myedit(parameter)
  {
  vars:

   "edit_variable" string => "private edit variable is $(parameter)"; 

  insert_lines:

     "$(edit_variable)";
  
  replace_patterns:

  # replace shell comments with C comments

   "#(.*)"

      replace_with => C_comment,
     select_region => MySection("New section");

  }

########################################
# Bodies
########################################

body replace_with C_comment

{
replace_value => "/* $(match.1) */"; # backreference 0
occurrences => "all";  # first, last all
}

########################################################

body select_region MySection(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

@end verbatim

Try this example on the file
@verbatim
[First section]

one
two 
three

[New section]

four
#five
six

[final]

seven
eleven
@end verbatim

@noindent The resulting file is edited like this:
@verbatim
[First section]

one
two
three

[New section]

four
/* cf3 */
six

[final]

seven
eleven

private edit variable is second test
@end verbatim


@menu
* Runaway change warning::      
* Commenting lines::            
@end menu

@node Runaway change warning, Commenting lines, Pattern matching and referencing, Pattern matching and referencing
@subsection Runaway change warning

Be careful when using patterns to search for files that are altered by cfengine
is you are not using a file repository. Each time cfengine makes a change it
saves an old file into a copy like @file{cf3_test.cf-before-edit}. These
new files then get matched by the same expression above -- because it ends
in the generic@code{.*}), or does not
specify a tail for the expression. Thus cfengine will happily edit backups
of the edit file too, and generate a recursive process, resulting in something
like the following:

@smallexample
cf3_test                  cf3_test.cf-before-edit
cf3_test~                 cf3_test~.cf-before-edit.cf-before-edit
cf3_test~.cf-before-edit  cf3_test~.cf-before-edit.cf-before-edit.cf-before-edit
@end smallexample

Always try to be as specific as possible when specifying patterns. A lazy approach
will often come back to haunt you.


@node Commenting lines,  , Runaway change warning, Pattern matching and referencing
@subsection Commenting lines

The following example shows how you would hash-comment lines in a file
using cfengine 3.

@verbatim
######################################################################
#
# HashCommentLines implemented in cfengine 3
#
######################################################################

body common control

{
version => "1.2.3";
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
files:

  "/home/mark/tmp/comment_test"

       create    => "true",
       edit_line => comment_lines_matching;
}

########################################################

bundle edit_line comment_lines_matching
  {
  vars:

    "regexes" slist => { "one.*", "two.*", "four.*" };

  replace_patterns:

   "^($(regexes))$"
      replace_with => comment("# ");
  }

########################################
# Bodies
########################################

body replace_with comment(c)

{
replace_value => "$(c) $(match.1)";
occurrences => "all";
}

@end verbatim


@c ----------------------------------------------------------------------------
@node Distributed discovery, Developer structures, Pattern matching and referencing, A simple crash course
@section Distributed discovery

Cfengine's philosophy and modus operandi is to make machines as self-reliant
as possible. This is the path to scalability. Sometimes we want machines
to be able to detect one another and sample each others' behaviour. This can
be accomplished using probes and server functions. 

For example, testing whether services are up and running can be a useful
probe even from a local host. Cfengine has in-built functions for generically
probing the environment; these are designed to encourage decentralized
monitoring.

@verbatim

body common control

{
bundlesequence  => { "test"  };
}

###########################################################

bundle agent test

{     
vars:

 "hosts" slist => { "server1.example.org", "server2", "server3" };
 
 "up_servers" int =>  selectservers("@(hosts)","80","","","100","alive_servers");

classes:

  "someone_alive" expression => isgreaterthan("$(up_servers)","0");

  "i_am_a_server" expression => regarray("up_servers","$(host)|$(fqhost)");

reports:

  someone_alive::

    "Number of active servers $(up_servers)" action => always;

    "First server $(alive_servers[0]) fails over to $(alive_servers[1])";


}

@end verbatim


@c ----------------------------------------------------------------------------
@node Developer structures,  , Distributed discovery, A simple crash course
@section Developer structures

Developers may note that the internal data-types follow a simple set
of internal linked lists, as in the diagram below.

@image{list_expand,10cm,,The type relationships in list expansion,png}


@c -----------------------------------------------------------------------

@node How to run cfengine 3 examples, A complete configuration, A simple crash course, Top
@chapter How to run cfengine 3 examples

The cfengine @file{tests} directory contains a multitude of examples of cfengine 3 code.
These instructions assume that you have all of your configuration in a
single test file, such as the example in the distribution directory
@file{tests/units}.

@enumerate
@item Test the file as a non-privileged user first, if you can.

@item Always verify syntax first with @code{cf-promises}. This requires no privileges.
An @code{cf-agent} will not execute a configuration that has not passed this test.

@smallexample

host$ cf-promises -f ./inputfile.cf

@end smallexample

@item Run the examples like this, e.g.

@smallexample

host$ src/cf-promises -f ./tests/units/unit_server_copy_localhost.cf
host$ src/cf-serverd -f ./tests/units/unit_server_copy_localhost.cf
host$ src/cf-agent -f ./tests/units/unit_server_copy_localhost.cf

@end smallexample

@end enumerate

Running @code{cf-agent} in verbose mode provides detailed information
about the state of the systems promises.

@smallexample
Outcome of version 1.2.3: Promises observed to be kept 99%, 
Promises repaired 1%, Promises not repaired 0%
@end smallexample

The log-file @file{WORKDIR/promise.log} contains the summary of these reports
with timestamps. This is the simplest kind of high level audit record of the
system.




@c ---------------------------------------------------------------------------
@node A complete configuration, Control Promises, How to run cfengine 3 examples, Top
@chapter A complete configuration

To illustrate a complete configuration for agents and daemons,
consider the following example code, supplied in the @file{inputs/}
directory of the distribution. Comments indicate the thinking behind
this starting point.


@menu
* promises.cf::                 
* site.cf::                     
* update.cf::                   
* failsafe.cf::                 
* What should a failsafe or update file contain::  
* Recovery from errors in the configuration::  
* Recovery from errors in the software::  
@end menu

@node promises.cf, site.cf, A complete configuration, A complete configuration
@section @file{promises.cf}

This file is the first file that @code{cf-agent} with no arguments
will try to look for. It should contain all of the basic
configuration settings, including a list of other files
to include. It should have a @code{bundlesequence}.

This file can stay fixed, except for extending the bundlesequence.
The bundlesequence acts like the `genetic makeup' of the configuration.
In a large configuration, you will want to have a different bundlesequence
for different classes of host. Use list variables to paste in 
list fragments to describe the make-up of each class. 

@verbatim
#######################################################
#
# promises.cf
#
#######################################################

body common control

{
# List the `genes' for this system..

bundlesequence  => { 
                   "update",
                   "garbage_collection",
                   "main",
                   "cfengine"  
                   };


inputs          => {
                   "update.cf",
                   "site.cf",
                   "library.cf" 
                   };
}

#######################################################
# Now set defaults for all components' hard-promises
#######################################################

body agent control
{
# if default runtime is 5 mins we need this for long jobs
ifelapsed => "15";
}

#######################################################

body monitor control
{
forgetrate => "0.7";
histograms => "true";
}

#######################################################

body executor control

{
splaytime => "1";
mailto => "cfengine_mail@example.org";
smtpserver => "localhost";
mailmaxlines => "30";

# Instead of a separate update script, now do this

exec_command => "$(sys.workdir)/bin/cf-agent -f failsafe.cf && $(sys.workdir)/bin/cf-agent";
}

#######################################################

body reporter control

{
reports => { "performance", "last_seen", "monitor_history" };
build_directory => "/tmp/nerves";
report_output => "html";
}

#######################################################

body runagent control
{
hosts => { 
          "127.0.0.1" 
          # , "myhost.example.com:5308", ...
         };

}

#######################################################

body server control 

{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };

# Make updates and runs happen in one

cfruncommand => 

 "$(sys.workdir)/bin/cf-agent -f failsafe.cf && $(sys.workdir)/bin/cf-agent";

allowusers   => { "root" };
}

@end verbatim



@node site.cf, update.cf, promises.cf, A complete configuration
@section @file{site.cf}

Use this file to add your site-specific configuration.
Common bundles can be used to define global variables.
Otherwise, unqualified variables are local to the bundle in which
they are defined -- however they can be access by
writing @code{$(bundle.variable)}.

@verbatim
#######################################################
#
# site.cf
#
#######################################################

bundle common g
{
vars:

  SuSE::

   "crontab" string => "/var/spool/cron/tabs/root";

 !SuSE::

   "crontab" string => "/var/spool/cron/crontabs/root";
}

@end verbatim

The cfengine bundle below detects whether cfengine 2 is already
running on the host or not, and if so attempts to kill off old daemon
processes and encapsulate the agent. It also looks for rules in the
old cfengine configuration that would potentially spoil cfengine 3's
control of the system: the last thing we want is for cfengine 2 and
cfengine 3 to fight each other for control of the system.  Cfengine 3
tries to edit an existing crontab entry to replace any references to
@code{cfexecd} with @code{cf-execd}; if none are found it will add a 5
minute run schedule.  You should never put @code{cf-agent}or
@code{cf-agent} directly inside @code{cron} without the @code{cf-execd}
wrapper.

@verbatim
#######################################################
# Start with cfengine itself
#######################################################

bundle agent cfengine

{
classes:

  "integrate_cfengine2" 

      and => { 
             fileexists("$(sys.workdir)/inputs/cfagent.conf"), 
             fileexists("$(sys.workdir)/bin/cfagent")
             };

vars:

   "cf2bits" slist => { "cfenvd", "cfservd", "cfexecd" };

commands:

 integrate_cfengine2:: 

   "$(sys.workdir)/bin/cfagent"

        action => longjob;

files:

  # Warn about rules relating to cfengine 2 in inputs - could conflict

  "$(sys.workdir)/inputs/.*"

       comment     => "Check if there are still promises about cfengine 2 that need removing",
       edit_line   => DeleteLinesMatching(".*$(cf2bits).*"),
       file_select => OldCf2Files,
       action      => WarnOnly;

  # Check cf-execd and schedule is in crontab

  "$(g.crontab)"
       edit_line => upgrade_cfexecd,
         classes => define("exec_fix");

processes:

  exec_fix::

    "cron" signals => { "hup" };


}

#######################################################
# General site issues can be in bundles like this one
#######################################################

bundle agent main

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd" };

 # - - - - - - - - - - - - - - - - - - - - - - - -

files:

  "$(sys.resolv)"  # test on "/tmp/resolv.conf" #

     create        => "true",
     edit_line     => resolver,
     edit_defaults => def;

 # Uncomment this to perform a change-detection scan

 #  "/usr"         
 #     changes      => lay_trip_wire,
 #     depth_search => recurse("inf"),
 #     action       => measure;

processes:

  "cfenvd"             signals => { "term" };

 # Uncomment this when you are ready to upgrade the server
 #
 #  "cfservd"             signals => { "term" };
 #

 # Now make sure the new parts are running, cf-serverd will fail if
 # the old server is still running 

  "$(component)" restart_class => canonify("start_$(component)");

 # - - - - - - - - - - - - - - - - - - - - - - - -

commands:

   "$(sys.workdir)/bin/$(component)"

       ifvarclass => canonify("start_$(component)");

}

@end verbatim

This section takes a backup of a user home directory.  This is
especially useful for a single laptop or personal workstation that
does not have a regular external backup. If a user deletes a file by
accident, this shadow backup might contain the file even while
travelling offline.

@verbatim

#######################################################
# Backup
#######################################################

bundle agent backup
{
files:

  "/home/backup"

     copy_from => cp("/home/mark"),
  depth_search => recurse("inf"),
   file_select => exclude_files,
        action => longjob;

}

#######################################################
# Garbage collection issues
#######################################################

bundle agent garbage_collection
{
files:

  "$(sys.workdir)/outputs" 

    delete => tidy,
    file_select => days_old("3"),
    depth_search => recurse("inf");


}

###########################################################

body file_select OldCf2Files
{
leaf_name => { 
             "promises.cf", 
             "site.cf", 
             "library.cf", 
             "failsafe.cf", 
             ".*.txt", 
             ".*.html", 
             ".*~",
             "#.*" 
             };

file_result => "!leaf_name";
}

###########################################################

body action measure
{
measurement_class => "Detect Changes in /usr";
ifelapsed => "240";
expireafter => "240";
}

@end verbatim

Some basic anomaly detection: we respond with simple warnings
if resource anomalies are detected.

@verbatim
#######################################################
# Anomaly monitoring
#######################################################

bundle agent anomalies
{
reports:

rootprocs_high_dev2::

   "RootProc anomaly high 2 dev on $(mon.host) at $(mon.env_time) 
    measured value $(mon.value_rootprocs) av $(mon.av_rootprocs) 
    pm $(mon.dev_rootprocs)"

      showstate => { "rootprocs" };

entropy_www_in_high&anomaly_hosts.www_in_high_anomaly::

   "HIGH ENTROPY Incoming www anomaly high anomaly dev!! 
    on $(mon.host) at $(mon.env_time) 
    - measured value $(mon.value_www_in) 
    av $(mon.av_www_in) pm $(mon.dev_www_in)"
   
      showstate => { "incoming.www" };

 entropy_www_in_low.anomaly_hosts.www_in_high_anomaly::

   "LOW ENTROPY Incoming www anomaly high anomaly dev!! 
    on $(mon.host) at $(mon.env_time)
     - measured value $(svalue_www_in) 
    av $(av_www_in) pm $(dev_www_in)"

     showstate => { "incoming.www" };

entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2::

   "Anomalous number of new TCP connections on $(mon.host) 
    at $(mon.env_time) 
    - measured value $(mon.value_tcpsyn_in) 
    av $(mon.av_tcpsyn_in) pm $(mon.dev_tcpsyn_in)"

     showstate => { "incoming.tcpsyn" };

 entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly::

   "Anomalous (3dev) incoming DNS packets on $(mon.host) 
    at $(mon.env_time) - measured value $(mon.value_dns_in) 
    av $(av_dns_in) pm $(mon.dev_dns_in)"
   
     showstate => { "incoming.dns" };

 entropy_dns_in_low.anomaly_hosts.udp_in_high_dev2::

   "Anomalous (2dev) incoming (non-DNS) UDP traffic 
    on $(mon.host) at $(mon.env_time) - measured value 
    $(mon.value_udp_in) av $(mon.av_udp_in) pm $(mon.dev_udp_in)"

     showstate => { "incoming.udp" };

 anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high::

   "Anomalous low entropy (3dev) incoming ICMP traffic 
    on $(mon.host) at $(mon.env_time) - measured value $(mon.value_icmp_in) 
    av $(mon.av_icmp_in) pm $(mon.dev_icmp_in)"
   
     showstate => { "incoming.icmp" };
}

@end verbatim

Server access rules are a touchy business. In an enterprise
setting you generally want every host to allow a monitoring
host to be able to download data, and a backup host to be able
to access important data on every host. On a laptop or personal
workstation, there might not be any reason to run a server
for external use; however you might configure it as below
to allow localhost access for testing.

@verbatim

#######################################################
# Server configuration
#######################################################

bundle server access_rules()
{
access:

  "/home/mark/test_area"

    admit   => { "127.0.0.1" };

  # Rule for cf-runagent

  "/home/mark/.cfagent/bin/cf-agent"

    admit   => { "127.0.0.1" };

# New in cf3 - RBAC with cf-runagent

roles:

  ".*"  authorize => { "mark" };
}

@end verbatim


@node update.cf, failsafe.cf, site.cf, A complete configuration
@section @file{update.cf}

This file should never change. If you ever change it, or when you
upgrade cfengine, make sure the old and the new cfengine can
parse and execute this file. If not, you risk losing control of
your system.

@verbatim
#########################################################
#
# update.cf
#
#########################################################

bundle agent update
{
vars:

 "master_location" string => "/your/master/cfengine-inputs";

files:

  # Update the configuration

  "/var/cfengine/inputs" 

    perms => system("600"),
    copy_from => mycopy("$(master_location)","localhost"),
    depth_search => recurse("inf"),
    action => immediate;

  # Update the software cache

  "/var/cfengine/bin" 

    perms => system("700"),
    copy_from => mycopy("/usr/local/sbin","localhost"),
    depth_search => recurse("inf"),
    action => immediate;
}

############################################

body perms system(p)

{
mode  => "$(p)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source      => "$(from)";
compare     => "digest";
}

#########################################################

body action immediate
{
ifelapsed => "1";
}
@end verbatim




@node failsafe.cf, What should a failsafe or update file contain, update.cf, A complete configuration
@section @file{failsafe.cf}

This file should never change. If you ever change it, or when you
upgrade cfengine, make sure the old and the new cfengine can
parse and execute this file. If not, you risk losing control of
your system.

@verbatim
#########################################################
#
# Failsafe file
#
#########################################################

body common control

{
bundlesequence => { "update" };

inputs => { "update.cf" };
}

############################################

body depth_search recurse(d)

{
depth => "$(d)";
}

@end verbatim


@node What should a failsafe or update file contain, Recovery from errors in the configuration, failsafe.cf, A complete configuration
@section What should a failsafe and update file contain?


The @file{failsafe.cf} file is to make sure that your system can
upgrade gracefully to new versions even when mistakes are made.


As a general rule:
@itemize

@item 
Upgrade the software first, then add new features
to the configuration. 

@item 
Never use advanced features in the failsafe or update file.

@item 
Avoid using library code. Paste it in explicitly using a special
name that does not collide with a name in library. The update
process should not have @i{any} dependencies.

@end itemize

@noindent A cfengine configuration will fail-over to the failsafe configuration
if it is unable to read or parse the contents successfully. That means
that any new features you try in a configuration will cause a
fail-over, because the parser will not be able to interpret the new
features until the software itself has been updated.



@node Recovery from errors in the configuration, Recovery from errors in the software, What should a failsafe or update file contain, A complete configuration
@section Recovery from errors in the configuration

The @file{failsafe.cf} file should be able to download the latest
master configuration from source always.

@verbatim

#######################################################
#
# failsafe.cf
#
#######################################################

body common control

{
bundlesequence => { "update" };
}

#########################################################

bundle agent update
{
files:

  "/var/cfengine/inputs" 

    perms => system,
    copy_from => mycopy("/home/mark/cfengine-inputs","localhost"),
    depth_search => recurse("inf");

  "/var/cfengine/bin" 

    perms => system,
    copy_from => mycopy("/usr/local/sbin","localhost"),
    depth_search => recurse("inf");

}

#########################################################

body perms system

{
mode  => "0700";
}

#########################################################

body depth_search recurse(d)

{
depth => "$(d)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source       => "$(from)";
servers      => { "$(server)" , "failover.domain.tld" };
#copy_backup => "true";
#trustkey    => "true";
encrypt      => "true";
}

@end verbatim

@noindent If the @code{copy_backup} option is true, cfengine will keep a single
previous version of the file before copy, if the value is @samp{timestamp}
cfengine keeps time-stamped versions either in the location of the file, or in the
file repository if one is defined. The @code{trustkey} option should normally
be commented out so that public keys are only exchanged under controlled conditions.


@node Recovery from errors in the software,  , Recovery from errors in the configuration, A complete configuration
@section Recovery from errors in the software

The update should optionally include an update of software
so that a single failover from a configuration that is `too new'
for the software will still correct itself once the new software
is available.

@verbatim

#######################################################
#
# update.cf
#
#######################################################

bundle agent update

{
files:

  "/var/cfengine/inputs" 

    perms => system("600"),
    copy_from => mycopy("/home/mark/cfengine-inputs","localhost"),
    depth_search => recurse("inf");

  "/var/cfengine/bin" 

    perms => system("700"),
    copy_from => mycopy("/usr/local/sbin","localhost"),
    file_select => cf3_files,
    depth_search => recurse("inf");

}

############################################

body perms system(p)

{
mode  => "$(p)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source      => "$(from)";
compare     => "digest";
}

@end verbatim

@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Control Promises, Bundles for common, A complete configuration, Top
@chapter Control promises

@*

While promises to configure your system are entirley user-defined, the
details of the operational behaviour of the cfengine software is of
course hard-coded. You can still configure the details of this
behaviour using the control promise bodies. Control behaviour is
defined in bodies because the actual promises are fixed and you only
change their details within sensible limits.

Note that in cfengine's previous versions, the @code{control} part of
the configuration contained a mixture of internal control parameters
and user definitions. There is now a cleaner separation in
cfengine 3. User defined behaviour requires a promise, and must
therefore be defined in a bundle.

Below is a list of the control parameters for the different components
(Agents and Daemons@footnote{There is no Da Vinci code in cfengine}) of the cfengine software.


@menu
* control common::              
* control agent::               
* control server::              
* control monitor::             
* control runagent::            
* control executor::            
* control knowledge::           
* control reporter::            
@end menu

@node control common, control agent, Control Promises, Control Promises
@section @code{common} control promises

@*


@cartouche
@smallexample

body common control

@{
inputs  => @{
           "update.cf",
           "library.cf"
           @};

bundlesequence  => @{
                   update("policy_host.domain.tld"),
                   "main",
                   "cfengine2"
                   @};

output_prefix => "cfengine>";
version => "1.2.3";
@}

@end smallexample
@end cartouche


@*

the @code{common} control body refers to those promises that are
hard-coded into all the components of cfengine, and therefore affect
the behaviour of all the components.



@menu
* bundlesequence in common::    
* inputs in common::            
* version in common::           
* lastseenexpireafter in common::  
* output_prefix in common::     
* domain in common::            
* require_comments in common::  
@end menu

@node bundlesequence in common, inputs in common, control common, control common
@subsection @code{bundlesequence}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: List of promise bundles to verify in order


@noindent @b{Example}:@*
@*

@verbatim
body common control

{
#..
bundlesequence  => {
                   update("policy_host.domain.tld"),
                   "main",
                   "cfengine2"
                   };
}
@end verbatim


@noindent @b{Notes}:@*
@*

The @code{bundlesequence} determines whether compiled bundles will be executed and
in what order they will be executed. The list refers to the names of bundles
which might be parameterized function-like objects.

The @code{bundlesequence} is like a genetic makeup of a machine. The bundles
act like characteristics of the systems. If you want different systems to have
different bundlesequences, distinguish them with classes:

@verbatim
webservers::

  bundlesequence => { "main", "web" };

others::

  bundlesequence => { "main", "otherstuff" };

@end verbatim

If you want to add a basic common sequence to all sequences, then use
global variable lists to do this:

@verbatim
body agent control
{
webservers::

  bundlesequence => { @(g.bs), "web" };

others::

  bundlesequence => { @(g.bs), "otherstuff" };

}

bundle common g
{
vars:

  "bs" slist => { "main", "basic_stuff" }; 
}

@end verbatim



@node inputs in common, version in common, bundlesequence in common, control common
@subsection @code{inputs}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: List of filenames to parse for promises


@noindent @b{Example}:@*
@*

@verbatim

body common control
{
inputs  => {
           "update.cf",
           "library.cf"
           };
}

@end verbatim


@noindent @b{Notes}:@*
@*



@node version in common, lastseenexpireafter in common, inputs in common, control common
@subsection @code{version}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Scalar version string for this configuration


@noindent @b{Example}:@*
@*



@verbatim

body common control
{
version => "1.2.3";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The version string is used in error messages and reports.



@node lastseenexpireafter in common, output_prefix in common, version in common, control common
@subsection @code{lastseenexpireafter}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Number of minutes after which last-seen entries are purged


@noindent @b{Example}:@*
@*


@noindent @b{Notes}:@*
@*

@verbatim

body common control
{
lastseenexpireafter => "72";
}

@end verbatim



@node output_prefix in common, domain in common, lastseenexpireafter in common, control common
@subsection @code{output_prefix}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The string prefix for standard output


@noindent @b{Example}:@*
@*

@verbatim

body common control
{
output_prefix => "my_cf3";
}

@end verbatim


@noindent @b{Notes}:@*
@*




@node domain in common, require_comments in common, output_prefix in common, control common
@subsection @code{domain}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Specify the domain name for this host


@noindent @b{Example}:@*
@*

@verbatim

body common control
{
domain => "example.org";
}

@end verbatim


@noindent @b{Notes}:@*
@*

There is no standard, universal or reliable way of determining the
DNS domain name of a host, so it can be set explicitly to simplify
discovery and name-lookup.




@node require_comments in common,  , domain in common, control common
@subsection @code{require_comments}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Warn about promises that do not have comment documentation


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
common::

require_comments => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*


This may be used as a policy Quality Assurance measure, to remind
policy makers to properly document their promises. When true,
@code{cf-promises} will report loudly on promises that do not have
comments.

@node control agent, control server, control common, Control Promises
@section @code{agent} control promises

@*

@cartouche
@smallexample

body agent control
@{
123_456_789::

  domain => "mydomain.com";

123_456_789_111::

  auditing => "true";

any::

  fullencryption => "true";

@}

@end smallexample
@end cartouche

@*


Settings describing the details of the fixed behavioural promises made by
@code{cf-agent}. For example:



@menu
* abortclasses in agent::       
* abortbundleclasses in agent::  
* addclasses in agent::         
* agentaccess in agent::        
* agentfacility in agent::      
* auditing in agent::           
* binarypaddingchar in agent::  
* bindtointerface in agent::    
* hashupdates in agent::        
* childlibpath in agent::       
* defaultcopytype in agent::    
* dryrun in agent::             
* editbinaryfilesize in agent::  
* editfilesize in agent::       
* environment in agent::        
* exclamation in agent::        
* expireafter in agent::        
* files_single_copy in agent::  
* files_auto_define in agent::  
* fullencryption in agent::     
* hostnamekeys in agent::       
* ifelapsed in agent::          
* inform in agent::             
* lastseen in agent::           
* intermittency in agent::      
* max_children in agent::       
* maxconnections in agent::     
* mountfilesystems in agent::   
* nonalphanumfiles in agent::   
* repchar in agent::            
* default_repository in agent::  
* secureinput in agent::        
* sensiblecount in agent::      
* sensiblesize in agent::       
* skipidentify in agent::       
* suspiciousnames in agent::    
* syslog in agent::             
* timezone in agent::           
* default_timeout in agent::    
* verbose in agent::            
@end menu

@node abortclasses in agent, abortbundleclasses in agent, control agent, control agent
@subsection @code{abortclasses}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: A list of classes which if defined lead to termination of cf-agent


@noindent @b{Example}:@*
@*

@verbatim

 body agent control

  {
  abortclasses => { "danger", "should_not_continue" };
  }

@end verbatim


@noindent @b{Notes}:@*
@*


A list of classes that @code{cf-agent} will watch out for. If any of
these classes becomes defined, it will cause the current execution of
@code{cf-agent} to be aborted. This may be used for validation, for
example.



@node abortbundleclasses in agent, addclasses in agent, abortclasses in agent, control agent
@subsection @code{abortbundleclasses}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: A list of classes which if defined lead to termination of current bundle


@noindent @b{Example}:@*
@*

This example shows how to use the feature to validate input to a method bundle.

@verbatim

body common control

{
bundlesequence  => { "testbundle"  };
version => "1.2.3";
}

###########################################

body agent control

{
abortbundleclasses => { "invalid" };
}

###########################################

bundle agent testbundle
{
vars:

 "userlist" slist => { "xyz", "mark", "jeang", "jonhenrik", "thomas", "eben" };

methods:

 "any" usebundle => subtest("$(userlist)");

}

###########################################

bundle agent subtest(user)

{
classes:

  "invalid" not => regcmp("[a-z][a-z][a-z][a-z]","$(user)");

reports:

 !invalid::

  "User name $(user) is valid at 4 letters";
}

@end verbatim


@noindent @b{Notes}:@*
@*

A list of classes that @code{cf-agent} will watch out for. If any of
these classes becomes defined, it will cause the current bundle to be
aborted. This may be used for validation, for example.



@node addclasses in agent, agentaccess in agent, abortbundleclasses in agent, control agent
@subsection @code{addclasses}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: A list of classes to be defined always in the current context


@noindent @b{Example}:@*
@*

Add classes adds global, literal classes. The only predicates available during the control
section are hard-classes.

@verbatim

any::

  addclasses => { "My_Organization" }

solaris::

  addclasses => { "some_solaris_alive", "running_on_sunshine" };


@end verbatim


@noindent @b{Notes}:@*
@*

Another place to make global aliases for system hardclasses. Classes
here are added unqeuivocally to the system. If classes are used to
predicate definition, then they must be defined in terms of global
hard classes.




@node agentaccess in agent, agentfacility in agent, addclasses in agent, control agent
@subsection @code{agentaccess}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: A list of user names allowed to execute cf-agent


@noindent @b{Example}:@*
@*

@verbatim

 agentaccess => { "mark", "root", "sudo" };

@end verbatim


@noindent @b{Notes}:@*
@*

A list of user names that will be allowed to attempt execution of the
current configuration. This is mainly a sanity check rather than a
security measure. 




@node agentfacility in agent, auditing in agent, agentaccess in agent, control agent
@subsection @code{agentfacility}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{LOG_USER}
          @code{LOG_DAEMON}
          @code{LOG_LOCAL0}
          @code{LOG_LOCAL1}
          @code{LOG_LOCAL2}
          @code{LOG_LOCAL3}
          @code{LOG_LOCAL4}
          @code{LOG_LOCAL5}
          @code{LOG_LOCAL6}
          @code{LOG_LOCAL7}
@end example

@noindent @b{Synopsis}: The syslog facility for cf-agent


@noindent @b{Example}:@*
@*

@verbatim

agentfacility => "LOG_USER";

@end verbatim


@noindent @b{Notes}:@*
@*

Sets the agent's syslog facility level. See the manual pages for syslog.




@node auditing in agent, binarypaddingchar in agent, agentfacility in agent, control agent
@subsection @code{auditing}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false flag to activate the cf-agent audit log


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
auditing  => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*


If this is set, cfengine will perform auditing on promises in the
current configuration. This means that all details surrounding the
verification of the current promise will be recorded in the audit
database. The database may be inspected with @code{cf-report}, or
@code{cfshow} in cfengine 2.



@node binarypaddingchar in agent, bindtointerface in agent, auditing in agent, control agent
@subsection @code{binarypaddingchar}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Character used to pad unequal replacements in binary editing


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
binarypaddingchar => "$(const.0)";
}

@end verbatim


@noindent @b{Notes}:@*
@*

When editing binary files, it can be dangerous to replace a text
string with one that is longer or shorter as byte references and jumps
would be destroyed. Cfengine will therefore not allow replacements that
are larger in size than the original, but shorter strings can be padded
out to the same length.




@node bindtointerface in agent, hashupdates in agent, binarypaddingchar in agent, control agent
@subsection @code{bindtointerface}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Use this interface for outgoing connections


@noindent @b{Example}:@*
@*


@verbatim

bindtointerface => "192.168.1.1";

@end verbatim


@noindent @b{Notes}:@*
@*

On multi-homed hosts, the server and client can bind
to a specific interface for server traffic. The IP address
of the interface must be given as the argument, not the device name.



@node hashupdates in agent, childlibpath in agent, bindtointerface in agent, control agent
@subsection @code{hashupdates}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether stored hashes are updated when change is detected in source


@noindent @b{Example}:@*
@*


@verbatim
body agent control
{
hashupdates => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If @samp{true} the stored reference value is updated as soon as a warning
message has been given. As most changes are benign (package updates etc)
this is a common setting.



@node childlibpath in agent, defaultcopytype in agent, hashupdates in agent, control agent
@subsection @code{childlibpath}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: LD_LIBRARY_PATH for child processes


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
childlibpath => "/usr/lcoal/lib:/usr/local/gnu/lib";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This string may be used to set the internal @code{LD_LIBRARY_PATH}
environment of the agent.



@node defaultcopytype in agent, dryrun in agent, childlibpath in agent, control agent
@subsection @code{defaultcopytype}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{mtime}
          @code{atime}
          @code{ctime}
          @code{digest}
          @code{hash}
          @code{binary}
@end example

@noindent @b{Synopsis}: (null)


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
#...
defaultcopytype => "digest";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Sets the global default policy for comparing source and image in copy transactions.




@node dryrun in agent, editbinaryfilesize in agent, defaultcopytype in agent, control agent
@subsection @code{dryrun}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: All talk and no action mode


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
dryrun => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If set in the configuration, cfengine makes no changes to a
system, only reports what it needs to do.



@node editbinaryfilesize in agent, editfilesize in agent, dryrun in agent, control agent
@subsection @code{editbinaryfilesize}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer limit on maximum binary file size to be edited


@noindent @b{Example}:@*
@*


@verbatim

body agent control
{
edibinaryfilesize => "10M";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The limit on editing binary files should generally be higher than for text files.
Note the use of units allowed in the integer type.



@node editfilesize in agent, environment in agent, editbinaryfilesize in agent, control agent
@subsection @code{editfilesize}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer limit on maximum text file size to be edited


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
editfilesize => "120k";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The global setting for the file-editing safety-net. Note the use of special units is allowed.



@node environment in agent, exclamation in agent, editfilesize in agent, control agent
@subsection @code{environment}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{[A-Za-z_]+=.*}


@noindent @b{Synopsis}: List of environment variables to be inherited by children


@noindent @b{Example}:@*
@*

@verbatim

body common control
{
bundlesequence => { "one" };
}

body agent control
{
environment => { "A=123", "B=456", "PGK_PATH=/tmp"};
}

bundle agent one
{
commands:

  "/usr/bin/env";
}
@end verbatim


@noindent @b{Notes}:@*
@*

This may be used to set the runtime environment of the agent process. The values of environment variables
are inherited by child commands. Some interactive programs insist on values being set, e.g.

@verbatim

# Required by apt-cache, debian

environment => { "LANG=C"};

@end verbatim



@node exclamation in agent, expireafter in agent, environment in agent, control agent
@subsection @code{exclamation}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false print exclamation marks during security warnings


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
exclamation => "false";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This affects only the output format of warnings.




@node expireafter in agent, files_single_copy in agent, exclamation in agent, control agent
@subsection @code{expireafter}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Global default for time before on-going promise repairs are interrupted


@noindent @b{Example}:@*
@*

@verbatim
body action example
{
ifelapsed   => "120";
expireafter => "240";
}
@end verbatim


@noindent @b{Notes}:@*
@*

The locking time after which cfengine will attempt to kill and restart 
its attempt to keep a promise.



@node files_single_copy in agent, files_auto_define in agent, expireafter in agent, control agent
@subsection @code{files_single_copy}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of filenames to be watched for multiple-source conflicts


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
single_copy => { "/etc/.*", "/special/file" };
}

@end verbatim



@noindent @b{Notes}:@*
@*

This list of regular expressions will ensure that files matching the
patterns of the list are never copied from more than one source during
a single run of @code{cf-agent}. This may be considered a protection
against accidential overlap of copies from diverse remote sources, or
as a first-come-first-served disambiguation tool for lazy-evaluation
of overlapping file-copy promises.



@node files_auto_define in agent, fullencryption in agent, files_single_copy in agent, control agent
@subsection @code{files_auto_define}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of filenames to define classes if copied


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
files_auto_define => { "/etc/syslog\.c.*", "/etc/passwd" };
}

@end verbatim


@noindent @b{Notes}:@*
@*


Classes are automatically defined by the files that are copied.  The
file is named according to the prefixed `canonization' of the file
name.  Canonization means that non-identifier characters are converted
into underscores. Thus @file{/etc/passwd} would canonize to
@samp{_etc_passwd}. The prefix @samp{auto_} is added to clarify the
origin of the class. Thus in the example the copying of
@file{/etc/passwd} would lead to the class @samp{auto__etc_passwd}
being defined automatically.




@node fullencryption in agent, hostnamekeys in agent, files_auto_define in agent, control agent
@subsection @code{fullencryption}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Full encryption mode in server connections, includes directory listings


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
fullencryption => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If true this encrypts all levels of the queries to the server during
file transfers. The default is to not encrypt all aspects, since this
can slow down transfer and basically only contributes to global
warming for most users.



@node hostnamekeys in agent, ifelapsed in agent, fullencryption in agent, control agent
@subsection @code{hostnamekeys}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false label ppkeys by hostname not IP address


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
hostnamekeys => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Client side choice to base key associations on host names rather than IP address.
This is useful for hosts with dynamic addresses.



@node ifelapsed in agent, inform in agent, hostnamekeys in agent, control agent
@subsection @code{ifelapsed}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Global default for time that must elapse before promise will be rechecked


@noindent @b{Example}:@*
@*


@verbatim

#local

body action example
{
ifelapsed   => "120";
expireafter => "240";
}

# global

body agent control
{
ifelapsed   => "120";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This overrides the global settings. Promises which take a long time to
verify should usually be protected with a long value for this
parameter.  This serves as a resource `spam' protection. A cfengine
check could easily run every 5 minutes provided resource intensive
operations are not performed on every run. Using time classes like
@code{Hr12} etc., is one part of this strategy; using @code{ifelapsed}
is another which is not tied to a specific time.



@node inform in agent, lastseen in agent, ifelapsed in agent, control agent
@subsection @code{inform}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false set inform level default


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
inform => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Equivalent to or overrides the command line option @samp{-I}. Sets the
default output level `permanently' within the class context indicated.



@node lastseen in agent, intermittency in agent, inform in agent, control agent
@subsection @code{lastseen}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false record last observed time for all client-server connections (true)


@noindent @b{Example}:@*
@*

In control:
@verbatim

body agent control
{
lastseen => "false";
}

@end verbatim

See also in reports:
@verbatim

reports:

  "Comment"

    lastseen => "10";

@end verbatim


@noindent @b{Notes}:@*
@*

In reports: after this time (hours) has passed, references to the external peer
will be purged from this host's database.

In control: determines whether cfengine will records last seen
intermittency profiles (reliability diagnostics) in
@file{WORKDIR/lastseen}. This generates a separate file for each each
host that connects to the current host.  For central hubs this can
result is a huge number of files.



@node intermittency in agent, max_children in agent, lastseen in agent, control agent
@subsection @code{intermittency}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false store detailed recordings of last observed time for all client-server connections for reliability assessment (false)


@noindent @b{Example}:@*
@*

@verbatim

reports:

  "Comment"

    intermittency => "0.5";

@end verbatim


@noindent @b{Notes}:@*
@*

Report on cfengine peers in the neighbourhood watch whose observed
irregularity of connection exceeds 0.5 scaled entropy units, meaning
that they show an erratic pattern of connection.



@node max_children in agent, maxconnections in agent, intermittency in agent, control agent
@subsection @code{max_children}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum number of background tasks that should be allowed concurrently


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
max_children => "10";
}

# or

body agent control
{
max_children => "10";
}

@end verbatim



@noindent @b{Notes}:@*
@*

For the run-agent this represents the maximum number of forked
background processes allowed when parallelizing connections to
servers. For the agent it represents the number of background jobs
allowed concurrently. Background jobs often lead to contention of
the disk resources slowing down tasks considerably; there is thus a law
of diminishing returns.



@node maxconnections in agent, mountfilesystems in agent, max_children in agent, control agent
@subsection @code{maxconnections}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum number of outgoing connections to cf-serverd


@noindent @b{Example}:@*
@*

@verbatim

# client side 

body agent control
{
maxconnections => "1000";
}

# server side

body server control
{
maxconnections => "1000";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Watch out for kernel limitations for maximum numbers of open file descriptors
which can limit this.



@node mountfilesystems in agent, nonalphanumfiles in agent, maxconnections in agent, control agent
@subsection @code{mountfilesystems}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false mount any filesystems promised


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
mountfilesystems => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Issues the generic command to mount file systems defined in the file system table.




@node nonalphanumfiles in agent, repchar in agent, mountfilesystems in agent, control agent
@subsection @code{nonalphanumfiles}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false warn about filenames with no alphanumeric content


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
nonalphanumericfiles => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This test is applied in all recursive/depth searches.




@node repchar in agent, default_repository in agent, nonalphanumfiles in agent, control agent
@subsection @code{repchar}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.}


@noindent @b{Synopsis}: The character used to canonize pathnames in the file repository


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
repchar => "_";
}

@end verbatim


@noindent @b{Notes}:@*
@*




@node default_repository in agent, secureinput in agent, repchar in agent, control agent
@subsection @code{default_repository}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path to the default file repository


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
default_respository => "/var/cfengine/repository";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If defined the default repository is the location where versions of
files altered by cfengine are stored. This should be understood in
relation to the policy for @samp{backup} in copying, editing etc.  If
the backups are time-stamped, this becomes effective a version control
repository.





@node secureinput in agent, sensiblecount in agent, default_repository in agent, control agent
@subsection @code{secureinput}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false check whether input files are writable by unauthorized users


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
secureinput => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If this is set, the agent will not accept an input file that is not owned
by a privileged user.



@node sensiblecount in agent, sensiblesize in agent, secureinput in agent, control agent
@subsection @code{sensiblecount}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Minimum number of files a mounted filesystem is expected to have


@noindent @b{Example}:@*
@*

@verbatim

body agent control 
{
sensiblecount => "20";
}

@end verbatim



@noindent @b{Notes}:@*
@*



@node sensiblesize in agent, skipidentify in agent, sensiblecount in agent, control agent
@subsection @code{sensiblesize}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Minimum number of bytes a mounted filesystem is expected to have


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
sensiblesize => "20K";
}

@end verbatim




@noindent @b{Notes}:@*
@*




@node skipidentify in agent, suspiciousnames in agent, sensiblesize in agent, control agent
@subsection @code{skipidentify}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Do not send IP/name during server connection because address resolution is broken


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
skipidentify => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Hosts that are not registered in DNS cannot supply reasonable credentials
for a secondary confirmation of their identity to a cfengine server. This
causes the agent to ignore its missing DNS credentials.



@node suspiciousnames in agent, syslog in agent, skipidentify in agent, control agent
@subsection @code{suspiciousnames}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{List of names to warn about if found during any file search}


@noindent @b{Synopsis}: (null)


@noindent @b{Example}:@*
@*


@verbatim

body agent control
{
suspiciousnames => { ".mo", "lrk3", "rootkit" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

If cfengine sees these names during recursive (depth) file searches it will
warn about them.



@node syslog in agent, timezone in agent, suspiciousnames in agent, control agent
@subsection @code{syslog}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false switches on output to syslog at the inform level


@noindent @b{Example}:@*
@*

@verbatim

body agent example
{
syslog => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*





@node timezone in agent, default_timeout in agent, syslog in agent, control agent
@subsection @code{timezone}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of allowed timezones this machine must comply with


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
timezone => { "MET", "CET", "GMT+1" };
}

@end verbatim


@noindent @b{Notes}:@*
@*




@node default_timeout in agent, verbose in agent, timezone in agent, control agent
@subsection @code{default_timeout}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum time a network connection should attempt to connect


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
default_timeout => "10";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The time is in seconds. It is not a guaranteed number, since it
depends on system behaviour. under Linux, the kernel version plays a
role, since not all system calls seem to respect the signals.




@node verbose in agent,  , default_timeout in agent, control agent
@subsection @code{verbose}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false switches on verbose standard output


@noindent @b{Example}:@*
@*


@verbatim

body agent control
{
verbose => "true";
}

@end verbatim



@noindent @b{Notes}:@*
@*


@node control server, control monitor, control agent, Control Promises
@section @code{server} control promises

@*

@cartouche
@smallexample

body server control

@{
allowconnects         => @{ "127.0.0.1" , "::1" ,  ".*.example.org" @};
allowallconnects      => @{ "127.0.0.1" , "::1" ,  ".*.example.org" @};

# Uncomment me under controlled circumstances
#trustkeysfrom         => @{ "127.0.0.1" , "::1" ,  ".*.example.org" @};
@}

@end smallexample
@end cartouche

@*

Server controls are mainly about determining access policy for the
connection protocol: i.e. access to the server itself. Access to 
specific files must be granted in addition.



@menu
* cfruncommand in server::      
* maxconnections in server::    
* denybadclocks in server::     
* allowconnects in server::     
* denyconnects in server::      
* allowallconnects in server::  
* trustkeysfrom in server::     
* allowusers in server::        
* dynamicaddresses in server::  
* skipverify in server::        
* logallconnections in server::  
* logencryptedtransfers in server::  
* hostnamekeys in server::      
* auditing in server::          
* bindtointerface in server::   
* serverfacility in server::    
* port in server::              
@end menu

@node cfruncommand in server, maxconnections in server, control server, control server
@subsection @code{cfruncommand}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path to the cf-agent command or cf-execd wrapper for remote execution


@noindent @b{Example}:@*
@*

@verbatim

body server control

{
#..
cfruncommand => "/var/cfengine/bin/cf-agent";
}


@end verbatim


@noindent @b{Notes}:@*
@*

It is normal for this to point to the location of @code{cf-agent} but
it could also point to the @code{cf-execd}, or even another program at
your own risk.



@node maxconnections in server, denybadclocks in server, cfruncommand in server, control server
@subsection @code{maxconnections}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum number of connections that will be accepted by cf-serverd


@noindent @b{Example}:@*
@*

@verbatim

# client side 

body agent control
{
maxconnections => "1000";
}

# server side

body server control
{
maxconnections => "1000";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Watch out for kernel limitations for maximum numbers of open file descriptors
which can limit this.



@node denybadclocks in server, allowconnects in server, maxconnections in server, control server
@subsection @code{denybadclocks}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false accept connections from hosts with clocks that are out of sync


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
#..
denybadclocks => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

A possible form of attack on the fileserver is to request files based
on time by setting the clocks incorrectly. This option prevents
connections from clients whose clocks are drifting too far from the
server clock. This serves as a warning about clock asynchronization
and also a protection against Denial of Service attempts based on
clock corruption.



@node allowconnects in server, denyconnects in server, denybadclocks in server, control server
@subsection @code{allowconnects}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames that may connect to the server port


@noindent @b{Example}:@*
@*

@verbatim

allowconnects         => { 
                         "127.0.0.1" , 
                         "::1", 
                         "2001.10.*" , 
                         "host.domain.tld", 
                         "host[0-9]+\.domain.com" 
                         };

@end verbatim



@noindent @b{Notes}:@*
@*

If a client's identity matches an entry in this list it is granted to
permission to send data to the server port. Clients who are not in this
list may not connect or send data to the server.




@node denyconnects in server, allowallconnects in server, allowconnects in server, control server
@subsection @code{denyconnects}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames that may NOT connect to the server port


@noindent @b{Example}:@*
@*


@verbatim
body server control
{
denyconnects => { "badhost.domain.evil" };
}
@end verbatim


@noindent @b{Notes}:@*
@*

Hosts or IP addresses that are explicitly denied access. This should
only be used in special circumstances.  One should never grant generic
access to everything and then deny special cases. Since the default
server behaviour is to grant no access to anything, this list is
unnecessary unless you have already granted access to some set of
hosts using a generic pattern, to which you intend to make an exception.



@node allowallconnects in server, trustkeysfrom in server, denyconnects in server, control server
@subsection @code{allowallconnects}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames that may have more than one connection to the server port


@noindent @b{Example}:@*
@*

@verbatim

allowallconnects      => { 
                         "127.0.0.1" , 
                         "::1", 
                         "2001.10.*" , 
                         "host.domain.tld", 
                         "host[0-9]+\.domain.com" 
                         };

@end verbatim


@noindent @b{Notes}:@*
@*

This list of regular expressions matches hosts that are allowed to
connect an umlimited number of times up to the maximum connection
limit. Without this, a host may only connect once (which is a very
strong constraint, as the host must wait for the TCP FIN_WAIT to
expire before reconnction can be attempted).

In cfengine 2 this corresponds to @code{AllowMultipleConnectionsFrom}.




@node trustkeysfrom in server, allowusers in server, allowallconnects in server, control server
@subsection @code{trustkeysfrom}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames from whom we accept public keys on trust


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
trustkeysfrom => {"hosts.*", "192.168.*"};
}

@end verbatim


@noindent @b{Notes}:@*
@*

If connecting clients' public keys have not already been trusted, this
allows us to say `yes' to accepting the keys on trust. Normally this
should be an empty list except in controlled circumstances.



@node allowusers in server, dynamicaddresses in server, trustkeysfrom in server, control server
@subsection @code{allowusers}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of usernames who may execute requests from this server


@noindent @b{Example}:@*
@*


@verbatim

allowusers => { "cfengine", "root" };

@end verbatim


@noindent @b{Notes}:@*
@*

The usernames listed in this list are those asserted as public key
identities during client-server connections. These may or may not
correspond to system identities on the server-side system.




@node dynamicaddresses in server, skipverify in server, allowusers in server, control server
@subsection @code{dynamicaddresses}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames for which the IP/name binding is expected to change


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
dynamicaddresses => { "dhcp_.*" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

The addresses or hostnames here are expected to have non-permanent
address-name bindings, we must therefor work harder to determine
whether hosts credentials are trusted by looking for existing public
keys in files that do not match the current hostname or IP.




@node skipverify in server, logallconnections in server, dynamicaddresses in server, control server
@subsection @code{skipverify}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of IPs or hostnames for which we expect no DNS binding and cannot verify


@noindent @b{Example}:@*
@*


@verbatim

body server control
{
skipverify => { "special_host.*", "192.168.*" };
}
@end verbatim


@noindent @b{Notes}:@*
@*

Server side decision to ignore requirements of DNS identity confirmation.



@node logallconnections in server, logencryptedtransfers in server, skipverify in server, control server
@subsection @code{logallconnections}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false causes the server to log all new connections to syslog


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
logallconnections => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If set, the server will record connection attempts in syslog.




@node logencryptedtransfers in server, hostnamekeys in server, logallconnections in server, control server
@subsection @code{logencryptedtransfers}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false log all successful transfers required to be encrypted


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
logencryptedtransfers => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If true the server will log all transfers of files which the server
requires to encrypted in order to grant access (see
@code{ifencrypted}) to syslog. These files are deemed to be
particularly sensitive.



@node hostnamekeys in server, auditing in server, logencryptedtransfers in server, control server
@subsection @code{hostnamekeys}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false store keys using hostname lookup instead of IP addresses


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
hostnamekeys => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Client side choice to base key associations on host names rather than IP address.
This is useful for hosts with dynamic addresses.



@node auditing in server, bindtointerface in server, hostnamekeys in server, control server
@subsection @code{auditing}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false activate auditing of server connections


@noindent @b{Example}:@*
@*

@verbatim

body agent control
{
auditing  => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*


If this is set, cfengine will perform auditing on promises in the
current configuration. This means that all details surrounding the
verification of the current promise will be recorded in the audit
database. The database may be inspected with @code{cf-report}, or
@code{cfshow} in cfengine 2.



@node bindtointerface in server, serverfacility in server, auditing in server, control server
@subsection @code{bindtointerface}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: IP of the interface to which the server should bind on multi-homed hosts


@noindent @b{Example}:@*
@*


@verbatim

bindtointerface => "192.168.1.1";

@end verbatim


@noindent @b{Notes}:@*
@*

On multi-homed hosts, the server and client can bind
to a specific interface for server traffic. The IP address
of the interface must be given as the argument, not the device name.



@node serverfacility in server, port in server, bindtointerface in server, control server
@subsection @code{serverfacility}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{LOG_USER}
          @code{LOG_DAEMON}
          @code{LOG_LOCAL0}
          @code{LOG_LOCAL1}
          @code{LOG_LOCAL2}
          @code{LOG_LOCAL3}
          @code{LOG_LOCAL4}
          @code{LOG_LOCAL5}
          @code{LOG_LOCAL6}
          @code{LOG_LOCAL7}
@end example

@noindent @b{Synopsis}: Menu option for syslog facility level


@noindent @b{Example}:@*
@*

@verbatim

body server control
{
serverfacility => "LOG_USER";
}
@end verbatim



@noindent @b{Notes}:@*
@*

See syslog notes.



@node port in server,  , serverfacility in server, control server
@subsection @code{port}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{1024,99999}


@noindent @b{Synopsis}: Default port for cfengine server


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
port => "5308";
}

body server control
{
specialhost::
 port => "5308";

!specialhost::
 port => "5308";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The standard or registered port number is tcp/5308. Cfengine does not
presently use its registered udp port with the same number, but this
could change in the future.

Changing the standard port number is not recommended practice. You should
not do it without a good reason.

@node control monitor, control runagent, control server, Control Promises
@section @code{monitor} control promises

@*

@cartouche
@smallexample

body monitor control()
   @{
   #version => "1.2.3.4";

   threshold => "0.3";
   forgetrate => "0.7";
   histograms => "true";
   tcpdump => "false";
   tcpdumpcommand => "/usr/sbin/tcpdump -i eth1 -n -t -v";

   @}

@end smallexample
@end cartouche

@*

The system defaults will be sufficient for most users. This
configurability potential will be a key to developing the
integrated monitoring capabilities of cfengine however.



@menu
* forgetrate in monitor::       
* monitorfacility in monitor::  
* histograms in monitor::       
* tcpdump in monitor::          
* tcpdumpcommand in monitor::   
@end menu

@node forgetrate in monitor, monitorfacility in monitor, control monitor, control monitor
@subsection @code{forgetrate}
@noindent @b{Type}: real

@noindent @b{Allowed input range}: @code{0,1}


@noindent @b{Synopsis}: Decimal fraction [0,1] weighting of new values over old in 2d-average computation


@noindent @b{Example}:@*
@*

@verbatim

body monitor control
{
threshold => "0.3";
forgetrate => "0.7";
histograms => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Configurable settings for the machine-learning algorithm that
tracks system behaviour. This is only for expert users. This parameter
effectively determines (together with the monitoring rate) how
quickly cfengine forgets its previous history.



@node monitorfacility in monitor, histograms in monitor, forgetrate in monitor, control monitor
@subsection @code{monitorfacility}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{LOG_USER}
          @code{LOG_DAEMON}
          @code{LOG_LOCAL0}
          @code{LOG_LOCAL1}
          @code{LOG_LOCAL2}
          @code{LOG_LOCAL3}
          @code{LOG_LOCAL4}
          @code{LOG_LOCAL5}
          @code{LOG_LOCAL6}
          @code{LOG_LOCAL7}
@end example

@noindent @b{Synopsis}: Menu option for syslog facility


@noindent @b{Example}:@*
@*

@verbatim

body monitor control
{
monitorfacility => "LOG_USER";
}

@end verbatim


@noindent @b{Notes}:@*
@*

See notes for syslog.



@node histograms in monitor, tcpdump in monitor, monitorfacility in monitor, control monitor
@subsection @code{histograms}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false store signal histogram data


@noindent @b{Example}:@*
@*

@verbatim

body monitor control
{
histograms => "true";
}

@end verbatim



@noindent @b{Notes}:@*
@*

This is like the @samp{-H} option to @code{cfenvd} in cfengine 2.  It
causes cfengine to learn the conformally transformed distributions of
fluctuations about the mean.



@node tcpdump in monitor, tcpdumpcommand in monitor, histograms in monitor, control monitor
@subsection @code{tcpdump}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false use tcpdump if found


@noindent @b{Example}:@*
@*


@verbatim

body monitor control
{
tcpdump => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Interface with TCP stream if possible.



@node tcpdumpcommand in monitor,  , tcpdump in monitor, control monitor
@subsection @code{tcpdumpcommand}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path to the tcpdump command on this system


@noindent @b{Example}:@*
@*

@verbatim

body monitor control
{
tcpdumpcommand => "/usr/sbin/tcpdump -i eth1";
}

@end verbatim


@noindent @b{Notes}:@*
@*

If this is defined, the monitor will try to interface with the TCP stream and
monitor generic package categories for anomalies.

@node control runagent, control executor, control monitor, Control Promises
@section @code{runagent} control promises

@*

@cartouche
@smallexample

body runagent control
@{
# default port is 5308

hosts => @{ "127.0.0.1:5308", "eternity.iu.hio.no:80", "slogans.iu.hio.no" @};

#output_to_file => "true";
@}

@end smallexample
@end cartouche

@*

The most important parameter here is the list of hosts that the agent
will poll for connections. This is easily read in from a file list,
however when doing so always have a stable input source that does not
depend on the network (including a database or directory service) in
any way: introducing such dependencies makes configuration brittle.



@menu
* hosts in runagent::           
* port in runagent::            
* force_ipv4 in runagent::      
* trustkey in runagent::        
* encrypt in runagent::         
* background_children in runagent::  
* max_children in runagent::    
* output_to_file in runagent::  
@end menu

@node hosts in runagent, port in runagent, control runagent, control runagent
@subsection @code{hosts}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of host or IP addresses to attempt connection with


@noindent @b{Example}:@*
@*


@verbatim

body runagent control
{
network1::
  hosts => { "host1.example.org", "host2", "host3" };

network2::
  hosts => { "host1.example.com", "host2", "host3" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

The complete list of contactable hosts. The values may be either
numerical IP addresses or DNS names, optionally suffixed by a @samp{:}
and a port number. If no port number is given, the default cfengine
port 5308 is assumed.



@node port in runagent, force_ipv4 in runagent, hosts in runagent, control runagent
@subsection @code{port}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{1024,99999}


@noindent @b{Synopsis}: Default port for cfengine server


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
port => "5308";
}

body server control
{
specialhost::
 port => "5308";

!specialhost::
 port => "5308";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The standard or registered port number is tcp/5308. Cfengine does not
presently use its registered udp port with the same number, but this
could change in the future.

Changing the standard port number is not recommended practice. You should
not do it without a good reason.



@node force_ipv4 in runagent, trustkey in runagent, port in runagent, control runagent
@subsection @code{force_ipv4}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false force use of ipv4 in connection


@noindent @b{Example}:@*
@*

@verbatim

body copy_from example
{
force_ipv4 => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

IPv6 should be harmless to most users unless you have a partially
or misconfigured setup.




@node trustkey in runagent, encrypt in runagent, force_ipv4 in runagent, control runagent
@subsection @code{trustkey}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false automatically accept all keys on trust from servers


@noindent @b{Example}:@*
@*

@verbatim

body copy_from example
{
trustkey => "true";
}

@end verbatim



@noindent @b{Notes}:@*
@*

If the server's public key has not already been trusted, this
allows us to accept the key in automated key-exchange.

Note that, as a simple security precaution, trustkey should normally
be set to @samp{false}, to avoid key exchange with a server one is not
one hundred percent sure about, though the risks for a client are
rather low. On the server-side however, trust is often granted to
many clients or to a whole network in which possibly unauthorized
parties might be able to obtain an IP address, thus the trust issue
is most important on the server side.

As soon as a public key has been exchanged, the trust option has no
effect. A machine that has been trusted remains trusted until
its key is manually revoked by a system administrator. Keys are
stored in @file{WORKDIR/ppkeys}.



@node encrypt in runagent, background_children in runagent, trustkey in runagent, control runagent
@subsection @code{encrypt}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false encrypt connections with servers


@noindent @b{Example}:@*
@*

@verbatim

body copy_from example
{
servers  => { "remote-host.example.org" };
encrypt => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Client connections are encrypted with using a Blowfish randomly
generated session key.  The intial connection is encrypted using the
public/private keys for the client and server hosts.



@node background_children in runagent, max_children in runagent, encrypt in runagent, control runagent
@subsection @code{background_children}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false parallelize connections to servers


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
background_children => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Causes the runagent to attempt parallelized connections to the servers.



@node max_children in runagent, output_to_file in runagent, background_children in runagent, control runagent
@subsection @code{max_children}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum number of simultaneous connections to attempt


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
max_children => "10";
}

# or

body agent control
{
max_children => "10";
}

@end verbatim



@noindent @b{Notes}:@*
@*

For the run-agent this represents the maximum number of forked
background processes allowed when parallelizing connections to
servers. For the agent it represents the number of background jobs
allowed concurrently. Background jobs often lead to contention of
the disk resources slowing down tasks considerably; there is thus a law
of diminishing returns.



@node output_to_file in runagent,  , max_children in runagent, control runagent
@subsection @code{output_to_file}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to send collected output to file(s)


@noindent @b{Example}:@*
@*

@verbatim

body runagent control
{
output_to_file => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Filenames are chosen automatically and placed in the
@file{WORKDIR/outputs/@var{hostname}_runagent.out}.

@node control executor, control knowledge, control runagent, Control Promises
@section @code{executor} control promises

@*

@cartouche
@smallexample

body executor control

@{
splaytime  => "5";
mailto     => "cfengine@@example.org";
mailfrom   => "cfengine@@$(host).example.org";
smtpserver => "localhost";
schedule   => @{ "Min00_05", "Min30_35" @}
@}

@end smallexample
@end cartouche

@*

These body settings determine the behaviour of @code{cf-execd}, including
scheduling times and output capture to @file{WORKDIR/outputs} and relay via email.
Note that the @code{splaytime} and @code{schedule} parameters
are now coded here rather than (as previously) in the agent.



@menu
* splaytime in executor::       
* mailfrom in executor::        
* mailto in executor::          
* smtpserver in executor::      
* mailmaxlines in executor::    
* schedule in executor::        
* executorfacility in executor::  
* exec_command in executor::    
@end menu

@node splaytime in executor, mailfrom in executor, control executor, control executor
@subsection @code{splaytime}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Time in minutes to splay this host based on its name hash


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
splaytime => "2";
}

@end verbatim


@noindent @b{Notes}:@*
@*

@noindent A rough rule of thumb for scaling of small updates is set the splay
time by:

splaytime = 1 + Number of clients / 50




@node mailfrom in executor, mailto in executor, splaytime in executor, control executor
@subsection @code{mailfrom}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*@.*}


@noindent @b{Synopsis}: Email-address cfengine mail appears to come from


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
mailfrom => "MrCfengine@example.org";
}

@end verbatim


@noindent @b{Notes}:@*
@*




@node mailto in executor, smtpserver in executor, mailfrom in executor, control executor
@subsection @code{mailto}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*@.*}


@noindent @b{Synopsis}: Email-address cfengine mail is sent to


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
mailto => "cfengine_alias@example.org";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The address to whom email is sent if an smtp host is configured.



@node smtpserver in executor, mailmaxlines in executor, mailto in executor, control executor
@subsection @code{smtpserver}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Name or IP of a willing smtp server for sending email


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
smtpserver => "smtp.example.org";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This should point to a standard port 25 server without encyption.
If you are running secured or encrypted email then you should
run a mail relay on localhost and point this to localhost.



@node mailmaxlines in executor, schedule in executor, smtpserver in executor, control executor
@subsection @code{mailmaxlines}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,1000}


@noindent @b{Synopsis}: Maximum number of lines of output to send by email


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
mailmaxlines => "100";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This limit prevents anomalously large outputs from clogging up a
system administrator's mailbox.  The output is truncated in the email
report, but the complete original transcript is stored in
@file{WORKDIR/outputs/*} where it can be viewed on demand.
A reference to the appropriate file is given.



@node schedule in executor, executorfacility in executor, mailmaxlines in executor, control executor
@subsection @code{schedule}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The class schedule for activating cf-execd


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
schedule => { "Min00_05", "Min05_20", "Min30_35", "Min45_50" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

The list should contain classes which are visible to the @code{cf-execd}
daemon. In principle any defined class will cause the daemon to wake up
and schedule the execution of the @code{cf-agent}.



@node executorfacility in executor, exec_command in executor, schedule in executor, control executor
@subsection @code{executorfacility}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{LOG_USER}
          @code{LOG_DAEMON}
          @code{LOG_LOCAL0}
          @code{LOG_LOCAL1}
          @code{LOG_LOCAL2}
          @code{LOG_LOCAL3}
          @code{LOG_LOCAL4}
          @code{LOG_LOCAL5}
          @code{LOG_LOCAL6}
          @code{LOG_LOCAL7}
@end example

@noindent @b{Synopsis}: Menu option for syslog facility level


@noindent @b{Example}:@*
@*

@verbatim

body executor control
{
executorfacility => "LOG_USER";
}

@end verbatim


@noindent @b{Notes}:@*
@*

See the syslog manual pages.



@node exec_command in executor,  , executorfacility in executor, control executor
@subsection @code{exec_command}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: The full path and command to the executable run by default (overriding builtin)


@noindent @b{Example}:@*
@*

@verbatim

exec_command => "$(sys.workdir)/bin/cf-agent -f failsafe.cf && $(sys.workdir)/bin/cf-agent";

@end verbatim


@noindent @b{Notes}:@*
@*

The command is run in a shell encapsulation so pipes and shell symbols
may be used if desired.  Unlike, cfengine 2, cfengine 3 does not
automatically run a separate update sequence before its normal
run. This can be handled using the approach in the example above.

@node control knowledge, control reporter, control executor, Control Promises
@section @code{knowledge} control promises

@*

@cartouche
@smallexample

body knowledge control

@{
build_directory => ".";

sql_database => "my_knowledge";
sql_owner => "db_user";
sql_passwd => ""; # No passwd
sql_type => "mysql";

query_output => "html";

style_sheet => "http://www.example.org/css/style.css";
html_banner =>
               "
               <ul>
                <li>Item 1
                <li>Item 2
               </ul>
               ";
@}

@end smallexample
@end cartouche

@*

These parameters control the way in which knowledge data are stored
and retrieved from a relational database and the output format
of the queries. 



@menu
* id_prefix in knowledge::      
* build_directory in knowledge::  
* sql_type in knowledge::       
* sql_database in knowledge::   
* sql_owner in knowledge::      
* sql_passwd in knowledge::     
* sql_server in knowledge::     
* sql_connection_db in knowledge::  
* query_output in knowledge::   
* query_engine in knowledge::   
* style_sheet in knowledge::    
* html_banner in knowledge::    
* html_footer in knowledge::    
* graph_output in knowledge::   
* graph_directory in knowledge::  
* generate_manual in knowledge::  
* manual_source_directory in knowledge::  
@end menu

@node id_prefix in knowledge, build_directory in knowledge, control knowledge, control knowledge
@subsection @code{id_prefix}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: The LTM identifier prefix used to label topic maps (used for disambiguation in merging)


@noindent @b{Example}:@*
@*
@verbatim

body knowledge control
{
id_prefix => "unique_prefix";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Use to disambiguate indentifiers for a successful merging of topic maps,
especially in Linear Topic Map (LTM) format using third party tools such
as Ontopia's Omnigator.



@node build_directory in knowledge, sql_type in knowledge, id_prefix in knowledge, control knowledge
@subsection @code{build_directory}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: The directory in which to generate output files


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control

{
#..
build_directory => "/tmp/builddir";
}

body reporter control

{
#..
build_directory => "/tmp/builddir";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The directory where all auto-generated textual output is placed by @code{cf-know}.
This includes manual generation, ontology and topic map data.



@node sql_type in knowledge, sql_database in knowledge, build_directory in knowledge, control knowledge
@subsection @code{sql_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{mysql}
          @code{postgres}
@end example

@noindent @b{Synopsis}: Menu option for supported database type


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_type => "mysql";
}

@end verbatim


@noindent @b{Notes}:@*
@*





@node sql_database in knowledge, sql_owner in knowledge, sql_type in knowledge, control knowledge
@subsection @code{sql_database}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of database used for the topic map


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_database => "cfengine_knowledge_db";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The name of an SQL database for caching knowledge.



@node sql_owner in knowledge, sql_passwd in knowledge, sql_database in knowledge, control knowledge
@subsection @code{sql_owner}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: User id of sql database user


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_owner => "db_owner";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Part of the credentials for opening the database. This depends on the type of
database.



@node sql_passwd in knowledge, sql_server in knowledge, sql_owner in knowledge, control knowledge
@subsection @code{sql_passwd}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Embedded password for accessing sql database


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_passwd => "";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Part of the credentials for connecting to the database server.
This is system dependent. If the server host is localhost a password
might not be required.



@node sql_server in knowledge, sql_connection_db in knowledge, sql_passwd in knowledge, control knowledge
@subsection @code{sql_server}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name or IP of database server (or localhost)


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_server => "localhost";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The host name of IP address of the server. The default is to look on the localhost.



@node sql_connection_db in knowledge, query_output in knowledge, sql_server in knowledge, control knowledge
@subsection @code{sql_connection_db}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The name of an existing database to connect to in order to create/manage other databases


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
sql_connection_db => "mysql";
}

@end verbatim


@noindent @b{Notes}:@*
@*

In order to create a database on a database server (all of which
practice voluntary cooperation), one has to be able to connect
to the server, however, without an existing database this is not allowed.
Thus, database servers provide a default database that can be connected
to in order to thereafter create new databases. These are called
@code{postgres} and @code{mysql} for their respective database servers.

For the knowledge agent, this setting is made in the control body,
for database verification promises, it is made in the 
@code{database_server} body.



@node query_output in knowledge, query_engine in knowledge, sql_connection_db in knowledge, control knowledge
@subsection @code{query_output}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{html}
          @code{text}
@end example

@noindent @b{Synopsis}: Menu option for generated output format


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
query_output => "html";
}

@end verbatim


@noindent @b{Notes}:@*
@*





@node query_engine in knowledge, style_sheet in knowledge, query_output in knowledge, control knowledge
@subsection @code{query_engine}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of a dynamic web-page used to accept and drive queries in a browser


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
query_engine => "http://www.example.org/script.php";
}

body reporter control
{
query_engine => "http://www.example.org/script.pl";
}

@end verbatim


@noindent @b{Notes}:@*
@*

When displaying topic maps in HTML format, @code{cf-know} will render
each topic as a link to this URL with the new topic as an argument.
Thus it is possible to make a dynamic web query by embedding cfengine
in the web page as system call and passing the argument to it.



@node style_sheet in knowledge, html_banner in knowledge, query_engine in knowledge, control knowledge
@subsection @code{style_sheet}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of a style-sheet to be used in rendering html output (added to headers)


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
style_sheet => "http://www.example.org/css/sheet.css";
}

body reporter control
{
style_sheet => "http://www.example.org/css/sheet.css";
}

@end verbatim


@noindent @b{Notes}:@*
@*

For formatting the HTML generated output of @code{cf-know}.



@node html_banner in knowledge, html_footer in knowledge, style_sheet in knowledge, control knowledge
@subsection @code{html_banner}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: HTML code for a banner to be added to rendered in html after the header


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
html_banner => "<img src=\"http://www.example.org/img/banner.png\">";
}

body reporter control
{
html_banner => "<img src=\"http://www.example.org/img/banner.png\">";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This content is cited when generating HTML output from the knowledge agent.




@node html_footer in knowledge, graph_output in knowledge, html_banner in knowledge, control knowledge
@subsection @code{html_footer}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: HTML code for a page footer to be added to rendered in html before the end body tag


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
html_footer => "
               <div id=\"footer\">Bottom of the page</div>
               ";
}

body knowledge control
{
html_footer => "
               <div id=\"footer\">Bottom of the page</div>
               ";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This allows us to cite HTML code for formatting reports generated by the reporting and knowledge
agents.



@node graph_output in knowledge, graph_directory in knowledge, html_footer in knowledge, control knowledge
@subsection @code{graph_output}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false generate png visualization of topic map if possible (requires lib)


@noindent @b{Example}:@*
@*

@verbatim
body knowledge control

{
# fix/override -g option
graph_output => "true"; 
}

@end verbatim


@noindent @b{Notes}:@*
@*

Equivalent to the use of the @samp{-g} option for @code{cf-know}.



@node graph_directory in knowledge, generate_manual in knowledge, graph_output in knowledge, control knowledge
@subsection @code{graph_directory}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path to directory where rendered .png files will be created


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
graph_directory => "/tmp/output";
}

@end verbatim


@noindent @b{Notes}:@*
@*

A separate location where the potentially large number of @file{.png}
visualizations of a knowledge representation are pre-compiled.
This feature only works if the necessary graphics libraries are
present.



@node generate_manual in knowledge, manual_source_directory in knowledge, graph_directory in knowledge, control knowledge
@subsection @code{generate_manual}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false generate texinfo manual page skeleton for this version


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
generate_manual => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*


Auto-creates a manual based on the self-documented code. As the
promise syntax is extended the manual self-heals. The resulting manual
is generated in Texinfo format, from which all other formats can be
generated.



@node manual_source_directory in knowledge,  , generate_manual in knowledge, control knowledge
@subsection @code{manual_source_directory}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path to directory where raw text about manual topics is found (defaults to build_directory)


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
manual_source => "/path/cfengine_manual_commentary";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This is used in the self-healing documentation. The directory points to
a location where the Texinfo sources for per-section commentary is maintained.

@node control reporter,  , control knowledge, Control Promises
@section @code{reporter} control promises

@*

@verbatim

body reporter control
{
reports => { "performance", "last_seen", "monitor_history" };
build_directory => "/tmp/nerves";
report_output => "html";
}

@end verbatim

@*

Determines a list of reports to write into the build directory. The
format may be in text, html or xml format. The reporter agent
@code{cf-report} replaces both @code{cfshow} and @code{cfenvgraph}. It
no longer produces output to the console.

Some reports are only available in enterprise level versions of cfengine.



@menu
* aggregation_point in reporter::  
* auto_scaling in reporter::    
* build_directory in reporter::  
* csv2xml in reporter::         
* error_bars in reporter::      
* html_banner in reporter::     
* html_embed in reporter::      
* html_footer in reporter::     
* query_engine in reporter::    
* reports in reporter::         
* report_output in reporter::   
* style_sheet in reporter::     
* time_stamps in reporter::     
@end menu

@node aggregation_point in reporter, auto_scaling in reporter, control reporter, control reporter
@subsection @code{aggregation_point}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: The root directory of the data cache for CMDB aggregation


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
aggregation_point => "/srv/www/htdocs/reports";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This feature is only used in enterprise level versions of cfengine.
It specifies the directory where reports from multiple hosts are
to be aggregated in sub-directories. This should be somewhere under
the document root of the web server for the cfengine knowledge base
in order to make the reports browsable.



@node auto_scaling in reporter, build_directory in reporter, aggregation_point in reporter, control reporter
@subsection @code{auto_scaling}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to auto-scale graph output to optimize use of space


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
auto_scaling => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Automatic scaling is the default.



@node build_directory in reporter, csv2xml in reporter, auto_scaling in reporter, control reporter
@subsection @code{build_directory}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: The directory in which to generate output files


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control

{
#..
build_directory => "/tmp/builddir";
}

body reporter control

{
#..
build_directory => "/tmp/builddir";
}

@end verbatim


@noindent @b{Notes}:@*
@*

The directory where all auto-generated textual output is placed by @code{cf-know}.
This includes manual generation, ontology and topic map data.



@node csv2xml in reporter, error_bars in reporter, build_directory in reporter, control reporter
@subsection @code{csv2xml}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A list of csv formatted files in the build directory to convert to simple xml


@noindent @b{Example}:@*
@*


@verbatim

body reporter control
{
csv2xml => { "myreport.csv", "custom_report.csv"  };
}

@end verbatim


@noindent @b{Notes}:@*
@*

CSV files are easy to generate in cfengine from individual promise logging functions.
XML is not easily generated due to its hierarchical structure. This function allows
@code{cf-report} to convert a CSV file into pidgin XML for convenience. The schema
has the general form:

@verbatim

<output>
 <line> <one>...</one> <two>...</two> ... </line>
 <line> <one>...</one> <two>...</two> ... </line>
</output>

@end verbatim



@node error_bars in reporter, html_banner in reporter, csv2xml in reporter, control reporter
@subsection @code{error_bars}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to generate error bars on graph output


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
error_bars => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*


The default is to produce error bars. Without error bars from
cfengine's machine learning data there is no way to assess
the significance of an observation about the system, i.e. whether
it is normal or anomalous.



@node html_banner in reporter, html_embed in reporter, error_bars in reporter, control reporter
@subsection @code{html_banner}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: HTML code for a banner to be added to rendered in html after the header


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
html_banner => "<img src=\"http://www.example.org/img/banner.png\">";
}

body reporter control
{
html_banner => "<img src=\"http://www.example.org/img/banner.png\">";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This content is cited when generating HTML output from the knowledge agent.




@node html_embed in reporter, html_footer in reporter, html_banner in reporter, control reporter
@subsection @code{html_embed}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: If true, no header and footer tags will be added to html output


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
html_embed => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Embedded HTML means something that could be put into a frame or table, without
html or body tags, headers footers etc.




@node html_footer in reporter, query_engine in reporter, html_embed in reporter, control reporter
@subsection @code{html_footer}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: HTML code for a page footer to be added to rendered in html before the end body tag


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
html_footer => "
               <div id=\"footer\">Bottom of the page</div>
               ";
}

body knowledge control
{
html_footer => "
               <div id=\"footer\">Bottom of the page</div>
               ";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This allows us to cite HTML code for formatting reports generated by the reporting and knowledge
agents.



@node query_engine in reporter, reports in reporter, html_footer in reporter, control reporter
@subsection @code{query_engine}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of a dynamic web-page used to accept and drive queries in a browser


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
query_engine => "http://www.example.org/script.php";
}

body reporter control
{
query_engine => "http://www.example.org/script.pl";
}

@end verbatim


@noindent @b{Notes}:@*
@*

When displaying topic maps in HTML format, @code{cf-know} will render
each topic as a link to this URL with the new topic as an argument.
Thus it is possible to make a dynamic web query by embedding cfengine
in the web page as system call and passing the argument to it.



@node reports in reporter, report_output in reporter, query_engine in reporter, control reporter
@subsection @code{reports}
@noindent @b{Type}: (option list)

@noindent @b{Allowed input range}: @*
@example
          @code{audit}
          @code{performance}
          @code{all_locks}
          @code{active_locks}
          @code{hashes}
          @code{classes}
          @code{last_seen}
          @code{monitor_now}
          @code{monitor_history}
          @code{monitor_summary}
          @code{compliance}
          @code{setuid}
          @code{file_changes}
          @code{installed_software}
          @code{software_patches}
          @code{variables}
@end example

@noindent @b{Synopsis}: A list of reports that may be generated


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
reports => { "performance", "classes"  };
}

@end verbatim


@noindent @b{Notes}:@*
@*

A list of report types that can be generated by this agent.  The
listed items from @code{compliance} onward are available only
Enterprise editions of cfengine.



@node report_output in reporter, style_sheet in reporter, reports in reporter, control reporter
@subsection @code{report_output}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{csv}
          @code{html}
          @code{text}
          @code{xml}
@end example

@noindent @b{Synopsis}: Menu option for generated output format. Applies only to text reports, graph data remain in xydy format.


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
report_output => "html";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Sets the output format of embedded database reports.




@node style_sheet in reporter, time_stamps in reporter, report_output in reporter, control reporter
@subsection @code{style_sheet}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of a style-sheet to be used in rendering html output (added to headers)


@noindent @b{Example}:@*
@*

@verbatim

body knowledge control
{
style_sheet => "http://www.example.org/css/sheet.css";
}

body reporter control
{
style_sheet => "http://www.example.org/css/sheet.css";
}

@end verbatim


@noindent @b{Notes}:@*
@*

For formatting the HTML generated output of @code{cf-know}.



@node time_stamps in reporter,  , style_sheet in reporter, control reporter
@subsection @code{time_stamps}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to generate timestamps on the output directory


@noindent @b{Example}:@*
@*

@verbatim

body reporter control
{
time_stamps => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This option is only necessary with the default build directory.  This
can be used to keep snapshots of the system but it will result in a
lot of storage be consumed. For most purposes cfengine is programmed
to forget the past at a predictable rate and there is no need to
override this. 

@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Bundles for common, Bundles for agent, Control Promises, Top
@chapter Bundles of @code{common}

@*

@cartouche
@smallexample

bundle common globals
@{
vars:

  "global_var" string => "value";

classes:

  "global_class" expression => "value";
@}

@end smallexample
@end cartouche

@*

Common bundles may only contain the promise types that are common to
all bodies.  Their main function is to define cross-component global
definitions. Common bundles are observed by every agent, whereas the
agent specific bundle types are ignored by components other than the
intended recipient.



@menu
* vars in common promises::     
* classes in common promises::  
* reports in common promises::  
* * in agent promises::         
* * in edit_line promises::     
@end menu

@node vars in common promises, classes in common promises, Bundles for common, Bundles for common
@section @code{vars} promises

@*

Whereas most promise types are specific to a particular kind of
interpretation that requires a typed interpreter (the bundle type),
a number of promises can be made in any kind of bundle since they
are of a generic input/output nature. These are listed below.



@menu
* string in vars::              
* int in vars::                 
* real in vars::                
* slist in vars::               
* ilist in vars::               
* rlist in vars::               
* policy in vars::              
@end menu

@node string in vars, int in vars, vars in common promises, vars in common promises
@subsection @code{string}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A scalar string


@noindent @b{Example}:@*
@*

@verbatim

vars:

 "xxx"    string => "Some literal string...";

 "yyy"    string => readfile( "/home/mark/tmp/testfile" , "33" );

@end verbatim


@noindent @b{Notes}:@*
@*

In cfengine previously lists were represented (as in the shell) using
separted scalars, e.g. like the PATH variable. This design feature
turned out to be an error of judgement which has resulted in much
trouble. This is no longer supported in cfengine 3. By keeping lists
an independent type many limitations have been removed.



@node int in vars, real in vars, string in vars, vars in common promises
@subsection @code{int}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{-99999999999,9999999999}


@noindent @b{Synopsis}: A scalar integer


@noindent @b{Example}:@*
@*

@verbatim
vars:

 "scalar" int    => "16k";

 "ran"    int    => randomint(4,88);

 "dim_array" int =>  readstringarray("array_name","/etc/passwd","#[^\n]*",":",10,4000);

@end verbatim


@noindent @b{Notes}:@*
@*


Integer values may use suffices @samp{k}, @samp{K}, @samp{m}, @samp{M}, etc

@table @samp

@item k
The value multipled by 1000.
@item K
The value multipled by 1024.
@item m
The value multipled by 1000 * 1000.
@item M
The value multipled by 1024 * 1024.
@item g
The value multipled by 1000 * 1000 * 1000.
@item G
The value multipled by 1024 * 1024 * 1024.
@item %
A percentage between 1 and 100 - mainly for use in a storage context.

@end table

The value @samp{inf} may also be used to represent an umlimited positive value.



@node real in vars, slist in vars, int in vars, vars in common promises
@subsection @code{real}
@noindent @b{Type}: real

@noindent @b{Allowed input range}: @code{-9.99999E100,9.99999E100}


@noindent @b{Synopsis}: A scalar real number


@noindent @b{Example}:@*
@*

@verbatim

vars:
   
 "scalar" real   => "0.5";

@end verbatim


@noindent @b{Notes}:@*
@*

Real numbers are not used in many places in cfengine, but they are
useful for representing probabilties and performance data.



@node slist in vars, ilist in vars, real in vars, vars in common promises
@subsection @code{slist}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A list of scalar strings


@noindent @b{Example}:@*
@*

@verbatim
vars:

 "xxx"    slist  => {  "literal1",  "literal2" };

 "yyy"    slist  => { 
                    readstringlist(
                                  "/home/mark/tmp/testlist",
                                  "#[a-zA-Z0-9 ]*",
                                  "[^a-zA-Z0-9]",
                                  15,
                                  4000
                                  ) 
                    };

 "zzz"    slist  => { readstringlist("/home/mark/tmp/testlist2","#[^\n]*",",",5,4000) };


@end verbatim


@noindent @b{Notes}:@*
@*




@node ilist in vars, rlist in vars, slist in vars, vars in common promises
@subsection @code{ilist}
@noindent @b{Type}: ilist

@noindent @b{Allowed input range}: @code{-99999999999,9999999999}


@noindent @b{Synopsis}: A list of integers


@noindent @b{Example}:@*
@*

@verbatim

vars:

  "variable_id"

       ilist => { "10", "11", "12" };

@end verbatim


@noindent @b{Notes}:@*
@*

Integer lists are lists of strings that are expected to be treated as integers.
The typing in cfengine is dynamic, so the variable types are interchangable.



@node rlist in vars, policy in vars, ilist in vars, vars in common promises
@subsection @code{rlist}
@noindent @b{Type}: rlist

@noindent @b{Allowed input range}: @code{-9.99999E100,9.99999E100}


@noindent @b{Synopsis}: A list of real numbers


@noindent @b{Example}:@*
@*

@verbatim

vars:

  "varid" rlist => { "0.1", "0.2", "0.3" };

@end verbatim



@noindent @b{Notes}:@*
@*




@node policy in vars,  , rlist in vars, vars in common promises
@subsection @code{policy}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{free}
          @code{overridable}
          @code{constant}
@end example

@noindent @b{Synopsis}: The policy for (dis)allowing redefinition of variables


@noindent @b{Example}:@*
@*


@verbatim

vars:

  "varid" string => "value..."
          policy => "constant";

@end verbatim


@noindent @b{Notes}:@*
@*

Variables can either be allowed to change their value dynamically (be
redefined) or they can be constant. The use of private variable spaces
in cfengine 3 makes it unlikely that variable redefinition would be
necessary in cfengine 3.



@node classes in common promises, reports in common promises, vars in common promises, Bundles for common
@section @code{classes} promises

@*

Whereas most promise types are specific to a particular kind of
interpretation that requires a typed interpreter (the bundle type),
a number of promises can be made in any kind of bundle since they
are of a generic input/output nature. These are listed below.



@menu
* or in classes::               
* and in classes::              
* xor in classes::              
* dist in classes::             
* expression in classes::       
* not in classes::              
@end menu

@node or in classes, and in classes, classes in common promises, classes in common promises
@subsection @code{or}
@noindent @b{Type}: clist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_!&@@$|.()]+}


@noindent @b{Synopsis}: Combine class sources with inclusive OR


@noindent @b{Example}:@*
@*

@verbatim

classes:

    "compound_test" 

      or => { classmatch("linux_x86_64_2_6_22.*"), "suse_10_3" };

@end verbatim


@noindent @b{Notes}:@*
@*

A useful construction for writing expressions that contain special functions.



@node and in classes, xor in classes, or in classes, classes in common promises
@subsection @code{and}
@noindent @b{Type}: clist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_!&@@$|.()]+}


@noindent @b{Synopsis}: Combine class sources with AND


@noindent @b{Example}:@*
@*

@verbatim

classes:

  "compound_class" and => { classmatch("host[0-9].*"), "Monday", "Hr02" };

@end verbatim


@noindent @b{Notes}:@*
@*

If an expression contains a mixture of different object types that
need to be ANDed together, this list form is more convenient than
providing an expression.



@node xor in classes, dist in classes, and in classes, classes in common promises
@subsection @code{xor}
@noindent @b{Type}: clist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_!&@@$|.()]+}


@noindent @b{Synopsis}: Combine class sources with XOR


@noindent @b{Example}:@*
@*


@verbatim

classes:

 "another_global" xor => { "any", "linux", "solaris"};

@end verbatim



@noindent @b{Notes}:@*
@*




@node dist in classes, expression in classes, xor in classes, classes in common promises
@subsection @code{dist}
@noindent @b{Type}: rlist

@noindent @b{Allowed input range}: @code{-9.99999E100,9.99999E100}


@noindent @b{Synopsis}: Generate a probabilistic class distribution (strategy in cfengine 2)


@noindent @b{Example}:@*
@*

@verbatim

classes:

  "my_dist"  

    dist => { "10", "20", "40", "50" };

@end verbatim


@noindent @b{Notes}:@*
@*

Assign one exclusive class randomly weighted on a probability distribution.
This will generate the following classes:

@smallexample
my_dist    (always)
my_dist_10 (10/120 of the time)
my_dist_20 (20/120 of the time)
my_dist_40 (40/120 of the time)
my_dist_50 (50/120 of the time)
@end smallexample

This was previous called a @samp{strategy} in cfengine 2. 



@node expression in classes, not in classes, dist in classes, classes in common promises
@subsection @code{expression}
@noindent @b{Type}: class

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_!&@@$|.()]+}


@noindent @b{Synopsis}: Evaluate string expression of classes in normal form


@noindent @b{Example}:@*
@*
@verbatim

classes:

  "class_name" expression => "solaris|(linux.specialclass)";

@end verbatim


@noindent @b{Notes}:@*
@*

A way of aliasing class combinations.




@node not in classes,  , expression in classes, classes in common promises
@subsection @code{not}
@noindent @b{Type}: class

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_!&@@$|.()]+}


@noindent @b{Synopsis}: Evaluate the negation of string expression in normal form


@noindent @b{Example}:@*
@*

@verbatim

classes:

   "others"  not => "linux|solaris";

@end verbatim


@noindent @b{Notes}:@*
@*

In file editing, this negates the effect of the promiser-pattern regular expression.



@node reports in common promises, * in agent promises, classes in common promises, Bundles for common
@section @code{reports} promises

@*

Whereas most promise types are specific to a particular kind of
interpretation that requires a typed interpreter (the bundle type),
a number of promises can be made in any kind of bundle since they
are of a generic input/output nature. These are listed below.



@menu
* friend_pattern in reports::   
* intermittency in reports::    
* lastseen in reports::         
* printfile in reports::        
* report_to_file in reports::   
* showstate in reports::        
@end menu

@node friend_pattern in reports, intermittency in reports, reports in common promises, reports in common promises
@subsection @code{friend_pattern}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression to keep selected hosts from the friends report list


@noindent @b{Example}:@*
@*

@verbatim

reports:

  linux::

   "Friend status report"

          lastseen => "0"
     friend_patten => "host1|host2|.*\.domain\.tld";

@end verbatim


@noindent @b{Notes}:@*
@*

This regular expression should match hosts we want to exclude from friend reports.



@node intermittency in reports, lastseen in reports, friend_pattern in reports, reports in common promises
@subsection @code{intermittency}
@noindent @b{Type}: real

@noindent @b{Allowed input range}: @code{0,1}


@noindent @b{Synopsis}: Real number threshold [0,1] of intermittency about current peers, report above


@noindent @b{Example}:@*
@*

@verbatim

reports:

  "Comment"

    intermittency => "0.5";

@end verbatim


@noindent @b{Notes}:@*
@*

Report on cfengine peers in the neighbourhood watch whose observed
irregularity of connection exceeds 0.5 scaled entropy units, meaning
that they show an erratic pattern of connection.



@node lastseen in reports, printfile in reports, intermittency in reports, reports in common promises
@subsection @code{lastseen}
@noindent @b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer time threshold in hours since current peers were last seen, report absence


@noindent @b{Example}:@*
@*

In control:
@verbatim

body agent control
{
lastseen => "false";
}

@end verbatim

See also in reports:
@verbatim

reports:

  "Comment"

    lastseen => "10";

@end verbatim


@noindent @b{Notes}:@*
@*

In reports: after this time (hours) has passed, references to the external peer
will be purged from this host's database.

In control: determines whether cfengine will records last seen
intermittency profiles (reliability diagnostics) in
@file{WORKDIR/lastseen}. This generates a separate file for each each
host that connects to the current host.  For central hubs this can
result is a huge number of files.



@node printfile in reports, report_to_file in reports, lastseen in reports, reports in common promises
@subsection @code{printfile} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{file_to_print}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path name to the file that is to be sent to standard output


@b{Example}:@*
@*

@verbatim

body printfile example
{
file_to_print   => "/etc/motd";
number_of_lines => "10";
}

@end verbatim


@b{Notes}:@*
@*

Include part of a file in a report.


@item @code{number_of_lines}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer maximum number of lines to print from selected file


@b{Example}:@*
@*

@verbatim

body printfile example
{
number_of_lines => "10";
}

@end verbatim


@b{Notes}:@*
@*


@end table


@node report_to_file in reports, showstate in reports, printfile in reports, reports in common promises
@subsection @code{report_to_file}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: The path and filename to which output should be appended


@noindent @b{Example}:@*
@*

@verbatim

bundle agent test
{
reports:

  linux::

   "$(sys.date),This is a report from $(sys.host)"

       report_to_file => "/tmp/test_log";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Append the output of the report to the named file instead of standard
output.  If the file cannot be opened for writing then the report
defaults to the standard output.



@node showstate in reports,  , report_to_file in reports, reports in common promises
@subsection @code{showstate}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of services about which status reports should be reported to standard output


@noindent @b{Example}:@*
@*

@verbatim

reports:

  "Comment"

    showstate => {"www_in", "ssh_out", "otherprocs" };

@end verbatim


@noindent @b{Notes}:@*
@*

The basic list of services is:

@table @samp
@item users
Users logged in
@item rootprocs
Privileged system processes
@item otherprocs
Non-privileged process
@item diskfree
Free disk on / partition
@item loadavg
% kernel load utilization
@item netbiosns_in
netbios name lookups (in)
@item netbiosns_out
netbios name lookups (out)
@item netbiosdgm_in
netbios name datagrams (in)
@item netbiosdgm_out
netbios name datagrams (out)
@item netbiosssn_in
netbios name sessions (in)
@item netbiosssn_out
netbios name sessions (out)
@item irc_in
IRC connections (in)
@item irc_out
IRC connections (out)
@item cfengine_in
cfengine connections (in)
@item cfengine_out
cfengine connections (out)
@item nfsd_in
nfs connections (in)
@item nfsd_out
nfs connections (out)
@item smtp_in
smtp connections (in)
@item smtp_out
smtp connections (out)
@item www_in
www connections (in)
@item www_out
www connections (out)
@item ftp_in
ftp connections (in)
@item ftp_out
ftp connections (out)
@item ssh_in
ssh connections (in)
@item ssh_out
ssh connections (out)
@item wwws_in
wwws connections (in)
@item wwws_out
wwws connections (out)
@item icmp_in
ICMP packets (in)
@item icmp_out
ICMP packets (out)
@item udp_in
UDP dgrams (in)
@item udp_out
UDP dgrams (out)
@item dns_in
DNS requests (in)
@item dns_out
DNS requests (out)
@item tcpsyn_in
TCP sessions (in)
@item tcpsyn_out
TCP sessions (out)
@item tcpack_in
TCP acks (in)
@item tcpack_out
TCP acks (out)
@item tcpfin_in
TCP finish (in)
@item tcpfin_out
TCP finish (out)
@item tcpmisc_in
TCP misc (in)
@item tcpmisc_out
TCP misc (out)
@item webaccess
Webserver hits
@item weberrors
Webserver errors
@item syslog
New log entries (Syslog)
@item messages
New log entries (messages)
@item temp0
CPU Temperature 0
@item temp1
CPU Temperature 1
@item temp2
CPU Temperature 2
@item temp3
CPU Temperature 3
@item cpu
%CPU utilization (all)
@item cpu0
%CPU utilization 0
@item cpu1
%CPU utilization 1
@item cpu2
%CPU utilization 2
@item cpu3
%CPU utilization 3
@end table



@node * in agent promises, * in edit_line promises, reports in common promises, Bundles for common
@section @code{*} promises in @samp{agent}

@*

Most promise bodies belong to one and only one type of promise.  The
generic `*' promises bodies can be added to any promise type in
@code{cf-agent}, hence the star which means `any'.


The body attributes described below can be added to any promise rule
in the agent. These promises address matters of a completely general
nature -- how cfengine behaves as it attempts to keep a promise,
comments about the promises etc.

@*

@verbatim

files:

   "/etc/passwd" -> "Security team"

      perms  => p("644"),
      action => justcheck,
      comment => "This was decided in internal procedures XYZ123";

@end verbatim

@*




@menu
* action in *::                 
* classes in *::                
* ifvarclass in *::             
* handle in *::                 
* depends_on in *::             
* comment in *::                
@end menu

@node action in *, classes in *, * in agent promises, * in agent promises
@subsection @code{action} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{action_policy}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{fix}
          @code{warn}
          @code{nop}
@end example

@noindent @b{Synopsis}: Whether to repair or report about non-kept promises


@b{Example}:@*
@*

The following example shows a simple use of transaction control,
causing the promise to be verified as a separate background process.

@verbatim

body action background

{
action_policy => "warn";
}

@end verbatim


@b{Notes}:@*
@*

The @code{action} settings allow general transaction control to be
implemented on promise verification. Action bodies place limits on how
often to verify the promise and what classes to raise in the case that
the promise can or cannot be kept.

Note that actions can be added to sub-bundles like methods and editing
bundles, and that promises within these do not inherit action settings
at higher levels. Thus, in the following example there are two levels
of action setting:

@verbatim
########################################################
#
# Warn if line matched
#
########################################################

body common control

{
bundlesequence  => { "testbundle" };
}

########################################################

bundle agent testbundle

{
files:

  "/var/cfengine/inputs/.*"

       edit_line => DeleteLinesMatching(".*cfenvd.*"),
       action => WarnOnly;
}

########################################################

bundle edit_line DeleteLinesMatching(regex)
  {
  delete_lines:

    "$(regex)" action => WarnOnly;

  }

########################################################

body action WarnOnly
{
action_policy => "warn";
}
@end verbatim

The @code{action} setting for the @code{files} promise means that file
edits will not be committed to disk, only warned about. This is a master-level
promise that overrides anything that happens during the editing. The
@code{action} setting for the edit bundle means that the internal
memory modelling of the file will only warn about changes rather than
committing them to the memory model. This makes little difference to the
end result, but it means that cfengine will report

@smallexample
Need to delete line - ... - but only a warning was promised
@end smallexample

@noindent Instead of 

@smallexample
Deleting the prpomised line ...
Need to save file - but only a warning was promised
@end smallexample

@noindent In either case, no changes will be made to the disk, but the messages
given by @code{cf-agent} will differ.


@item @code{ifelapsed}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Number of minutes before next allowed assessment of promise


@b{Example}:@*
@*


@verbatim

#local

body action example
{
ifelapsed   => "120";
expireafter => "240";
}

# global

body agent control
{
ifelapsed   => "120";
}

@end verbatim


@b{Notes}:@*
@*

This overrides the global settings. Promises which take a long time to
verify should usually be protected with a long value for this
parameter.  This serves as a resource `spam' protection. A cfengine
check could easily run every 5 minutes provided resource intensive
operations are not performed on every run. Using time classes like
@code{Hr12} etc., is one part of this strategy; using @code{ifelapsed}
is another which is not tied to a specific time.

@item @code{expireafter}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Number of minutes before a repair action is interrupted and retried


@b{Example}:@*
@*

@verbatim
body action example
{
ifelapsed   => "120";
expireafter => "240";
}
@end verbatim


@b{Notes}:@*
@*

The locking time after which cfengine will attempt to kill and restart 
its attempt to keep a promise.

@item @code{log_string}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A message to be written to the log when a promise verification leads to a repair


@b{Example}:@*
@*

@example

@var{promise-type}:

 "promiser"

   attr => "value",
   action => log_me("checked $(this.promiser)");

# ..
 
body action log_me(s)
@{
log_string => "$(s)";
@}

@end example


@b{Notes}:@*
@*

The @code{log_string} works together with @code{log_repair},
@code{log_kept} etc, to define a string for logging to one of the named
files depending on promise outcome, or to standard output of the log file
is stipulared as @samp{stdout}. Log strings on standard output are denoted
by an @samp{L:} prefix.

Note that @code{log_string} does not interact with @code{log_level},
which is about regular system output messages.

@item @code{log_level}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{inform}
          @code{verbose}
          @code{error}
          @code{log}
@end example

@noindent @b{Synopsis}: The reporting level sent to syslog


@b{Example}:@*
@*

@verbatim

body action example
{
log_level => "inform";
}

@end verbatim


@b{Notes}:@*
@*

Use this as an alternative to auditing to use the syslog mechanism to centralize
or manage messaging from cfengine. A backup of these messages will still be
kept in @file{WORKDIR/outputs} if you are using @code{cf-execd}.

@item @code{log_kept}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: This should be filename of a file to which log_string will be saved, if undefined it goes to syslog


@b{Example}:@*
@*

@verbatim

body action logme(x)
{
log_kept => "/tmp/private_keptlog.log";
log_failed => "/tmp/private_faillog.log";
log_repaired => "/tmp/private_replog.log";
log_string => "$(sys.date) $(x) promise status";
}

@end verbatim


@b{Notes}:@*
@*

If this option is specified together with @code{log_string}, the
current promise will log promise-kept status using the log string to
this named file. If these log names are absent, the default logging
destination for the log string is syslog, but only for non-kept
promises. Only the @code{log_string} is affected by this setting. Other messages
destined for logging are sent to syslog.

It is intended that named file logs should be different for the three
cases: promise kept, promise not kept and promise repaired.

@item @code{log_repaired}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: This should be filename of a file to which log_string will be saved, if undefined it goes to syslog


@b{Example}:@*
@*

@verbatim

bundle agent test
{
vars:

  "software" slist => { "/root/xyz", "/tmp/xyz" };

files:

  "$(software)"

    create => "true",
     action => logme("$(software)");

}


body action logme(x)
{
log_kept => "/tmp/private_keptlog.log";
log_failed => "/tmp/private_faillog.log";
log_repaired => "/tmp/private_replog.log";
log_string => "$(sys.date) $(x) promise status";
}

@end verbatim


@b{Notes}:@*
@*

This may be the name of a log to which the @code{log_string} is written if a promise is repaired.

@item @code{log_failed}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: This should be filename of a file to which log_string will be saved, if undefined it goes to syslog


@b{Example}:@*
@*

@verbatim

bundle agent test
{
vars:

  "software" slist => { "/root/xyz", "/tmp/xyz" };

files:

  "$(software)"

    create => "true",
     action => logme("$(software)");

}


body action logme(x)
{
log_kept => "/tmp/private_keptlog.log";
log_failed => "/tmp/private_faillog.log";
log_repaired => "/tmp/private_replog.log";
log_string => "$(sys.date) $(x) promise status";
}

@end verbatim


@b{Notes}:@*
@*

If this option is specified together with @code{log_string}, the
current promise will log promise-kept status using the log string to
this named file. If these log names are absent, the default logging
destination for the log string is syslog, but only for non-kept
promises. Only the @code{log_string} is affected by this setting. Other messages
destined for logging are sent to syslog.

It is intended that named file logs should be different for the three
cases: promise kept, promise not kept and promise repaired.

@item @code{audit}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false switch for detailed audit records of this promise


@b{Example}:@*
@*

@verbatim

body action example
{
# ...

audit => "true";
}

@end verbatim


@b{Notes}:@*
@*


If this is set, cfengine will perform auditing on this specific 
promise. This means that all details surrounding the verification of
the current promise will be recorded in the audit database. The
database may be inspected with @code{cf-report}, or @code{cfshow} in
cfengine 2.


@item @code{background}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false switch for parallelizing the promise repair


@b{Example}:@*
@*

@verbatim

body action example
{
background => "true";
}

@end verbatim


@b{Notes}:@*
@*

If possible, background the verification of the current promise. This
is advantageous only if the verification might take a significant
amount of time, e.g. in remote copying of filesystem/disk scans.

@item @code{report_level}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{inform}
          @code{verbose}
          @code{error}
          @code{log}
@end example

@noindent @b{Synopsis}: The reporting level for standard output


@b{Example}:@*
@*

@verbatim

body action example
{
report_level => "verbose";
}

@end verbatim


@b{Notes}:@*
@*

In cfengine 2 one would say @samp{inform=true} or @samp{syslog=true}, etc.
This replaces these levels since they act as encapsulating super-sets.

@item @code{measurement_class}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: If set performance will be measured and recorded under this identifier


@b{Example}:@*
@*

@verbatim


body action measure
{
measurement_class => "$(this.promiser) long job scan of /usr";
}

@end verbatim


@b{Notes}:@*
@*

By setting this string you switch on performance measurement for the
current promise, and also give the measurement a name. The identifier forms a
partial identity for optional performance scanning of promises of the form:

@example
@var{ID:promise-type:promiser}.
@end example

These can be seen identifying  using @code{cf-reports}, e.g. in the
generated file @file{performance.html}.

@end table


@node classes in *, ifvarclass in *, action in *, * in agent promises
@subsection @code{classes} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{promise_repaired}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A list of classes to be defined


@b{Example}:@*
@*


@verbatim

body classes example
{
promise_repaired => { "change_happened" };
}

@end verbatim


@b{Notes}:@*
@*

If a promise is `repaired' it means that a corrective action had to be
taken to keep the promise.


Important: complex promises, e.g. @code{files} promises that set
multiple parameters on a file simultaneously can report misleadingly.
The classes for different parts of a promise are not separable. Thus,
if you promise to create and file and change its permissions, when the
file exists with incorrect permissions, @code{cf-agent} will report
that the @samp{promise_kept} for the file existence, but
@samp{promise_repaired} for the permissions. If you need separate
reports, you should code two separate promises rather than `overloading'
a single one.


@item @code{repair_failed}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A list of classes to be defined


@b{Example}:@*
@*

@verbatim

body classes example
{
repair_failed => { "unknown_error" };
}

@end verbatim



@b{Notes}:@*
@*

A promise could not be repaired because the corrective
action failed for some reason.


@item @code{repair_denied}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A list of classes to be defined


@b{Example}:@*
@*

@verbatim

body classes example
{
repair_denied => { "permission_failure" };
}

@end verbatim


@b{Notes}:@*
@*

A promise could not be kept because access to a key resource
was denied.

@item @code{repair_timeout}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A list of classes to be defined


@b{Example}:@*
@*


@verbatim

body classes example
{
repair_timeout => { "too_slow", "did_not_wait" };
}

@end verbatim




@b{Notes}:@*
@*

A promise maintenance repair timed-out waiting for some dependent resource.

@item @code{promise_kept}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A list of classes to be defined


@b{Example}:@*
@*


@verbatim

body classes example
{
promise_kept => { "success", "kaplah" };
}

@end verbatim


@b{Notes}:@*
@*

This class is set if no action was necessary by @code{cf-agent}
because the promise concerned was aready kept without further action
required.

Important: complex promises, e.g. @code{files} promises that set
multiple parameters on a file simultaneously can report misleadingly.
The classes for different parts of a promise are not separable. Thus,
if you promise to create and file and change its permissions, when the
file exists with incorrect permissions, @code{cf-agent} will report
that the @samp{promise_kept} for the file existence, but
@samp{promise_repaired} for the permissions. If you need separate
reports, you should code two separate promises rather than `overloading'
a single one.



@item @code{persist_time}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: A number of minutes the specified classes should remain active


@b{Example}:@*
@*

@verbatim

body classes example
{
persist_time => "10";
}

@end verbatim


@b{Notes}:@*
@*

By default classes are ephemeral entities that disappear when @code{cf-agent}
terminates. By setting a persistence time, they can last even when the agent
is not running.

@item @code{timer_policy}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{absolute}
          @code{reset}
@end example

@noindent @b{Synopsis}: Whether a persistent class restarts its counter when rediscovered


@b{Example}:@*
@*

@verbatim

body classes example
{
timer_policy => "reset";
}

@end verbatim


@b{Notes}:@*
@*

The in most cases resetting a timer will give a more honest appraisal
of which classes are currently important, but if we want to activate
a response of limited duration as a rare event then an asbolute
time limit is useful.

@end table


@node ifvarclass in *, handle in *, classes in *, * in agent promises
@subsection @code{ifvarclass}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Extended classes ANDed with context


@noindent @b{Example}:@*
@*

The generic example has the form:
@example

@var{promise-type}:

  "@var{promiser}"
 
    ifvarclass => "$(program)_running|($(program)_notfound&Hr12)";

@end example

@noindent A specific example would be:

@verbatim

bundle agent example

{     
commands:

 any::

    "/bin/echo This is linux"

       ifvarclass => "linux";


    "/bin/echo This is solaris"

       ifvarclass => "solaris";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This is an additional class expression that will be evaluated after
the @samp{@var{class}::} classes have selected promises. It is
provided in order to enable a channel between variables and classes.
The result is thus the logical AND of the ordinary classes and the
variable classes.

This function is provided so that one can form expressions that link
variables and classes, e.g.

@verbatim
# Check that all components are running

vars:

  "component" slist => { "cf-monitord", "cf-serverd" };

processes:

  "$(component)" restart_class => canonify("start_$(component)");

commands:

   "/var/cfengine/bin/$(component)"

       ifvarclass => canonify("start_$(component)");

@end verbatim

Notice that the function @code{canonify()} is provided to convert a
general variable input into a string composed only of legal
characters, using the same algorithm that cfengine uses.



@node handle in *, depends_on in *, ifvarclass in *, * in agent promises
@subsection @code{handle}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A unique id-tag string for referring to this as a promisee elsewhere


@noindent @b{Example}:@*
@*

@verbatim

access:

  "/source"

    handle  => "update_rule",
    admit   => { "127.0.0.1" };

@end verbatim


@noindent @b{Notes}:@*
@*

A promise handle is like a `goto' label. It allows you to refer to a promise as the promisee
of @code{depends_on} client of another promise. Handles are essential for mapping dependencies
and performing impact analyses.



@node depends_on in *, comment in *, handle in *, * in agent promises
@subsection @code{depends_on}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A list of promise handles that this promise builds on or depends on somehow (for knowledge management)


@noindent @b{Example}:@*
@*

@verbatim

files:

  "/home/mark/tmp/testcopy" 

    builds_on    => { "server_promise_1" },
    copy_from    => mycopy("/source");

@end verbatim


@noindent @b{Notes}:@*
@*

This is a list of promise handles for whom this promise is a promisee. In other words,
we acknowledge that this promise will be affected by the list of promises whose handles
are specified.



@node comment in *,  , depends_on in *, * in agent promises
@subsection @code{comment}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A comment about this promise's real intention that follows through the program


@noindent @b{Example}:@*
@*

@verbatim

comment => "This comment follows the data for reference ...",

@end verbatim


@noindent @b{Notes}:@*
@*

Comments written in code follow the program, they are not merely discarded.
They appear in reports and error messages.



@node * in edit_line promises,  , * in agent promises, Bundles for common
@section @code{*} promises in @samp{edit_line}

@*

Most promise bodies belong to one and only one type of promise.  The
generic `*' promises bodies can be added to any promise type in
@code{cf-agent}, hence the star which means `any'.


The body attributes described below can be added to any promise rule
in the agent. These promises address matters of a completely general
nature -- how cfengine behaves as it attempts to keep a promise,
comments about the promises etc.

@*

@verbatim

files:

   "/etc/passwd" -> "Security team"

      perms  => p("644"),
      action => justcheck,
      comment => "This was decided in internal procedures XYZ123";

@end verbatim

@*




@menu
* select_region in *::          
@end menu

@node select_region in *,  , * in edit_line promises, * in edit_line promises
@subsection @code{select_region} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{select_start}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Regular expression matching start of edit region


@b{Example}:@*
@*

@verbatim

body select_region example(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

@end verbatim



@b{Notes}:@*
@*

See also @code{select_end}. These delimiters mark out the region
of a file to be edited. In the example, it is assumed that the file
has section markers. 

@smallexample
[section 1]

lines.
lines...


[section 2]

lines ....
etc..

@end smallexample

@noindent The start marker includes the first matched line.

@item @code{select_end}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Regular expression matches end of edit region from start


@b{Example}:@*
@*


@verbatim

body select_region example(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

@end verbatim


@b{Notes}:@*
@*

See also @code{select_start}. These delimiters mark out the region
of a file to be edited. In the example, it is assumed that the file
has section markes 

@smallexample
[section 1]

lines.
lines...


[section 2]

lines ....
etc..

@end smallexample

If you want to match from a starting location to the end of file, then just omit
the @code{select_end} promise and it will run to the end of file.

@end table
@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Bundles for agent, Bundles for server, Bundles for common, Top
@chapter Bundles of @code{agent}

@*

@cartouche
@smallexample

bundle agent main(parameter)

@{
vars:

  "sys_files"    slist        => @{
                                 "/etc/passwd",
                                 "/etc/services"
                                 @};
files:

  "$(sys_files)" perms        => p("root","0644"),
                 changes      => trip_wire;

  "/etc/shadow"  perms        => p("root","0600"),
                 changes      => trip_wire;

  "/usr"         changes      => trip_wire,
                 depth_search => recurse("inf");

  "/tmp"         delete       => tidy,
                 file_select  => days("2"),
                 depth_search => recurse("inf");

@}

@end smallexample
@end cartouche

@*

Agent bundles contain user-defined promises for @code{cf-agent}. The
types of promises and their corresponding bodies are detailed below.



@menu
* commands in agent promises::  
* databases in agent promises::  
* files in agent promises::     
* delete_lines in edit_line promises::  
* insert_lines in edit_line promises::  
* field_edits in edit_line promises::  
* replace_patterns in edit_line promises::  
* interfaces in agent promises::  
* methods in agent promises::   
* packages in agent promises::  
* processes in agent promises::  
* storage in agent promises::   
@end menu

@node commands in agent promises, databases in agent promises, Bundles for agent, Bundles for agent
@section @code{commands} promises in @samp{agent}

@*


@cartouche
@smallexample

commands:

  @var{"/path/to/command args"}

             args => "@var{more args}",
             contain => @var{contain_body},
             module => @var{true/false};

@end smallexample
@end cartouche

Command @i{containment} allows you to make a `sandbox' around a
command, to run it as a non-privileged user inside an isolated
directory tree. Cfengine @code{modules} are commands that support a simple
protocol (see below) in order to set additional variables and classes
on execution from user defined code. Modules are intended for use as
system probes rather than additional configuration promises.

In cfengine 3 commands and processes have been separated
cleanly. Restarting of processes must be coded as a separate
command. This stricter type separation will allow more careful
conflict analysis to be carried out.

Output from commands executed here is quoted inline, but prefixed
with the letter @samp{Q} to distinguish it from other output, e.g.
from @code{reports}.

Commands were called @code{shellcommands} in cfengine previously.
Modules were

@i{NOTE: a common mistake in using cfengine is to embed many shell
commands instead of using the built-in functionality. Use of cfengine
internals is preferred as it assures convergence and proper integrated
checking. Extensive use of shell commands will make a cfengine
execution very heavy-weight like other management systems. To minimize
the system cost of execution, always use cfengine internals.}

@*

@verbatim

bundle agent example

{
commands:

  "/bin/sleep 10"
     action  => background;

  "/bin/sleep"
     args => "20",
     action  => background;

}

@end verbatim

@*



@menu
* args in commands::            
* contain in commands::         
* module in commands::          
@end menu

@node args in commands, contain in commands, commands in agent promises, commands in agent promises
@subsection @code{args}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Alternative string of arguments for the command (concatenated with promiser string)


@noindent @b{Example}:@*
@*

@verbatim

commands:

  "/bin/echo one"

   args => "two three";

@end verbatim


@noindent @b{Notes}:@*
@*

Sometimes it is convenient to separate the arguments to a command from
the command itself. The final arguments are the concatenation with one
space. So in the example above the command would be

@verbatim

 /bin/echo one two three

@end verbatim




@node contain in commands, module in commands, args in commands, commands in agent promises
@subsection @code{contain} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{useshell}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false embed the command in a shell environment (true)


@b{Example}:@*
@*

@verbatim

body contain example
{
useshell => "true";
}

@end verbatim


@b{Notes}:@*
@*

The default is to use a shell when executing commands, but this has both
resource and security consequences. A shell consumes an extra process
and inherits environment variables, reads commands from files and performs
other actions beyond the control of cfengine. If one does not need shell
functionality such as piping through multiple commands then it is best
to manage without it.




@item @code{umask}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{0}
          @code{77}
          @code{22}
          @code{27}
          @code{72}
          @code{077}
          @code{022}
          @code{027}
          @code{072}
@end example

@noindent @b{Synopsis}: The umask value for the child process


@b{Example}:@*
@*

@verbatim

body contain example
{
umask => "077";
}

@end verbatim


@b{Notes}:@*
@*

Sets the internal umask for the process. Default value for the mask is @samp{077};

@item @code{exec_owner}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The user name or id under which to run the process


@b{Example}:@*
@*

@verbatim

body contain example
{
exec_owner => "mysql_user";
}

@end verbatim


@b{Notes}:@*
@*

This is part of the restriction of privilege for child processes
when running @code{cf-agent} as the root user, or a user with privileges.


@item @code{exec_group}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The group name or id under which to run the process


@b{Example}:@*
@*


@verbatim

body contain example
{
exec_group => "nogroup";
}

@end verbatim


@b{Notes}:@*
@*

This is part of the restriction of privilege for child processes
when running @code{cf-agent} as the root user, or a user with privileges.

@item @code{exec_timeout}
@b{Type}: int

@noindent @b{Allowed input range}: @code{1,3600}


@noindent @b{Synopsis}: Timeout in seconds for command completion


@b{Example}:@*
@*


@verbatim

body contain example
{
exec_timeout => "30";
}

@end verbatim


@b{Notes}:@*
@*

Attempt to time-out after this number of seconds. This cannot be guaranteed as not all
commands are willing to be interrupted in case of failure.

@item @code{chdir}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Directory for setting current/base directory for the process


@b{Example}:@*
@*

@verbatim

body contain example

{
chdir => "/containment/directory";
}

@end verbatim


@b{Notes}:@*
@*

This command has the effect of placing the running command into a current working
directory equal to the parameter given, i.e. it works like the @samp{cd} shell command. 

@item @code{chroot}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Directory of root sandbox for process


@b{Example}:@*
@*

@verbatim

body contain example

{
chroot => "/private/path";
}

@end verbatim


@b{Notes}:@*
@*

Sets the path of the directory that will be experienced as the top-most
root directory for the process. In security parlance, this creates
a `sandbox' for the process.

@item @code{preview}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false preview command when running in dry-run mode (with -n)


@b{Example}:@*
@*

@verbatim

body contain example
{
preview => "true";
}

@end verbatim


@b{Notes}:@*
@*

Previewing shell scripts during a dry-run is a potentially misleading
activity. It should only be used on scripts that make no changes to
the system. It is cfengine best practice to never write
change-functionality into user-written scripts except as a last
resort: cfengine can apply its safety checks to user defined scripts.

@item @code{no_output}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false discard all output from the command


@b{Example}:@*
@*

@verbatim

body contain example
{
no_output => "true";
}

@end verbatim


@b{Notes}:@*
@*

This is equivalent to piping standard output and error to @file{/dev/null}.

@end table


@node module in commands,  , contain in commands, commands in agent promises
@subsection @code{module}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to expect the cfengine module protocol


@noindent @b{Example}:@*
@*

@verbatim

commands:

   "/masterfiles/user_script"

     module => "true";

@end verbatim


@noindent @b{Notes}:@*
@*

If true, the module protocol is supported for this script, i.e. it is treated as a user
module. A plug-in module may
be written in any language, it can return any output you like, but lines
which begin with a @samp{+} sign are treated as classes to be defined
(like @option{-D}), while lines which begin with a @samp{-} sign are
treated as classes to be undefined (like @option{-N}).  Lines starting
with @samp{=} are variables/macros to be defined.  Any other lines of
output are cited by cfagent, so you should normally make your module
completely silent.  Here is an example module written in perl.

@smallexample
#!/usr/bin/perl
#
# module:myplugin
#

  # lots of computation....

if (@var{special-condition})
   @{
   print "+specialclass";
   @}

@end smallexample

Modules inherit the environment variables from cfagent and accept arguments, just
as a regular command does.

@smallexample
#!/bin/sh
#
# module:myplugin
#

/bin/echo $*

@end smallexample
@code{cf-agent} defines the classes as an environment variable so that programs
have access to these. E.g. try the following module:

@smallexample
#!/usr/bin/perl

print "Decoding $ENV@{CFALLCLASSES@}\n";

@@allclasses = split (":","$ENV@{CFALLCLASSES@}");

while ($c=shift(@@allclasses))
  @{
  $classes@{$c@} = 1;
  print "$c is set\n";
  @}

@end smallexample

Modules define variables in @code{cf-agent} by outputting strings of the form

@smallexample

=@var{variablename}=@var{value}

@end smallexample

These variables end up in a context which has the same name as the module.
When the @code{$(allclasses)} variable becomes too large to manipulate conveniently,
you can access the complete list of currently defined classes in the file
@file{/var/cfengine/state/allclasses}.



@node databases in agent promises, files in agent promises, commands in agent promises, Bundles for agent
@section @code{databases} promises in @samp{agent}

@*

@i{These features apply to Enterprise versions of cfengine only}.

Cfengine Nova can interact with commonly used database servers to keep
promises about the structure and content of data within them.


There are two main cases of database management to address: small
embedded databases and large centralized databases. 

Cfengine is a tool whose strength lies distributed management of
computers.  Databases are often centralized entities that have
single point of management, so a large monolithic database
is more easily managed with other tools. However, cfengine can still
monitor changes and discrepancies, and it can manage smaller embedded
databases that are distributed in nature, whether they are SQL,
registry or future types.

So creating 100 new databsaes for test purposes is a task for
cfengine, but adding a new item to an important production database is
not a task that we recommend using cfengine for.  

There are three kinds of database supported by Nova:

@table @emph

@item LDAP - The Lightweight Directory Access Protocol
A hierarchical network database primarily for reading simple schema.

@item SQL - Structured Query Language
A number of relational databases (currently supported: MySQL, Postgres)
for reading and writing complex data.

@item Registry - Microsoft Registry
An embedded database for interfacing with system values in Microsodt Windows.

@end table
In addition, cfengine uses a  variety of embedded databases
for its own internals.


Cfengine's ability to make promises about databases depends on the
good grace of the database server. Embedded databases are directly
part of the system and promises can be made directly. However,
databases running through a server process (either on the same host or
on a different host) are independent agents and cfengine cannot make
promises on their behalf, unless they promise (grant) permission for
cfengine to make the changes. Thus the pre-requisite for making
SQL database promises is to grant a point of access on the server.


@cartouche
@smallexample 

 databases:

  "@var{database}/@var{subkey or table}"

    database_operation => "@var{create/delete/drop}",
    database_type => "@var{sql/ms_registry}",
    database_columns => @{ 
                        "@var{name},@var{type},@var{size}",
                        "@var{name},@var{type}",
                        @},

    database_server => @var{body};


 body database_server @var{name}
  @{
  db_server_owner => "@var{account name}";
  db_server_password => "@var{password}";
  db_server_host => "@var{hostname or omit for localhost}";
  db_server_type => "@var{mysql/posgres}";
  db_server_connection_db => "@var{database we can connect to}";
  @}

@end smallexample
@end cartouche

@*

@verbatim

body common control
{
bundlesequence => { "databases" };
}

bundle agent databases

{
#commands:

#  "/usr/bin/createdb cf_topic_maps",

#        contain => as_user("mysql");

databases:

  "cf_topic_maps/topics"

    database_operation => "create",
    database_type => "sql",
    database_columns => { 
                        "topic_name,varchar,256",
                        "topic_comment,varchar,1024",
                        "topic_id,varchar,256",
                        "topic_type,varchar,256",
                        "topic_extra,varchar,26" 
                        },

    database_server => myserver;



}

################################################

body database_server myserver
{
any::
 db_server_owner => "postgres";
 db_server_password => "";
 db_server_host => "localhost";
 db_server_type => "postgres";
 db_server_connection_db => "postgres";
none::
 db_server_owner => "root";
 db_server_password => "";
 db_server_host => "localhost";
 db_server_type => "mysql";
 db_server_connection_db => "mysql";
}

body contain as_user(x)
{
exec_owner => "$(x)";
}
@end verbatim

@*

The promiser in database promises is a concatenation of the database name and underlying tables.
This presents a simple hierarchical model that looks like a file-system. This is the normal
structure within the Windows registry for instance. Entity-Relation databases do not normally
present tables in this way, but no harm is done in representing them as a hierarchy of depth 1.



@menu
* database_server in databases::  
* database_type in databases::  
* database_operation in databases::  
* database_columns in databases::  
* database_rows in databases::  
* registry_exclude in databases::  
@end menu

@node database_server in databases, database_type in databases, databases in agent promises, databases in agent promises
@subsection @code{database_server} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{db_server_owner}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: User name for database connection


@b{Example}:@*
@*

@verbatim

db_server_owner => "mark";

@end verbatim


@b{Notes}:@*
@*

@item @code{db_server_password}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Clear text password for database connection


@b{Example}:@*
@*

@verbatim

db_server_password => "xyz.1234";

@end verbatim


@b{Notes}:@*
@*

@item @code{db_server_host}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Hostname or address for connection to database, blank means localhost


@b{Example}:@*
@*

@verbatim

db_server_host => "sqlserv.example.org";

@end verbatim


@b{Notes}:@*
@*

Hostname or IP address of the server.

@item @code{db_server_type}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{postgres}
          @code{mysql}
@end example

@noindent @b{Synopsis}: The dialect of the database server


@b{Example}:@*
@*

@verbatim

db_server_type => "postgres";

@end verbatim


@b{Notes}:@*
@*


@item @code{db_server_connection_db}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The name of an existing database to connect to in order to create/manage other databases


@b{Example}:@*
@*

@verbatim

body database_server myserver(x)
{
db_server_owner => "$(x)";
db_server_password => "";
db_server_host => "localhost";
db_server_type => "$(mysql)";
db_server_connection_db => "$(x)";
}

@end verbatim

@noindent where @samp{x} is currently @code{mysql} or @code{postgres}.


@b{Notes}:@*
@*

In order to create a database on a database server (all of which
practice voluntary cooperation), one has to be able to connect
to the server, however, without an existing database this is not allowed.
Thus, database servers provide a default database that can be connected
to in order to thereafter create new databases. These are called
@code{postgres} and @code{mysql} for their respective database servers.

For the knowledge agent, this setting is made in the control body,
for database verification promises, it is made in the 
@code{database_server} body.

@end table


@node database_type in databases, database_operation in databases, database_server in databases, databases in agent promises
@subsection @code{database_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{sql}
          @code{ms_registry}
@end example

@noindent @b{Synopsis}: The type of database that is to be manipulated


@noindent @b{Example}:@*
@*

@verbatim

database_type => "@var{ms_registry}";

@end verbatim


@noindent @b{Notes}:@*
@*



@node database_operation in databases, database_columns in databases, database_type in databases, databases in agent promises
@subsection @code{database_operation}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{create}
          @code{delete}
          @code{drop}
          @code{cache}
          @code{verify}
          @code{restore}
@end example

@noindent @b{Synopsis}: The nature of the promise - to be or not to be


@noindent @b{Example}:@*
@*

@verbatim

database_operation => "create";

@end verbatim


@noindent @b{Notes}:@*
@*




@node database_columns in databases, database_rows in databases, database_operation in databases, databases in agent promises
@subsection @code{database_columns}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: A list of column definitions to be promised by SQL databases


@noindent @b{Example}:@*
@*

@verbatim

  "cf_topic_maps/topics"

    database_operation => "create",
    database_type => "sql",
    database_columns => { 
                        "topic_name,varchar,256",
                        "topic_comment,varchar,1024",
                        "topic_id,varchar,256",
                        "topic_type,varchar,256",
                        "topic_extra,varchar,26" 
                        },

    database_server => myserver;

@end verbatim


@noindent @b{Notes}:@*
@*

Columns are a list of tuplets (@var{Name,type,size}). Array items are triplets, and fixed size data elements are doublets.



@node database_rows in databases, registry_exclude in databases, database_columns in databases, databases in agent promises
@subsection @code{database_rows}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: @code{.*,.*}


@noindent @b{Synopsis}: An ordered list of row values to be promised by SQL databases


@noindent @b{Example}:@*
@*

@verbatim

bundle agent databases

{
databases:

 windows::

  # Regsitry has (value,data) pairs in "keys" which are directories

  "HKEY_LOCAL_MACHINE\SOFTWARE\Cfengine AS\Cfengine"

    database_operation => "create",
    database_rows => { "value1,REG_SZ,new value 1", "value2,REG_SZ,new val 2"} ,
    database_type     => "ms_registry";
}

@end verbatim


@noindent @b{Notes}:@*
@*

This constraint is used only in adding data to database columns. Rows are considered to be
instances of individual columns. In the case of the system registry on Windows, the rows
represent data on data-value pairs.



@node registry_exclude in databases,  , database_rows in databases, databases in agent promises
@subsection @code{registry_exclude}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A list of regular expressions to ignore in key/value verification


@noindent @b{Example}:@*
@*

@verbatim

databases:

 "HKEY_LOCAL_MACHINE\SOFTWARE"

    database_operation => "cache",

    registry_exclude => { ".*Windows.*CurrentVersion.*", 
                          ".*Touchpad.*", ".*Capabilities.FileAssociations.*", 
                          ".*Rfc1766.*" , 
                          ".*Synaptics.SynTP.*", 
                          ".*SupportedDevices.*8086", 
                          ".*Microsoft.*ErrorThresholds" 
                        },

    database_type     => "ms_registry";

@end verbatim


@noindent @b{Notes}:@*
@*

During recursive Windows registry scanning, this option allows us to ignore keys of values matching a
list of regular expressions. Some values in the registry are ephemeral and some should not be considered.
This provdes a convenient way of avoiding names. It is analogous to @code{exclude_dirs} for files.



@node files in agent promises, delete_lines in edit_line promises, databases in agent promises, Bundles for agent
@section @code{files} promises in @samp{agent}

@*

Files promises are an umbrella concept for all attributes of files. 
Operations fall basically into three categories: create, delete and
edit. 

@cartouche
@smallexample

 files:

   "@var{/path/file_object}"

       perms => @var{perms_body},
       ... ;

@end smallexample
@end cartouche

Prior to version 3, file promises were scattered into many different
types such as @code{files}, @code{tidy}, @code{copy}, @code{links},
etc.  File handling in cfengine 3 uses regular expressions everywhere for pattern
matching. The old `wildcard/globbing' expressions @samp{*} and
@samp{?}  are deprecated, and everything is based consistently on Perl
Compatible Regular Expressions where these are available. If PCRE is
not available on the local system, POSIX extended regular expressions
are used.


There is a natural ordering in file processing that obviates the need
for the actionsequence. The trick of using multiple actionsequence
items with different classes, e.g.

@verbatim
 actionsequence = ( ... files.one  ..  files.two )
@end verbatim

can now be handled more elegantly using bundles. The natural ordering 
uses that fact that some operations are mutually exclusive and that
some operations do not make sense in reverse order. For example,
editing a file and then copying onto it would be nonsense.
Similarly, you cannot both remove a file and rename it.

@noindent @b{File copying}

One of the first things users of cfengine 2 will notice is that copying is now `backwards'.
Instead of the default object being source and the option being the destination,
in cfengine 3 the destination is paramount and the source is an option.
This is because the model of voluntary cooperation tells us that it is the
object that is changed which is the agent making the promise. One cannot
force change onto a destination with cfengine, one can only invite change from
a source.

@noindent @b{Normal ordering}

Cfengine 3 no longer has an `action sequence'. Ordering of operations has,
in most cases, a natural ordering which is assumed by the agent. For instance:
`delete then create' (normal ordering) makes sense, but
`create then delete' does not. This sort of principle can be extended to
deal with all aspects of file promises.

The diagram below shows the ordering. Notice that the same ordering
applies regardless of file type (plain-file or directory).

@image{filelogic,10cm,,The normal ordering of file operators in cfengine 3,png}

The pseudo-code for this logic is shown in the diagram and below:

@verbatim
 for each file promise-object
    {
    if (depth_search) 

      do 
        DepthSearch (HandleLeaf)
      else 
        (HandleLeaf)
      done
    }

 HandleLeaf()
   {
   Does leaf-file exist?

     NO:  create
     YES: rename,delete,touch, 

     do
      for all servers in {localhost, @(servers)}
         {
         if (server-will-provide)
            do
              if (depth_search)
                 embedded source-depth-search (use file source)
                 break
              else
                 (use file source)
                 break
              done
            done
         }
     done
      
   Do all links (always local)

   Check Permissions

   Do edits
   }

@end verbatim

@noindent @b{Depth searches (recursion) during searches}

In cfengine 2 there was the concept of recursion during file
searches. Recursion is now called "depth-search". 
In addition, it was possible to specify
wildcards in the base-path for this search. Cfengine 3 replaces
the `globbing' symbols with standard regular expressions:

@verbatim

      Cfengine 2               Cfengine 3

/one/*/two/thr*/four    /one/.*/two/thr.*/four

@end verbatim

When we talk about a depth search, it refers to a search for file
objects which starts from the one or more matched base-paths as shown
in the example above.

@noindent @b{Local and remote searches}

There are two distinct kinds of depth
search:

@itemize
@item A local search over promiser agents.
@item A remote search over provider agents.
@end itemize

When we are @i{copying} or @i{linking} to a file source, it is the search over
the @i{remote} source that drives the content of a promise (the
promise is a promise to use what the remote source provides). In
general, the sources are on a different device to the images that make
the promises.  For all other promises, we search over existing local
objects.


If we specify depth search together with copy of a directory, then the
implied remote source search is assumed, and it is made after the
search over local base-path objects has been made. If you mix complex
promise body operations in a single prmose, this could lead to
confusion about the resulting behaviour, and a warning is issued. In
general it is not recommended to mix searches without a full
understanding of the consequences, but this might occasionally be
useful.

Depth search is not allowed with editfiles promises.

@noindent @b{File editing in cfengine 3}

Cfengine 2 assumed that all files were line-edited, because it was
based on Unix traditions. Since then many new file formats have
emerged, including XML.  Cfengine 3 opens up the possibiltiy for
multiple models of file editing. Line based editing is still present and
is both much simplified and much more powerful than previously.

File editing is not just a single kind of promise but a whole range of
`promises within files'. It is therefore not merely a body to a single kind of
promise, but a bundle of sub-promises. After all, inside each file is a new
world of objects that can make promises, quite separate from files' external
attributes.

A typical file editing stanza has the elements in the following
example.


@verbatim
######################################################################
#
# File editing
#
######################################################################

body common control

{
version => "1.2.3";
bundlesequence  => { "outerbundle"  };
}

########################################################

bundle agent outerbundle

{
files:

  "/home/mark/tmp/cf3_test"

       create    => "true",     # Like autocreate in cf2
       edit_line => inner_bundle;
}

########################################################

bundle edit_line inner_bundle
  {
  vars:

   "edit_variable" string => "private edit variable"; 
  
  replace_patterns:

   # replace shell comments with C comments

   "#(.*)"

      replace_with => C_comment,
     select_region => MySection("New section");

  reports:

    someclass::

      "This is file $(edit.filename)"
  }

########################################
# Bodies for the library ...
########################################

body replace_with C_comment

{
replace_value => "/* $(1) */"; # backreference 0
occurrences => "all";          # first, last all
}

########################################################

body select_region MySection(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

@end verbatim

@noindent There are several things to notice:

@itemize
@item 
The line-editing promises are all convergent promises about patterns within
the file. They have bodies, just like other attributes do and these allow us to make
simple templates about file editing while extending the power of the basic primitives.

@item 
All pattern matching is through perl compatible regular expressions
@item 
Editing takes place within a marked region (which defaults to the whole file).
@item 
Search/replace functions now allow back-references.
@item 
The line edit model now contains a field or column model for dealing with tabular files such
as Unix @file{passwd} and @file{group} files. We can now apply powerful convergent editing operations
to single fields inside a table, to append, order and delete items from lists inside fields.

@item
The special variable @code{$(edit.filename)} contains the name of the file being edited within
an edit bundle.
@end itemize

@noindent In the example above, back references are used to allow conversion of comments from shell-style
to C-style.


@*

@verbatim

bundle agent example
{
files:

  "/home/mark/tmp" -> "Security team"

       changes      => lay_a_tripwire,
       depth_search => recurse("inf"),
       action       => background;
}

#########################################################

body changes lay_a_tripwire

{
hash           => "md5";
report_changes => "content";
update         => "yes";
}

@end verbatim

@*



@menu
* acl in files::                
* changes in files::            
* copy_from in files::          
* create in files::             
* delete in files::             
* depth_search in files::       
* edit_line in files::          
* edit_xml in files::           
* edit_defaults in files::      
* file_select in files::        
* link_from in files::          
* move_obstructions in files::  
* pathtype in files::           
* perms in files::              
* rename in files::             
* repository in files::         
* touch in files::              
* transformer in files::        
@end menu

@node acl in files, changes in files, files in agent promises, files in agent promises
@subsection @code{acl} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{aces}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{((user|group):[^:]+:[-=+,rwx()]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)}


@noindent @b{Synopsis}: Native settings for access control entry


@b{Example}:@*
@*

@verbatim

body acl template

{
acl_method => "overwrite";
acl_type => "posix";
acl_directory_inherit => "parent";

aces => { 
        "user:*:r(wwx),-r:allow", 
        "group:*:+rw:allow", 
        "mask:x:allow", 
        "all:r"
        };
}

@end verbatim


@b{Notes}:@*
@*

Form of the
permissions is:

@cartouche
@smallexample
      aces => @{
              "@var{user:uid:mode[:perm_type]}", ..., 
              "@var{group:gid:mode[:perm_type]}", ..., 
              "@var{all:mode[:perm_type]}"
              @};
@end smallexample
@end cartouche

@itemize
@item @code{user} indicates that the line applies to a user specified
  by the user identitfier @code{uid}. @code{mode} is the permission
  mode string.

@item @code{group} indicates that the line applies to a group specified
  by the group identitfier @code{gid}. @code{mode} is the permission
  mode string.

@item @code{all} indicates that the line applies to every
  user. @code{mode} is the permission mode string.

@item @code{uid} is a valid user identifier for the system and
  cannot be empty. However, @code{uid} can be set to * as a synonym
  for the entity that owns the file system object (e.g. user:*:r).

@item @code{gid} is a valid group identifier for the system and
  cannot be empty. However, in some acl types, @code{gid} can be set
  to * to indicate a special group (e.g. in POSIX this refers to the
  file group).

@item @code{mode} is one or more strings
  @code{op}|@code{perms}|(@code{nperms}); a concatenation of @code{op},
  @code{perms} and optionally (@code{nperms}), see below, separated
  with commas (e.g. +rx,-w(s)). @code{mode} is parsed from left to
  right. 
@c TODO: include support for @code{fullaccess}, @code{noaccess},
@c and @code{remove}

@item @code{op} specifies the operation on any existing permissions,
  if the defined ACE already exists. @code{op} can be =, empty, + or
  -. = or empty sets the permissions to the ACE as stated, + adds and
  - removes the permissions from any existing ACE.
  @c TODO: what to do if + or - is used when ACE does not exist?

@item @code{nperms} (optional) specifies file system specific
  (native) permissions. Only valid if @code{acl_type} is
  defined. @code{nperms} will only be enforced if the file object is
  stored on a file system supporting the acl type set in
  @code{acl_type} (e.g. @code{nperms} will be ignored if
  @code{acl_type:}@code{ntfs} and the object is stored on a file system
  not supporting ntfs ACLs). Valid values for @code{nperms} varies with
  different ACL types, and is defined in subsequent sections.

@item @code{perm_type} (optional) can be set to either @code{allow} or
  @code{deny}, and defaults to @code{allow}. @code{deny} is only valid
  if @code{acl_type} is set to an ACL type that support deny
  permissions. A @code{deny} ACE will only be enforced if the file
  object is stored on a file system supporting the acl type set in
  @code{acl_type}.
@end itemize

@code{gperms} (generic permissions) is a concatenation of zero or more
of the characters shown in the table below. If left empty,
none of the permissions are set.
@c TODO: Should be allowed to set no permissions (empty perms?)


@multitable @columnfractions .05 .2 .30 .35
@headitem Flag @tab Description @tab Semantics on file @tab Semantics on directory

@item @code{r} @tab Read @tab Read data, permissions, attributes @tab Read
directory contents, permissions, attributes
@item @code{w} @tab Write @tab Write data @tab Create, delete, rename subobjects
@item @code{x} @tab Execute @tab Execute file @tab Access subobjects
@end multitable


Note that the @code{r} permission is not neccessary to read an object's
permissions and attributes in all file systems (e.g. in POSIX, having
@code{x} on its containing directory is sufficient).


@item @code{acl_directory_inherit}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{parent}
          @code{specify}
          @code{none}
@end example

@noindent @b{Synopsis}: Access control list type for the affected file system


@b{Example}:@*
@*

@verbatim

body acl template

{
acl_method => "overwrite";
acl_type => "posix";
acl_directory_inherit => "parent";

aces => { 
        "user:*:r(wwx),-r:allow", 
        "group:*:+rw:allow", 
        "mask:x:allow", 
        "all:r"
        };
}

@end verbatim


@b{Notes}:@*
@*



Directories have ACLs associated with them, but they also have the
ability to inherit an ACL to sub-objects created within them. POSIX
calls the former ACL type "access ACL" and the latter "default ACL",
and we will use the same terminology.

In some file systems, like NTFS, objects can only inherit the access
ACL of the parent directory (or nothing). There are also differences
in what is inherited by default. In POSIX, the default ACL is usually
unset, which results in no ACL inheritance, while NTFS always inherits
the access ACL to subobjects.


@item @code{acl_method}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{append}
          @code{overwrite}
@end example

@noindent @b{Synopsis}: Editing method for access control list


@b{Example}:@*
@*

@verbatim

body acl template

{
acl_method => "overwrite";
acl_type => "posix";
acl_directory_inherit => "parent";
aces => { "user:*:r(wwx),-r:allow", "group:*:+rw:allow", "mask:x:allow", "all:r"};
}

@end verbatim


@b{Notes}:@*
@*


@item @code{acl_type}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{generic}
          @code{posix}
          @code{ntfs}
@end example

@noindent @b{Synopsis}: Access control list type for the affected file system


@b{Example}:@*
@*

@verbatim

body acl template

{
acl_method => "overwrite";
acl_type => "posix";
acl_directory_inherit => "parent";
aces => { "user:*:r(wwx),-r:allow", "group:*:+rw:allow", "mask:x:allow", "all:r"};
}

@end verbatim


@b{Notes}:@*
@*

@item @code{specify_inherit_aces}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{((user|group):[^:]+:[-=+,rwx()]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)}


@noindent @b{Synopsis}: Native settings for access control entry


@b{Example}:@*
@*

@verbatim
body acl template
{
specify_inherit_aces => {  "all:r" };
}
@end verbatim


@b{Notes}:@*
@*

 @code{specify_inherit_aces} (optional) is a list of access control
  entries that are set on child objects. It is also parsed from left
  to right and allows multiple entries with same entity-type and
  id. Only valid if @code{acl_directory_inherit} is set to
  @code{specify}.

This is an acl which makes explicit setting for the acl inherited by
new objects within a directory. It is included for those implementations
that do not have a clear inheritance policy.

@end table


@node changes in files, copy_from in files, acl in files, files in agent promises
@subsection @code{changes} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{hash}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{md5}
          @code{sha1}
          @code{best}
@end example

@noindent @b{Synopsis}: Hash files for change detection


@b{Example}:@*
@*


@verbatim

body changes example
{
hash => "md5";
}

@end verbatim


@b{Notes}:@*
@*

The @code{best} option cross correlates the best two available
algorithms known in the OpenSSL library.


@item @code{report_changes}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{all}
          @code{stats}
          @code{content}
          @code{none}
@end example

@noindent @b{Synopsis}: Specify criteria for change warnings


@b{Example}:@*
@*

@verbatim

body changes example
{
report_changes => "content";
}

@end verbatim


@b{Notes}:@*
@*

Files can change in permissions and contents, i.e. external or internal attributes.
If @samp{all} is chosen all attributes are checked.

@item @code{update_hashes}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Update hash values immediately after change warning


@b{Example}:@*
@*

@verbatim

body changes example
{
update_hashes => "true";
}

@end verbatim


@b{Notes}:@*
@*

If this is positive, file hashes should be updated as soon as a change
is registered so that multiple warnings are not given about a single
change. This applies to addition and removal too.

@end table


@node copy_from in files, create in files, changes in files, files in agent promises
@subsection @code{copy_from} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{source}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Reference source file from which to copy


@b{Example}:@*
@*


@verbatim

body copy_from example
{
source => "/path/to/source";
}

# or

body link_from example
{
source => "/path/to/source";
}

@end verbatim




@b{Notes}:@*
@*

For remote copies this refers to the file name on the remote server.

@item @code{servers}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[A-Za-z0-9_.:-]+}


@noindent @b{Synopsis}: List of servers in order of preference from which to copy


@b{Example}:@*
@*

@verbatim

body copy_from example
{
servers => { "primary.example.org", "secondary.example.org", 
                 "tertiary.other.domain" };
}

@end verbatim


@b{Notes}:@*
@*

The servers are tried in order until one of them succeeds.

@item @code{collapse_destination_dir}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false Place files in subdirectories into the root destination directory during copy


@b{Example}:@*
@*

@verbatim

body copy_from mycopy(from,server)

{
source      => "$(from)";
servers     => { "$(server)" };
collapse_destination_dir => "true";
}

@end verbatim


@b{Notes}:@*
@*

Under normal operations, recursive copies cause cfengine to track subdirectories
of files. So, for instance, if we copy recurively from @file{src} to @file{dest},
then @file{src/subdir/file} will map to @file{dest/subdir/file}. 

By setting this option to @samp{true}, the promiser destination
directory promises to aggregate files searched from all subdirectories
into itself, i.e. a single destination directory.

@item @code{compare}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{atime}
          @code{mtime}
          @code{ctime}
          @code{digest}
          @code{hash}
@end example

@noindent @b{Synopsis}: Menu option policy for comparing source and image file attributes


@b{Example}:@*
@*


@verbatim

body copy_from example

{
compare => "digest";
}

@end verbatim


@b{Notes}:@*
@*

The default copy method is @samp{mtime} (modification time), meaning that
the source file is copied to the destination (promiser) file, if the
source file has been modified more recently than the destination.

@item @code{copy_backup}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{timestamp}
@end example

@noindent @b{Synopsis}: Menu option policy for file backup/version control


@b{Example}:@*
@*

@verbatim

body copy_from example
{
copy_backup => "timestamp";
}

@end verbatim


@b{Notes}:@*
@*

Determines whether a backup of the previous version is kept on the
system. This should be viewed in connection with the system repository,
since a defined repository affects the location at which the backup
is stored.

@item @code{encrypt}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false use encrypted data stream to connect to remote host


@b{Example}:@*
@*

@verbatim

body copy_from example
{
servers  => { "remote-host.example.org" };
encrypt => "true";
}

@end verbatim


@b{Notes}:@*
@*

Client connections are encrypted with using a Blowfish randomly
generated session key.  The intial connection is encrypted using the
public/private keys for the client and server hosts.

@item @code{check_root}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false check permissions on the root directory when depth_search


@b{Example}:@*
@*

@verbatim

body copy_from example
{
check_root => "true";
}

@end verbatim



@b{Notes}:@*
@*

When copying files recursively (by depth search), this flag determines
whether the permissions of the root directory should be set from the
root of the source. The default is to check only copied file objects
and subdirectories within this root (false).

@item @code{copylink_patterns}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of patterns matching files that should be linked instead of copied


@b{Example}:@*
@*


@verbatim

body copy_from example
{
copylink_patterns => { "special_node1", "other_node.*" };
}

@end verbatim


@b{Notes}:@*
@*


The matches are performed on the last node of the filename, i.e.  the
file without its path.

@item @code{copy_size}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,inf}


@noindent @b{Synopsis}: Integer range of file sizes that may be copied


@b{Example}:@*
@*

@verbatim

body copy_from example
{
copy_size => irange("0","50000");
} 

@end verbatim


@b{Notes}:@*
@*

The use of the irange function is optional. Ranges may also be
specified as a comma separated numbers.

@item @code{findertype}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{MacOSX}
@end example

@noindent @b{Synopsis}: Menu option for default finder type on MacOSX


@b{Example}:@*
@*

@verbatim

body copy_from example
{
findertype => "MacOSX";
}

@end verbatim


@b{Notes}:@*
@*

This applies only to the Macintosh OSX variants.

@item @code{linkcopy_patterns}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of patterns matching symbolic links that should be replaced with copies


@b{Example}:@*
@*

@verbatim

body copy_from mycopy(from)

{
source            => "$(from)";
linkcopy_patterns => { ".*" };
}

@end verbatim


@b{Notes}:@*
@*

The pattern matches the last node filename (i.e. without the absolute path).


@item @code{link_type}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{symlink}
          @code{hardlink}
          @code{relative}
          @code{absolute}
          @code{none}
@end example

@noindent @b{Synopsis}: Menu option for type of links to use when copying


@b{Example}:@*
@*

@verbatim

body link_from example
{
link_type => "hard";
}

@end verbatim


@b{Notes}:@*
@*

What kind of link should be used to link files. Users are advised to
be wary of `hard links' (see Unix manual pages for the @samp{ln}
command). The behaviour of non-symbolic links is often precarious and
unpredictable.

@item @code{force_update}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false force copy update always


@b{Example}:@*
@*

@verbatim

body copy_from example
{
force_update => "true";
}

@end verbatim


@b{Notes}:@*
@*

Warning: this is a non-convergent operation. Although the end point
might stabilize in content, the operation will never quiesce. Use of
this feature is not recommended except in exceptional circumstances
since it creates a busy-dependency. If the copy is a network copy,
the system will be disturbed by network disruptions.

@item @code{force_ipv4}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false force use of ipv4 on ipv6 enabled network


@b{Example}:@*
@*

@verbatim

body copy_from example
{
force_ipv4 => "true";
}

@end verbatim


@b{Notes}:@*
@*

IPv6 should be harmless to most users unless you have a partially
or misconfigured setup.


@item @code{portnumber}
@b{Type}: int

@noindent @b{Allowed input range}: @code{1024,99999}


@noindent @b{Synopsis}: Port number to connect to on server host


@b{Example}:@*
@*

@verbatim

body copy_from example
{
portnumber => "5308";
}

@end verbatim


@b{Notes}:@*
@*

The standard or registered port number is tcp/5308. Cfengine does not
presently use its registered udp port with the same number, but this
could change in the future.

@item @code{preserve}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to preserve file permissions on copied file


@b{Example}:@*
@*

@verbatim

body copy_from example
{
preserve => "true";
}

@end verbatim


@b{Notes}:@*
@*

Whether or not the copy preserves the permissions on the source files.

@item @code{purge}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false purge files on client that do not match files on server when depth_search


@b{Example}:@*
@*


@verbatim

body copy_from example
{
purge => "true";
}

@end verbatim


@b{Notes}:@*
@*

Purging files is a potentially dangerous matter during a file copy it
implies that any promiser (destination) file which is not matched by a
source will be deleted. Since there is no source, this means the file
will be irretrievable. Great care should be exercised when using this
feature.

Note that purging will also delete backup files generated during
the file copying if @code{copy_backup} is set to true.

@item @code{stealth}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to preserve time stamps on copied file


@b{Example}:@*
@*

@verbatim

body copy_from example
{
stealth => "true";
}

@end verbatim


@b{Notes}:@*
@*

Preserves file access and modification times on the promiser files.

@item @code{trustkey}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false trust public keys from remote server if previously unknown


@b{Example}:@*
@*

@verbatim

body copy_from example
{
trustkey => "true";
}

@end verbatim



@b{Notes}:@*
@*

If the server's public key has not already been trusted, this
allows us to accept the key in automated key-exchange.

Note that, as a simple security precaution, trustkey should normally
be set to @samp{false}, to avoid key exchange with a server one is not
one hundred percent sure about, though the risks for a client are
rather low. On the server-side however, trust is often granted to
many clients or to a whole network in which possibly unauthorized
parties might be able to obtain an IP address, thus the trust issue
is most important on the server side.

As soon as a public key has been exchanged, the trust option has no
effect. A machine that has been trusted remains trusted until
its key is manually revoked by a system administrator. Keys are
stored in @file{WORKDIR/ppkeys}.

@item @code{type_check}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false compare file types before copying and require match


@b{Example}:@*
@*

@verbatim

body copy_from example
{
type_check => "false";
}

@end verbatim


@b{Notes}:@*
@*

File types at source and destination should normally match in order for
updates to overwrite them. This option allows this checking to be switched off.

@item @code{verify}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false verify transferred file by hashing after copy (resource penalty)


@b{Example}:@*
@*

@verbatim

body copy_from example
{
verify => "true";
}

@end verbatim


@b{Notes}:@*
@*

This is a highly resource intensive option, not recommended
for large file transfers.

@end table


@node create in files, delete in files, copy_from in files, files in agent promises
@subsection @code{create}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to create non-existing file


@noindent @b{Example}:@*
@*

@verbatim

files:

  "/path/plain_file"

     create =>   "true";

  "/path/dir/."
  
     create =>   "true";

@end verbatim



@noindent @b{Notes}:@*
@*


Directories are created by using the @samp{/.} to signify a directory type.
Note that, if no permissions are specified, mode 600 is chosen for a file,
and mode 755 is chosen for a directory. If you cannot accept these defaults,
you @i{should} specify permissions.



@node delete in files, depth_search in files, create in files, files in agent promises
@subsection @code{delete} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{dirlinks}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{delete}
          @code{tidy}
          @code{keep}
@end example

@noindent @b{Synopsis}: Menu option policy for dealing with symbolic links to directories during deletion


@b{Example}:@*
@*


@verbatim

body delete example
{
dirlinks => "keep";
}

@end verbatim


@b{Notes}:@*
@*

Links to directories are normally removed just like any other link or
file objects. By keeping directory links, you preserve the logical
directory structure of the file system.

@item @code{rmdirs}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to delete empty directories during recursive deletion


@b{Example}:@*
@*

@verbatim

body delete example
{
rmdirs => "true";
}

@end verbatim


@b{Notes}:@*
@*

When deleting files recursively from a base directory, should we
delete empty directories also, or keep the directory structure intact?

Note the parent directory of a search is not deleted in recursive
deletions.  In cfengine 2 there was an option to delete the parent of
the search, but now in cfengine 3, you must code a separate promise to
delete the single parent object.

@verbatim

files:

  # This will not delete the parent

  "/home/mark/tmp/testcopy" 

    delete => tidyfiles,
    file_select => zero_age, # has rmdirs true
    depth_search => recurse("inf");

  # Now delete the parent.

  "/home/mark/tmp/testcopy" 
    delete => tidyfiles;

@end verbatim

@end table


@node depth_search in files, edit_line in files, delete in files, files in agent promises
@subsection @code{depth_search} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{depth}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Maximum depth level for search


@b{Example}:@*
@*


@verbatim

body depth_search example
{
depth => "inf";
}

@end verbatim


@b{Notes}:@*
@*

This was previous called `recurse' in earlier versions of cfengine.
Note that the value @samp{inf} may be used for an unlimited value.

When searching recursively from a directory, the parent directory is
not part of the search. It is only the anchor point. To alter the parent,
a separate non-recursive promise should be made.

@item @code{exclude_dirs}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: List of regexes of directory names NOT to include in depth search


@b{Example}:@*
@*

@verbatim

body depth_search
{
# no dot directories
exclude_dirs => { "\..*" };
}

@end verbatim


@b{Notes}:@*
@*

Directory names are treated specially when searching recursively through a
file system.

@item @code{include_basedir}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false include the start/root dir of the search results


@b{Example}:@*
@*

@verbatim

body depth_search example
{
include_basedir => "true";
}

@end verbatim


@b{Notes}:@*
@*

When checking files recursively (with @code{depth_search}) the promiser
is a directory. This parameter determines whether that initial directory
should be considered part of the promise or simply a boundary which marks
the edge of the search. If true, the promiser directory will also promise
the same attributes as the files inside it.

@item @code{include_dirs}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: List of regexes of directory names to include in depth search


@b{Example}:@*
@*

@verbatim

body depth_search example
{
include_dirs => { "subdir1", "subdir2", "pattern.*" };
}

@end verbatim


@b{Notes}:@*
@*

This is the complement of @code{exclude_dirs}.

@item @code{rmdeadlinks}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false remove links that point to nowhere


@b{Example}:@*
@*

@verbatim

body depth_search example
{
rmdeadlinks => "true";
}

@end verbatim


@b{Notes}:@*
@*

If we find links that point to non-existence files, should we delete them or keep them?

@item @code{traverse_links}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false traverse symbolic links to directories (false)


@b{Example}:@*
@*

@verbatim

body depth_search example
{
traverse_links => "true";
}

@end verbatim


@b{Notes}:@*
@*

If this is true, @code{cf-agent} will treat symbolic links to
directories as if they were directories. Normally this is considered a
potentially dangerous assumption and links are not traversed.

@item @code{xdev}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false exclude directories that are on different devices


@b{Example}:@*
@*

@verbatim

body depth_search example
{
xdev => "true";
}

@end verbatim


@b{Notes}:@*
@*


@end table


@node edit_line in files, edit_xml in files, depth_search in files, files in agent promises
@subsection @code{edit_line}

@b{Type}: (ext bundle) (Separate Bundle) 


@node edit_xml in files, edit_defaults in files, edit_line in files, files in agent promises
@subsection @code{edit_xml}

@b{Type}: (ext bundle) (Separate Bundle) 


@node edit_defaults in files, file_select in files, edit_xml in files, files in agent promises
@subsection @code{edit_defaults} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{edit_backup}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{timestamp}
          @code{rotate}
@end example

@noindent @b{Synopsis}: Menu option for backup policy on edit changes


@b{Example}:@*
@*


@verbatim

body edit_defaults example
{
edit_backup => "timestamp";
}

@end verbatim


@b{Notes}:@*
@*


@item @code{empty_file_before_editing}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Baseline memory model of file to zero/empty before commencing promised edits


@b{Example}:@*
@*

@verbatim

body edit_defaults example
{
empty_file_before_editing => "true";
}

@end verbatim


@b{Notes}:@*
@*

Emptying a file before reconstructing its contents according to a
fixed recipe allows an ordered procedure to be convergent.


@item @code{max_file_size}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Do not edit files bigger than this number of bytes


@b{Example}:@*
@*

@verbatim

body edit_defaults example
{
max_file_size => "50K";
}

@end verbatim


@b{Notes}:@*
@*

A local, per-file sanity check to make sure the file editing is sensible.
If this is set to zero, the check is disabled and any size may be edited.

@end table


@node file_select in files, link_from in files, edit_defaults in files, files in agent promises
@subsection @code{file_select} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{leaf_name}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of regexes that match an acceptable name


@b{Example}:@*
@*

@verbatim

body file_select example
{
leaf_name => { "S[0-9]+[a-zA-Z]+", "K[0-9]+[a-zA-Z]+" };
file_result => "leaf_name";
}

@end verbatim


@b{Notes}:@*
@*

This pattern matches only the node name of the file, not its path.

@item @code{path_name}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: List of pathnames to match acceptable target


@b{Example}:@*
@*

@verbatim

body file_select example
{
leaf_name => { "prog.pid", "prog.log" };
path_name => { "/etc/.*", "/var/run/.*" };

file_result => "leaf_name.path_name"
}

@end verbatim


@b{Notes}:@*
@*

Path name and leaf name can be conveniently tested for separately by use
of appropriate regular expressions.

@item @code{search_mode}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[0-7augorwxst,+-]+}


@noindent @b{Synopsis}: A list of mode masks for acceptable file permissions


@b{Example}:@*
@*


@verbatim

#######################################################
#
# Searching for permissions
#
#######################################################

body common control
   {
   any::

      bundlesequence  => { 
                         "testbundle"
                         };

   version => "1.2.3";
   }

############################################

bundle agent testbundle

{
files:

  "/home/mark/tmp/testcopy" 

    file_select => by_modes,
    transformer => "/bin/echo DETECTED $(this.promiser)",
    depth_search => recurse("inf");

}

############################################

body file_select by_modes

{
search_mode => { "711" , "666" };
file_result => "mode";
}

############################################

body depth_search recurse(d)

{
depth => "$(d)";
}

@end verbatim


@b{Notes}:@*
@*

The mode may be specified in symbolic or numerical form with @samp{+}
and @samp{-} constraints.
Note that concatenation @code{ug+s} implies @code{u} OR @code{g},
 and @code{u+g,u+s} implies @code{u} AND @code{g}.

@item @code{search_size}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,inf}


@noindent @b{Synopsis}: Integer range of file sizes


@b{Example}:@*
@*


@verbatim

body file_select example
{
search_size => irange("0","20k");
file_result => "size";
}

@end verbatim


@b{Notes}:@*
@*

@item @code{search_owners}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of acceptable user names or ids for the file, or regexes to match


@b{Example}:@*
@*

@verbatim

body file_select example
{
search_owners => { "mark", "jeang", "student_.*" };
file_result => "owner";
}

@end verbatim


@b{Notes}:@*
@*

A list of regular expressions.

@item @code{search_groups}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of acceptable group names or ids for the file, or regexes to match


@b{Example}:@*
@*


@verbatim

body file_select example
{
search_groups => { "users", "special_.*" };
file_result => "group";
}

@end verbatim


@b{Notes}:@*
@*


@item @code{search_bsdflags}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+}


@noindent @b{Synopsis}: String of flags for bsd file system flags expected set


@b{Example}:@*
@*

@verbatim

body file_select xyz
{
search_bsdflags => "archived|dump";
file_result => "bsdflags";
}
@end verbatim


@b{Notes}:@*
@*

Extra BSD file system flags.

@item @code{ctime}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,2147483647}


@noindent @b{Synopsis}: Range of change times (ctime) for acceptable files


@b{Example}:@*
@*


@verbatim

body files_select example
{
ctime => irange(ago(1,0,0,0,0,0),now);
file_result => "ctime";
}

@end verbatim




@b{Notes}:@*
@*

The file's change time refers to both modification of content and attributes
such as permissions.

@item @code{mtime}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,2147483647}


@noindent @b{Synopsis}: Range of modification times (mtime) for acceptable files


@b{Example}:@*
@*

@verbatim

body files_select example
{
mtime => irange(ago(1,0,0,0,0,0),now);
file_result => "mtime";
}

@end verbatim


@b{Notes}:@*
@*

The file's modification time refers to both modification of content but not other attributes
such as permissions.


@item @code{atime}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,2147483647}


@noindent @b{Synopsis}: Range of access times (atime) for acceptable files


@b{Example}:@*
@*

@verbatim 
body file_select 

{
# files accessed in the last hour

atime     => irange(ago(0,0,0,1,0,0),now);
file_result => "atime";
}


body file_select 

{
# files accessed since 00:00 1st Jan 2000

atime     => irange(on(2000,1,1,0,0,0),now);
file_result => "atime";
}

@end verbatim


@b{Notes}:@*
@*

A range of times during which a file was accessed can be specified in
a @code{file_select} body. (Like file filters in cfengine 2.)


@item @code{exec_regex}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Matches file if this regular expression matches any full line returned by the command


@b{Example}:@*
@*

@verbatim

body file_select example
{
exec_regex => "SPECIAL_LINE: .*";
exec_program => "/path/test_program $(this.promiser)";
file_result => "exec_program.exec_regex";
}

@end verbatim


@b{Notes}:@*
@*

The regular expression must be used in conjuection with the @code{exec_program} test.
In this way the program must both return exit status 0 and its
output must match the regular expression.

@item @code{exec_program}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Execute this command on each file and match if the exit status is zero


@b{Example}:@*
@*


@verbatim

body file_select example
{
exec_program => "/path/test_program $(this.promiser)";
file_result => "exec_program";
}

@end verbatim


@b{Notes}:@*
@*

This is part of the customizable file search criteria.
If the user-defined  program returns exit status 0, the file is considered matched.

@item @code{file_types}
@b{Type}: (option list)

@noindent @b{Allowed input range}: @*
@example
          @code{plain}
          @code{reg}
          @code{symlink}
          @code{dir}
          @code{socket}
          @code{fifo}
          @code{door}
          @code{char}
          @code{block}
@end example

@noindent @b{Synopsis}: List of acceptable file types from menu choices


@b{Example}:@*
@*

@verbatim

body file_select filter
{
file_types => { "plain","symlink" };

file_result => "file_types";
}

@end verbatim


@b{Notes}:@*
@*

File types vary in details between operating systems. The main POSIX
types are provided here as menu options. 

@item @code{issymlinkto}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of regular expressions to match file objects


@b{Example}:@*
@*


@verbatim

body file_select example
{
issymlinkto => { "/etc/[^/]*", "/etc/init.d/[a-z0-9]*" };
}

@end verbatim


@b{Notes}:@*
@*

A list of regular expressions. If the file is a symbolic link which
points to files matched by one of these expressions, the file will be selected.

@item @code{file_result}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[(leaf_name|path_name|file_types|mode|size|owner|group|atime|ctime|mtime|issymlinkto|exec_regex|exec_program|bsdflags)[|&!.]*]*}


@noindent @b{Synopsis}: Logical expression combining classes defined by file search criteria


@b{Example}:@*
@*

@verbatim

body file_select any_age

{
mtime       => irange(ago(1,0,0,0,0,0),now);  
file_result => "mtime"; 
}

body file_select pdf_files_1dayold

{
mtime       => irange(ago(0,0,1,0,0,0),now);  
leaf_name   => { ".*.pdf" , ".*.fdf" };

file_result => "leaf_name&mtime";
}

@end verbatim


@b{Notes}:@*
@*

Sets the criteria for file selection outcome during file searches. The
syntax is the same as for a class expression since the file selection
is a classification of the file-search in the same way that system
classes are a classification of the abstact host-search.

Items should be from the following list:

@itemize
@item leaf_name
@item path_name
@item file_types
@item mode
@item size
@item owner
@item group
@item atime
@item ctime
@item mtime
@item issymlinkto
@item exec_regex
@item exec_program
@end itemize

@end table


@node link_from in files, move_obstructions in files, file_select in files, files in agent promises
@subsection @code{link_from} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{copy_patterns}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A set of patterns that should be copied ansd synchronized instead of linked


@b{Example}:@*
@*

@verbatim

body link_from example
{
copy_patterns =>  { "special_node1", "/path/special_node2" };
}

@end verbatim


@b{Notes}:@*
@*

During the linking of files, it is sometimes useful to buffer changes
with an actual copy, especially if the link is to an emphemeral file
system. This list of patterns matches files that arise during a
linking policy. A positive match means that the file should be copied
and updated by modification time.

@item @code{link_children}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to link all directory's children to source originals


@b{Example}:@*
@*

@verbatim

body link_from example
{
link_children => "true";
}

@end verbatim


@b{Notes}:@*
@*

If the promiser is a directory, instead of copying the children, link them to the
source.

@item @code{link_type}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{symlink}
          @code{hardlink}
          @code{relative}
          @code{absolute}
          @code{none}
@end example

@noindent @b{Synopsis}: The type of link used to alias the file


@b{Example}:@*
@*

@verbatim

body link_from example
{
link_type => "hard";
}

@end verbatim


@b{Notes}:@*
@*

What kind of link should be used to link files. Users are advised to
be wary of `hard links' (see Unix manual pages for the @samp{ln}
command). The behaviour of non-symbolic links is often precarious and
unpredictable.

@item @code{source}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The source file to which the link should point


@b{Example}:@*
@*


@verbatim

body copy_from example
{
source => "/path/to/source";
}

# or

body link_from example
{
source => "/path/to/source";
}

@end verbatim




@b{Notes}:@*
@*

For remote copies this refers to the file name on the remote server.

@item @code{when_linking_children}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{override_file}
          @code{if_no_such_file}
@end example

@noindent @b{Synopsis}: Policy for overriding existing files when linking directories of children


@b{Example}:@*
@*


@verbatim

body link_from example
{
when_linking_children => "if_no_such_file";
}

@end verbatim


@b{Notes}:@*
@*

The options refer to what happens if the directory exists already and
is already partially populated with files. If the directory being
copied from contains a file with the same name as that of a link
to be created, we must decide whether to override the existing
destination object with a link or simply omit the automatic
linkage for files that already exist. The latter case can
be used to make a copy of one directory with certain fields
overridden.

@item @code{when_no_source}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{force}
          @code{delete}
          @code{nop}
@end example

@noindent @b{Synopsis}: Behaviour when the source file to link to does not exist


@b{Example}:@*
@*

@verbatim

body link_from example
{
when_no_file => "force";
}

@end verbatim


@b{Notes}:@*
@*

If we try to create a link to a file that does not exist a link, how
should cfengine respond? The options are to force the creation to
a file that does not (yet) exist, delete any existing link, or do nothing.

@end table


@node move_obstructions in files, pathtype in files, link_from in files, files in agent promises
@subsection @code{move_obstructions}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to move obstructions to file-object creation


@noindent @b{Example}:@*
@*

@verbatim

files:

  "/tmp/testcopy" 

    copy_from    => mycopy("/tmp/source"),
    move_obstructions => "true",
    depth_search => recurse("inf");

@end verbatim


@noindent @b{Notes}:@*
@*

If we have promised to make file @file{X} a link, but it already
exists as a file, or vice-versa, or if a file is blocking the creation
of a directory etc, then normally cfengine will report an error. If
this is set, existing objects will be moved aside to allow the system
to heal without intervention. Files and directories are saved/renamed, but
symbolic links are deleted.



@node pathtype in files, perms in files, move_obstructions in files, files in agent promises
@subsection @code{pathtype}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{literal}
          @code{regex}
@end example

@noindent @b{Synopsis}: Menu option for interpreting promiser file object


@noindent @b{Example}:@*
@*

@verbatim

files:

   "/var/.*/lib"

      pathtype => "regex", #default
         perms => system;

   "/var/.*/lib"

      pathtype => "literal", 
         perms => system;

@end verbatim


@noindent @b{Notes}:@*
@*

If the keyword @code{literal} is invoked, a path looking like
a regular expression will be treated as a literal string. Thus in
the example, one case implies an iteration over all files/directories
matching the regular expression, while the other means a single
literal object with a name composed of dots and stars.



@node perms in files, rename in files, pathtype in files, files in agent promises
@subsection @code{perms} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{bsdflags}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+}


@noindent @b{Synopsis}: List of menu options for bsd file system flags to set


@b{Example}:@*
@*

@verbatim

body perms example

{
#..
bsdflags => { "uappnd","uchg","uunlnk","nodump",
              "opaque","sappnd","schg","sunlnk" };
}

@end verbatim


@b{Notes}:@*
@*

The free BSD Unices and MacOSX have additional filesystem flags which
can be set. Refer to the BSD @code{chflags} documentation for
this.

@item @code{groups}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.-]+}


@noindent @b{Synopsis}: List of acceptable groups of group ids, first is change target


@b{Example}:@*
@*


@verbatim
body perms example
{
groups => { "users", "administrators" };
}

@end verbatim


@b{Notes}:@*
@*

The first named group is the list is the defaul that will be configured if
the file does not match an element of the list.

@item @code{mode}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-7augorwxst,+-]+}


@noindent @b{Synopsis}: File permissions (like posix chmod)


@b{Example}:@*
@*

@verbatim

body perms example
{
mode => "a+rx,o+w";
}

@end verbatim


@b{Notes}:@*
@*

The mode string may be symbolic or numerical, like @code{chmod}.

@item @code{owners}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.-]+}


@noindent @b{Synopsis}: List of acceptable owners or user ids, first is change target


@b{Example}:@*
@*

@verbatim

body perms example
{
owners => { "mark", "wwwrun", "jeang" };
}

@end verbatim


@b{Notes}:@*
@*

The first user is the reference value that cfengine will set the file to if
none of the list items matches the true state of the file.

@item @code{rxdirs}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false add execute flag for directories if read flag is set


@b{Example}:@*
@*

@verbatim

body perms rxdirs
{
rxdirs => "false";
}

@end verbatim


@b{Notes}:@*
@*

Default behaviour is to set the @samp{x} flag on directories
automatically if the @samp{r} flag is specified when specifying
multiple files in a single promise.

@end table


@node rename in files, repository in files, perms in files, files in agent promises
@subsection @code{rename} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{disable}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false automatically rename and remove permissions


@b{Example}:@*
@*

@verbatim

body rename example
{
disable => "true"; 
disable_suffix => ".nuked";
}

@end verbatim


@b{Notes}:@*
@*

Disabling a file means making is impotent in the context in which it
has an effect. For executables this means preventing execution, for an
information file it means making the file unreadable.

@item @code{disable_mode}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-7augorwxst,+-]+}


@noindent @b{Synopsis}: The permissions to set when a file is disabled


@b{Example}:@*
@*


@verbatim

body rename example
{
disable_mode => "0600"; 
}

@end verbatim



@b{Notes}:@*
@*

To disable an executable it is not enough to rename it, you should also remove the
executable flag.


@item @code{disable_suffix}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The suffix to add to files when disabling (.cfdisabled)


@b{Example}:@*
@*


@verbatim

body rename example
{
disable => "true"; 
disable_suffix => ".nuked";
}

@end verbatim



@b{Notes}:@*
@*

To make disabled files in a particular manner, use this string suffix.
The default value is @file{.cf-disabled}.

@item @code{newname}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The desired name for the current file


@b{Example}:@*
@*

@verbatim

body rename example(s)
{
newname => "$(s)";
}

@end verbatim


@b{Notes}:@*
@*

@item @code{rotate}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99}


@noindent @b{Synopsis}: Maximum number of file rotations to keep


@b{Example}:@*
@*

@verbatim

body rename example
{
rotate => "4";
}

@end verbatim


@b{Notes}:@*
@*

Used for log rotation. 

@end table


@node repository in files, touch in files, rename in files, files in agent promises
@subsection @code{repository}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Name of a repository for versioning


@noindent @b{Example}:@*
@*


@verbatim

files:

 "/path/file"

   copy_from => source,
   repository => "/var/cfengine/repository";

@end verbatim


@noindent @b{Notes}:@*
@*

A local repository for this object, overrides the default.



@node touch in files, transformer in files, repository in files, files in agent promises
@subsection @code{touch}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether to touch time stamps on file


@noindent @b{Example}:@*
@*

@verbatim

files:

 "/path/file"

   touch => "true";

@end verbatim


@noindent @b{Notes}:@*
@*





@node transformer in files,  , touch in files, files in agent promises
@subsection @code{transformer}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command (with full path) used to transform current file (no shell wrapper used)


@noindent @b{Example}:@*
@*

@verbatim

 "/home/mark/tmp/testcopy"

    file_select => pdf_files,
    transformer => "/usr/bin/gzip $(this.promiser)",
    depth_search => recurse("inf");

@end verbatim


@noindent @b{Notes}:@*
@*

A command to execute on finding a file.



@node delete_lines in edit_line promises, insert_lines in edit_line promises, files in agent promises, Bundles for agent
@section @code{delete_lines} promises in @samp{edit_line}

@*

This promise assures that certain lines matching regular expression
patterns exactly will not be present in a text file. If the lines are
found, the default promise is to remove them.

@*

@verbatim

bundle edit_line example
  {
  delete_lines:

    "olduser.*";

  }

@end verbatim

@*



@menu
* delete_select in delete_lines::  
* not_matching in delete_lines::  
@end menu

@node delete_select in delete_lines, not_matching in delete_lines, delete_lines in edit_line promises, delete_lines in edit_line promises
@subsection @code{delete_select} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{delete_if_startwith_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if it starts with a string in the list


@b{Example}:@*
@*

@verbatim

body delete_select example(s)
{
delete_if_startwith_from_list => { @(s) };
}

@end verbatim


@b{Notes}:@*
@*

Delete lines from a file if they begin with the sub-strings listed.

@item @code{delete_if_not_startwith_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if it DOES NOT start with a string in the list


@b{Example}:@*
@*


@verbatim

body delete_select example(s)
{
delete_if_not_startwith_from_list => { @(s) };
}

@end verbatim


@b{Notes}:@*
@*

Delete lines from a file unless they start with the sub-strings in the list given.

@item @code{delete_if_match_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if it fully matches a regex in the list


@b{Example}:@*
@*

@verbatim

body delete_select example(s)
{
delete_if_match_from_list => { @(s) };
}

@end verbatim


@b{Notes}:@*
@*

Delete lines from a file if they completely match the regular expressions listed.


@item @code{delete_if_not_match_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if it DOES NOT fully match a regex in the list


@b{Example}:@*
@*

@verbatim

body delete_select example(s)
{
delete_if_not_match_from_list => { @(s) };
}

@end verbatim


@b{Notes}:@*
@*

Delete lines from a file unless they fully match regular expressions
in the list.

@item @code{delete_if_contains_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if a regex in the list match a line fragment


@b{Example}:@*
@*

@verbatim

body delete_select example(s)
{
delete_if_contains_from_list => { @(s) };
}

@end verbatim


@b{Notes}:@*
@*


Delete lines from a file if they contain the sub-strings listed.

@item @code{delete_if_not_contains_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Delete line if a regex in the list DOES NOT match a line fragment


@b{Example}:@*
@*

@verbatim

body delete_select discard(s)
{
delete_if_not_contains_from_list => { "substring1", "substring2" };
}

@end verbatim


@b{Notes}:@*
@*

Delete lines from the file which do not contain the sub-strings listed.

@end table


@node not_matching in delete_lines,  , delete_select in delete_lines, delete_lines in edit_line promises
@subsection @code{not_matching}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false negate match criterion


@noindent @b{Example}:@*
@*


@verbatim
delete_lines:

  # edit /etc/passwd

  "mark.*|root.*" not_matching => "true";

@end verbatim



@noindent @b{Notes}:@*
@*


The negation of an expression (for convenience).




@node insert_lines in edit_line promises, field_edits in edit_line promises, delete_lines in edit_line promises, Bundles for agent
@section @code{insert_lines} promises in @samp{edit_line}

@*

This promise is part of the line-editing model. It inserts lines into
the file at a specified location. The location is determined by
body-attributes.  The promise object referred to can be a literal line
of a file-reference from which to read lines.

@cartouche
@smallexample

 insert_lines:

   "@var{literal line or file reference}"

      location => @var{location_body},
      ...;

@end smallexample
@end cartouche


@*

@verbatim

body common control

{
any::

  bundlesequence  => {
                     example
                     };   
}

#######################################################

bundle agent example

{
files:

  "/var/spool/cron/crontabs/root"

     edit_line => addline;
}

#######################################################
# For the library
#######################################################

bundle edit_line addline

{
insert_lines:

 "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F";

}

@end verbatim

@*

By parameterizing the editing bundle, one can make generic and reusable editing bundles.

Note, when inserting multiple lines anchored to a particular place in
a file, be careful with your intuition.  If your intention is to
insert a set of lines in a given order after a marker, then the
following is incorrect:

@verbatim

bundle edit_lines x
{
insert_lines:

  "line one" location => myloc;
  "line two" location => myloc;
}

body location myloc

{
select_line_matching => "^# Right here.*";
before_after => "after";
}

@end verbatim
This will reverse the order of the lines and will not converge, since
the anchoring after the marker applies independently for each new
line. This is not a bug, but an error of logic.

What was probably intended was to add multiple ordered lines after the marker,
which should be a single correlated promise.

@verbatim

bundle edit_lines x
{
insert_lines:
 
 "line one$(const.n)line two" location => myloc;

}

@end verbatim
Or:
@verbatim

bundle edit_lines x
{
insert_lines:
 
  "line one
line two" location => myloc;

}

@end verbatim




@menu
* expand_scalars in insert_lines::  
* insert_type in insert_lines::  
* insert_select in insert_lines::  
* location in insert_lines::    
@end menu

@node expand_scalars in insert_lines, insert_type in insert_lines, insert_lines in edit_line promises, insert_lines in edit_line promises
@subsection @code{expand_scalars}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: Expand any unexpanded variables


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
files:

  "/home/mark/tmp/file_based_on_template"

       create    => "true",
       edit_line => ExpandMeFrom("/tmp/source_template");


}

########################################################

bundle edit_line ExpandMeFrom(template)
{
insert_lines:

   "$(template)"

          insert_type => "file",
       expand_scalars => "true";
}

@end verbatim


@noindent @b{Notes}:@*
@*

A way of incorporating templates with variable expansion into file
operations. Variables should be named and scoped appropriately for the
bundle in which this promise is made.

In cfengine 2 @code{editfiles} this was called @samp{ExpandVariables}.



@node insert_type in insert_lines, insert_select in insert_lines, expand_scalars in insert_lines, insert_lines in edit_line promises
@subsection @code{insert_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{literal}
          @code{string}
          @code{file}
@end example

@noindent @b{Synopsis}: Type of object the promiser string refers to (default literal)


@noindent @b{Example}:@*
@*

@verbatim
 insert_lines:

     "test lines"

       insert_type => "file";

@end verbatim


@noindent @b{Notes}:@*
@*

The default is to treat the promiser as a literal string. This is used
to tell cfengine that the string is non-literal and should be
interpreted as a filename from which to import lines.



@node insert_select in insert_lines, location in insert_lines, insert_type in insert_lines, insert_lines in edit_line promises
@subsection @code{insert_select} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{insert_if_startwith_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if it starts with a string in the list


@b{Example}:@*
@*


@verbatim

body insert_select example
{
insert_if_startwith_from_list => { "find_me_1", "find_me_2" };
}

@end verbatim



@b{Notes}:@*
@*

The list contains literal strings to search for in an secondary file
(not the main file being edited). If the string is found as the first
characters (at the start) of a line in the file, that line from the
secondary file will be inserted at the present location in the primary
file.

@item @code{insert_if_not_startwith_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if it DOES NOT start with a string in the list


@b{Example}:@*
@*


@verbatim

body insert_select example
{
insert_if_not_startwith_from_list => { "find_me_1", "find_me_2" };
}

@end verbatim



@b{Notes}:@*
@*

The complement of @code{insert_if_startwith_from_list}.


@item @code{insert_if_match_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if it fully matches a regex in the list


@b{Example}:@*
@*


@verbatim

body insert_select example
{
insert_if_match_from_list => { ".*find_.*_1.*", ".*find_.*_2.*" };
}

@end verbatim



@b{Notes}:@*
@*

The list contains regular expressions to search for in an secondary file (not the
main file being edited). If the regex matches a complete line of the file,
that line from the secondary file will be inserted at the present location
in the primary file.


@item @code{insert_if_not_match_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if it DOES NOT fully match a regex in the list


@b{Example}:@*
@*


@verbatim

body insert_select example
{
insert_if_not_match_from_list => { ".*find_.*_1.*", ".*find_.*_2.*" };
}

@end verbatim




@b{Notes}:@*
@*

The complement of @code{insert_if_match_from_list}.

@item @code{insert_if_contains_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if a regex in the list match a line fragment


@b{Example}:@*
@*

@verbatim

body insert_select example
{
insert_if_contains_from_list => { "find_me_1", "find_me_2" };
}

@end verbatim


@b{Notes}:@*
@*

The list contains literal strings to search for in an secondary file (not the
main file being edited). If the string is found in a line of the file,
that line from the secondary file will be inserted at the present location
in the primary file.

@item @code{insert_if_not_contains_from_list}
@b{Type}: slist

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Insert line if a regex in the list DOES NOT match a line fragment


@b{Example}:@*
@*


@verbatim

body insert_select example
{
insert_if_not_contains_from_list => { "find_me_1", "find_me_2" };
}

@end verbatim



@b{Notes}:@*
@*

The complement of @code{insert_if_contains_from_list}.

@end table


@node location in insert_lines,  , insert_select in insert_lines, insert_lines in edit_line promises
@subsection @code{location} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{before_after}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{before}
          @code{after}
@end example

@noindent @b{Synopsis}: Menu option, point cursor before of after matched line


@b{Example}:@*
@*

@verbatim

body location append

{
#...
before_after => "before";
}

@end verbatim


@b{Notes}:@*
@*

Determines whether an edit will occur before or after the currently
matched line.

@item @code{first_last}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{first}
          @code{last}
@end example

@noindent @b{Synopsis}: Menu option, choose first or last occurrence of match in file


@b{Example}:@*
@*


@verbatim

body location example
{
first_last => "last";
}

@end verbatim


@b{Notes}:@*
@*

In multiple matches, decide whether the first or last occurrence of
the matching pattern in the case affected by the change. In principle
this could be generalized to more cases but this seems like a fragile
quality to evaluate, and only these two cases are deemed of
reproducible significance.

@item @code{select_line_matching}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Regular expression for matching file line location


@b{Example}:@*
@*

@verbatim

body match_value example
{
select_line_matching => "^Expression match.* whole line$";
}

@end verbatim


@b{Notes}:@*
@*

The @samp{^$} are not necessary, just remember that the expression must match
a whole line, not a fragment within a line.

@end table


@node field_edits in edit_line promises, replace_patterns in edit_line promises, insert_lines in edit_line promises, Bundles for agent
@section @code{field_edits} promises in @samp{edit_line}

@*

Certain types of text file (e.g. the @file{passwd} and @file{group}
files in Unix) are tabular in nature, with field separators
(e.g. @samp{:} or @samp{,}). This promise assumes a parameterizable model
for editing the fields of such files, using a regular expression to
separate major fields and a character to separate sub-fields. First
you match the line with a regular expression, then a
@code{field_edits} body describes the separators for fields and one
level of sub-fields, along with policies for editing these fields, ordering
the items within them etc.

@cartouche
@smallexample

field_edits:

    "@var{regex matching line}"

              edit_field => @var{body};

@end smallexample
@end cartouche


@*

@verbatim

bundle agent example

{
vars:

 "userset" slist => { "one-x", "two-x", "three-x" };

files:

  "/tmp/passwd"

       create    => "true",
       edit_line => SetUserParam("mark","6","/set/this/shell");

  "/tmp/group"

       create    => "true",
       edit_line => AppendUserParam("root","4","@(userset)");
}

########################################################

bundle edit_line SetUserParam(user,field,val)
  {
  field_edits:

   "$(user).*"

      # Set field of the file to parameter

      edit_field => col(":","$(field)","$(val)","set");
  }

########################################################

bundle edit_line AppendUserParam(user,field,allusers)
  {
  vars:

    "val" slist => { @(allusers) };

  field_edits:

   "$(user).*"

      # Set field of the file to parameter

      edit_field => col(":","$(field)","$(val)","alphanum");

  }

########################################
# Bodies
########################################

body edit_field col(split,col,newval,method)

{
field_separator => "$(split)";
select_field    => "$(col)";
value_separator  => ",";
field_value     => "$(newval)";
field_operation => "$(method)";
extend_fields => "true";
}

@end verbatim

@*

Field editing allows us to edit tabular files in a unique way, adding
and removing data from addressable fields. The @file{passwd} and
@file{group} files are classic examples of tabular files, but there
are many ways to use this feature, e.g. edit a string

@verbatim

VARIABLE="one two three"

@end verbatim

@noindent View this line as a tabular line separated by @samp{"} and
with sub-separator given by the space.




@menu
* edit_field in field_edits::   
@end menu

@node edit_field in field_edits,  , field_edits in edit_line promises, field_edits in edit_line promises
@subsection @code{edit_field} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{allow_blank_fields}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false allow blank fields in a line (do not purge)


@b{Example}:@*
@*

@verbatim

body edit_field example
{
# ...
allow_blank_fields => "true";
}

@end verbatim


@b{Notes}:@*
@*


When editing a file using the field or column model, blank fields, especially
at the start and end are generally discarded. If this is set to true, cfengine
will retain the blank fields and print the appropriate number of field separators. 



@item @code{extend_fields}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false add new fields at end of line if necessary to complete edit


@b{Example}:@*
@*


@verbatim

body edit_field example
{
extend_fields => "true";
}

@end verbatim


@b{Notes}:@*
@*

If a user specifies a field that does not exist, because there are not
so many fields, this allows the number of fields to be extended.
Without this setting, cfengine will issue an error if a non-existent field
is referenced.
Blank fields in a tabular file can be eliminated or kept depending
in this setting. If in doubt, set this to true.


@item @code{field_operation}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{prepend}
          @code{append}
          @code{alphanum}
          @code{delete}
          @code{set}
@end example

@noindent @b{Synopsis}: Menu option policy for editing subfields


@b{Example}:@*
@*


@verbatim

body edit_field example
{
field_operation => "append";
}

@end verbatim


@b{Notes}:@*
@*

The method by which to edit a field in multi-field/column editing
of tabular files.

@item @code{field_separator}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: The regular expression used to separate fields in a line


@b{Example}:@*
@*

@verbatim

body edit_field example
{
field_separator => ":";
}

@end verbatim


@b{Notes}:@*
@*

Most tabular files are separated by simple characters, but by allowing
a general regular expression one can make creative use of this model to
edit all kinds of line-based text files.

@item @code{field_value}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Set field value to a fixed value


@b{Example}:@*
@*

@verbatim

body edit_field example(s)
{
field_value => "$(s)";
}

@end verbatim


@b{Notes}:@*
@*

Set a field to a constant value, e.g. reset the value to a constant
default, empty the field, or set it fixed list.

@item @code{select_field}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer index of the field required 1..n


@b{Example}:@*
@*

@verbatim

body field_edits example
{
select_field => "5";
}
@end verbatim


@b{Notes}:@*
@*

Numering starts from 1 not from 0.

@item @code{value_separator}
@b{Type}: string

@noindent @b{Allowed input range}: @code{^.$}


@noindent @b{Synopsis}: Character separator for subfields inside the selected field


@b{Example}:@*
@*

@verbatim

body field_edit example
{
value_separator => ",";
}

@end verbatim


@b{Notes}:@*
@*

For example, elements in the group file are separated by @samp{:},
but the lists of users in these fields are separated by @samp{,}.

@end table


@node replace_patterns in edit_line promises, interfaces in agent promises, field_edits in edit_line promises, Bundles for agent
@section @code{replace_patterns} promises in @samp{edit_line}

@*

This promise refers to arbitrary text patterns in a file.
The pattern is expressed as a regular expression and must be
compatible with the default model for regular expressions on
your system. The default model is PCRE (Perl Compatible Regular
Expressions) if available.

@cartouche
@smallexample

  replace_patterns:

   "@var{search pattern}"

      replace_with => @var{replace_body},
      ...;

@end smallexample
@end cartouche


@*

@verbatim

bundle edit_line upgrade_cfexecd
  {
  replace_patterns:

    "cfexecd" replace_with => With("cf-execd");
  }

########################################

body replace_with With(x)

{
replace_value => "$(x)";
occurrences => "all";
}

@end verbatim

@*

This is a straightforward search and replace function. In this case
only for line editing the regular expression may match a line fragment
-- it need not match the entire line.



@menu
* replace_with in replace_patterns::  
@end menu

@node replace_with in replace_patterns,  , replace_patterns in edit_line promises, replace_patterns in edit_line promises
@subsection @code{replace_with} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{occurrences}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{all}
          @code{first}
@end example

@noindent @b{Synopsis}: Menu option to replace all occurrences or just first (NB the latter is non-convergent)


@b{Example}:@*
@*

@verbatim

body replace_with example
{
occurrences => "first";
}

@end verbatim


@b{Notes}:@*
@*

A policy for string replacement.

@item @code{replace_value}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Value used to replace regular expression matches in search


@b{Example}:@*
@*

@verbatim

body replace_with example(s)
{
replace_value => "$(s)";
}

@end verbatim


@b{Notes}:@*
@*


@end table


@node interfaces in agent promises, methods in agent promises, replace_patterns in edit_line promises, Bundles for agent
@section @code{interfaces} promises in @samp{agent}

@*

Interfaces promises describe the configurable aspects relating to
network interfaces. Most workstations and servers have only a single
network interface, but routers and multi-homed hosts often have
multiple interfaces. Interface promises include attributes such as the
IP address identity, assumed netmask and routing policy in the case of
multi-homed hosts. For virtual machines and hosts, the list of
interfaces can be quite large.

@cartouche
@smallexample

 interfaces:

   "@var{interface name}"

     tcp_ip => @var{tcp_ip_body},
     ...;

@end smallexample
@end cartouche

@*

@verbatim

Fill me in (/home/mark/LapTop/CfengineProjects/CompanyDocuments/trunk/Cfengine3Reference/promise_interfaces_example.texinfo)
""
@end verbatim

@*

@verbatim

Fill me in (/home/mark/LapTop/CfengineProjects/CompanyDocuments/trunk/Cfengine3Reference/promise_interfaces_notes.texinfo)
""
@end verbatim



@menu
* tcp_ip in interfaces::        
@end menu

@node tcp_ip in interfaces,  , interfaces in agent promises, interfaces in agent promises
@subsection @code{tcp_ip} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{ipv4_address}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-9.]+/[0-4]+}


@noindent @b{Synopsis}: IPv4 address for the interface


@b{Example}:@*
@*

@verbatim

body tcp_ip example
{
ipv4_address => "123.456.789.001";
}

@end verbatim


@b{Notes}:@*
@*

The address will be checked and if necessary set. Today few hosts will
be managed in this way: address management will be handled by other services
like DHCP.

@item @code{ipv4_netmask}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-9.]+/[0-4]+}


@noindent @b{Synopsis}: Netmask for the interface


@b{Example}:@*
@*


@verbatim

body tcp_ip example
{
ipv4_netmask => "255.255.254.0";
}

@end verbatim



@b{Notes}:@*
@*

In many cases the CIDR form of address will show the netmask as @samp{/23}, but
this offers and `old style' alternative.

@item @code{ipv6_address}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-9a-fA-F:]+/[0-9]+}


@noindent @b{Synopsis}: IPv6 address for the interface


@b{Example}:@*
@*

@verbatim

body tcp_ip example
{
ipv6_address => "2001:700:700:3:20f:1fff:fe92:2cd3/64";
}

@end verbatim


@b{Notes}:@*
@*



@end table


@node methods in agent promises, packages in agent promises, interfaces in agent promises, Bundles for agent
@section @code{methods} promises in @samp{agent}

@*

Methods are compound promises that refer to whole bundles of promises.
Methods may be parameterized. Methods promises are written in a form
that is ready for future development. The promiser object is an
abstract identifier that refers to a collection (or pattern) of lower
level objects that are affected by the promise-bundle. Since the use
of these identifiers is for the future, you can simply use any string
here for the time being.

@cartouche
@smallexample

 methods:

   "any" 

      usebundle => @var{method_id}("parameter",...);

@end smallexample
@end cartouche

Methods are useful for encapsulating repeatedly used configuration
issues and iterating over parameters.

In cfengine 2 methods referred to separate sub-programs executed
as separate processes. Methods are now implemented as bundles
that are run inline. 

@*

@verbatim


bundle agent example
{
vars:

 "userlist" slist => { "mark", "jeang", "jonhenrik", "thomas", "eben" };

methods:

 "any" usebundle => subtest("$(userlist)");

}

###########################################

bundle agent subtest(user)

{
commands:

 "/bin/echo Fix $(user)";

reports:

 linux::

  "Finished doing stuff for $(user)";
}


@end verbatim

@*

Methods offer powerful ways to encapsulate multiple issues pertaining
to a set of parameters.



@menu
* usebundle in methods::        
@end menu

@node usebundle in methods,  , methods in agent promises, methods in agent promises
@subsection @code{usebundle}

@b{Type}: (ext bundle) (Separate Bundle) 


@node packages in agent promises, processes in agent promises, methods in agent promises, Bundles for agent
@section @code{packages} promises in @samp{agent}

@*

@cartouche
@verbatim

 vars:

  "match_package" slist => { 
                           "apache2", 
                           "apache2-mod_php5",
                           "apache2-prefork",
                           "php5" 
                           };
 packages:

    "$(match_package)"

         package_policy => "add",
         package_method => yum;

@end verbatim
@end cartouche


Software packaging is a core paradigm in operating system release
management today, and cfengine supports a generic approach to
integration with native operating support for packaging.  Package
promises allow cfengine to make promises the state of software
packages @i{conditionally}, given the assumption that a native package
manager will perform the actual manipulations. Since no agent can make
unconditional promises about another, this is the best that can be
achieved. 

Packages are treated as black-boxes with three labels: 

@itemize @bullet
@item A package name.
@item A version string.
@item An architecture name.
@end itemize

Package managers are treated as black boxes that may support some or all of the
following promise types:

@itemize @bullet
@item List installed packages
@item Add packages
@item Delete packages
@item Reinstall (repair) packages
@item Upgrade packages
@item Patch packages
@item Verify packages
@end itemize

If these services are promised by a package manager, @code{cf-agent}
promises to use the service and encapsulate it within the overall
cfengine framework.

@b{Domain knowledge}

Cfengine does not maintain operating system specific expert knowledge
internally, rather it uses a generic model for dealing with promises about
packages (which depend on the behaviour of an external package manager).
The approach is to define package system details in body-constraints that
can be written once and for all, for each package system.

Package promises are like @code{commands} promises in the sense that
cfengine promises nothing about the outcome of executing a
command. All it can promise is to interface with it, starting it and
using the results in good faith. Packages are basically `outsourced',
to invoke IT parlance.

The possibility of a cfengine package format that enables more guaranteeable
behaviour for special purposes has not been excluded for the future,
but in any case @code{cf-agent} must support native package formats
used by operating system maintainers as these are a core part of modern
operating systems.

@b{Behaviour}

A package promise consists of a name, a version and an architecture, @i{(n,v,a)},
and behaviour to be promised about packages that match criteria based on these.
The components @i{(n,v,a)} can be determined in one of two different ways:

@itemize
@item They may be specified independently, e.g.

@verbatim
packages:

  "mypackage"

     package_policy => "add",
     package_method => rpm,
     package_select => ">=",
     package_architectures => { "x86_64", "i586" },
     package_version => "1.2.3";

@end verbatim

@item They may be extracted from a package identifier or filename, using pattern matching, e.g.:

@verbatim
 package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s|]+).*";
 package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s|]+).*";
 package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
@end verbatim

@end itemize

When scanning a list of installed packages different managers present the information
@i{(n,v,a)} in quite different forms and pattern extraction is necessary. When making a
promise about a specific package, the cfengine user may choose one or the other model.


@b{Smart and dumb package systems}

Package managers vary enormously in their capabilities and in the
kinds of promises they make. There are broadly two types

@itemize
@item Smart package systems tha resolve dependencies and require only a symbolic package name.
@item Dumb package managers that do not resolve dependencies and need filename input.
@end itemize



Normal ordering for packages is the following:

@itemize @bullet
@item Delete
@item Add
@item Upgrade
@item Patch
@end itemize


@b{Promise repair logic}

We can discuss package promise repair in the following table.

@image{package-behaviour,14cm,,Promise repair logic for packages.,png}








@*

@verbatim

bundle agent packages
{
vars:

 # Test the simplest case -- leave everything to the yum smart manager

 "match_package" slist => { 
                          "apache2", 
                          "apache2-mod_php5",
                          "apache2-prefork",
                          "php5" 
                          };
packages:

  "$(match_package)"

     package_policy => "add",
     package_method => yum;

}

@end verbatim


@*

Packages promises can be very simple if the package manager is of the
smart variety that handles details for you. If you need to specify
architecture and version numbers of packages, this adds some
complexity, but the options are flexible and designed for maximal
adaptability.

@noindent @b{Patching}

Some package systems also support the idea of `patches'. These might
be formally different objects to packages. A patch might contain
material for several packages and be numbered differently.
When you select patching-policy the package name (promiser) can be
a regular expression that will match possible patch names, otherwise
identifying specific patches can be cumbersome.

Note that patching is a subtle business. There is no simple way using
the patch settings to install `all new system patches'. Here's why:

If we specify the name of a patch, then cfengine will try to see if it
exists and/or is installed. If it exists in the pending list, it will
be installed.  If it exists in the installed list it will not be
installed. Now consider the pattern @samp{.*}. This will match any
installed package, so cfengine will assume the relevant patch has been
installed already.  On the other hand, the pattern @samp{no match}
will not match an installed patch, but it will not match a named patch
either.

Some systems provide a command to do this, which can be specified
without specific patch arguments. If so, that command can be called
periodically under @code{commands}. The main purposes of patching
body items are:

@itemize
@item To install specific named patches in a controlled manner.
@item To generate reports of available and installed patches during
system reporting.
@end itemize

@noindent @b{Installers without package/patch arguments}

Cfengine supports the syntax @samp{$} at the end of a command to mean
that no package name arguments should be used or appended after the
dollar.  This is because some commands require a list of packages,
while others require an empty list. The default behaviour is to try to
append the name of one or more packages to the command, depending on 
whether the policy is for individual or bulk installation.



@menu
* package_architectures in packages::  
* package_method in packages::  
* package_policy in packages::  
* package_select in packages::  
* package_version in packages::  
@end menu

@node package_architectures in packages, package_method in packages, packages in agent promises, packages in agent promises
@subsection @code{package_architectures}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Select the architecture for package selection


@noindent @b{Example}:@*
@*

@verbatim
packages:

  "$(exact_package)"

     package_policy => "add",
     package_method => rpm,
     package_architectures => { "x86_64" };

@end verbatim


@noindent @b{Notes}:@*
@*

It is possible to specify a list of packages of different architectures if it is desirable to
install multiple architectures on the host. If no value is specified, cfengine makes no promise
about the result; the package manager's behaviour prevails.



@node package_method in packages, package_policy in packages, package_architectures in packages, packages in agent promises
@subsection @code{package_method} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{package_add_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to install a package to the system


@b{Example}:@*
@*

@verbatim

body package_method rpm
{
package_add_command => "/bin echo /bin/rpm -i ";
}

@end verbatim


@b{Notes}:@*
@*

This command should install a package when appended with the package referernce id, formed
using the @code{package_name_convention}, using the model of (name,version,architecture).

@item @code{package_arch_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package architecture string


@b{Example}:@*
@*

@verbatim

body package_method rpm

{
package_list_arch_regex    => "[^.]+\.([^.]+)";
}

@end verbatim


@b{Notes}:@*
@*

This is for use when extracting architecture from the name of the
promiser, i.e. when the architecture is not specified using the
@code{package_architectures} list.  It is a regular expression that
contains exactly one back reference (parenthesis) which marks the
location in the @i{promiser} at which the architecture is
specified. If no architecture is specified for the given package
manager, then do not define this.

@item @code{package_changes}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{individual}
          @code{bulk}
          @code{bulk_no_names}
@end example

@noindent @b{Synopsis}: Menu option - whether to group packages into a single aggregate command


@b{Example}:@*
@*

@verbatim

body package_method rpm

{
package_changes => "bulk";
}

@end verbatim


@b{Notes}:@*
@*
This indicate whether the package manager is capable of handling
package operations in bulk, i.e. with by given multiple arguments. If
this is set to @samp{bulk} then multiple arguments will be passed to
the package commands. If set to @samp{individual} packages will be
handled one by one. This might add a significant overhead to the
operations, and also affect the ability of the operating system's
package manager to handle dependencies.

@item @code{package_delete_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to remove a package from the system


@b{Example}:@*
@*

@verbatim

body package_method rpm

{
package_delete_command => "/bin/rpm -e --nodeps";
}

@end verbatim


@b{Notes}:@*
@*

The command that deletes a package from the system when appended with the package reference
identifier specified by @code{package_name_convention}.

@item @code{package_file_repositories}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: A list of machine-local directories to search for packages


@b{Example}:@*
@*

@verbatim

body package_method filebased
{
file_repositories => { "/package/repos1", "/packages/repos2" };
}

@end verbatim


@b{Notes}:@*
@*

If specified, cfengine will assume that the package installation occurs by filename and will
search the named paths for a package matching the pattern @code{package_name_convention}.
If found the name will be prefixed to the package name in the package commands.

@item @code{package_installed_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression which matches packages that are already installed


@b{Example}:@*
@*

@verbatim

body package_method yum
{
package_installed_regex => ".*installed.*";
}

@end verbatim


@b{Notes}:@*
@*

This regular expression should match lines in the output of the list command that are
actually installed packages. If all the lines match then it can be set of @samp{.*},
however most package systems output prefix lines and a variety of human padding that
needs to be ignored.

@item @code{package_list_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to obtain a list of installed packages


@b{Example}:@*
@*

@verbatim

body package_method rpm

{
package_list_command => "/bin/rpm -qa --queryformat \"%{name} %{version}-%{release}\n\"";
}

@end verbatim


@b{Notes}:@*
@*

This command should provide a complete list of the packages installed on the system.
It might also list packages that are not installed. Those should be filtered out using
the @code{package_installed_regex}.

@item @code{package_list_version_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package version string


@b{Example}:@*
@*

@verbatim
body package_method rpm

{
package_list_version_regex => "[^\s]+ ([^.]+).*";
}

@end verbatim


@b{Notes}:@*
@*

This regular expression should containe exactly one back-reference (parenthesis)
that marks the version string of packages listed as installed.

@item @code{package_list_name_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package name string


@b{Example}:@*
@*

@verbatim

body package_method rpm

{
package_list_name_regex    => "([^\s]+).*";
}

@end verbatim


@b{Notes}:@*
@*

This regular expression should contain a single back reference (parenthesis)
that marks the name of the package from the package listing.

@item @code{package_list_arch_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package architecture string


@b{Example}:@*
@*

@verbatim

body package_method rpm
{
package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
}

@end verbatim


@b{Notes}:@*
@*


A regular expression that contains exactly one back reference
(parenthesis) which marks the location in the listed package at which the
architecture is specified. If no architecture is specified for the
given package manager, then do not define this.

@item @code{package_name_convention}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: This is how the package manager expects the file to be referred to, e.g. $(name).$(arch)


@b{Example}:@*
@*

@verbatim
body package_method rpm

{
package_name_convention => "$(name).$(arch).rpm";
}

@end verbatim


@b{Notes}:@*
@*

This sets the pattern for naming the package in the way expected by
the package manager. Three special variables are defined from the
extracted data, in a private context for use: @samp{$(name)},
@samp{$(version)} and @samp{$(arch)}.

@item @code{package_name_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package name string


@b{Example}:@*
@*

@verbatim

body package_method rpm
{
package_name_regex => "([^\s]).*";
}

@end verbatim


@b{Notes}:@*
@*

This regular expression is only used when the @i{promiser} contains
not only the name of the package, but its version and archiecture
also. In that case, this expression should contain a single back-reference
(parenthesis) to extract the name of the package from the string.

@item @code{package_noverify_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression to match verification failure output


@b{Example}:@*
@*

@verbatim
body package_method xyz

{
# package_noverify_regex => ".*problem.*";

package_noverify_regex => ".*[^\s].*";   # some non-zero output
}

@end verbatim


@b{Notes}:@*
@*

A regular expression to match output from a package verification command. If the
ourput string matches this expression, the package is deemed broken.

@item @code{package_noverify_returncode}
@b{Type}: int

@noindent @b{Allowed input range}: @code{-99999999999,9999999999}


@noindent @b{Synopsis}: Integer return code indicating package verification failure


@b{Example}:@*
@*

@verbatim
body package_method xyz
{
package_noverify_returncode => "-1";
}
@end verbatim


@b{Notes}:@*
@*

For use if a package verification command uses the return code as the signal
for a failed package verification.

@item @code{package_patch_arch_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract update architecture string


@b{Example}:@*
@*

@verbatim

body package_method zypper
{
package_patch_arch_regex => "";
}

@end verbatim


@b{Notes}:@*
@*

A few package managers keep a separate notion of patches, as opposed to package updates.
OpenSuSE, for example, is one of these. This provide an analogous command struct to the
packages for patch updates.

@item @code{package_patch_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to update to the latest patch release of an installed package


@b{Example}:@*
@*

@verbatim
body package_method zypper

{
package_patch_command => "/usr/bin/zypper -non-interactive patch";
}
@end verbatim


@b{Notes}:@*
@*

If the package manager supports patching, this command should patch a
named package. If only patching of all packages is supported then consider running
that as a batch operation in @code{commands}. Alternatively one can end the command
string with a @samp{$} symbol, which cfengine will interpret as an instruction to
not append package names.

@item @code{package_patch_installed_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression which matches packages that are already installed


@b{Example}:@*
@*

@verbatim

body package_method zypper
{
package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
}

@end verbatim


@b{Notes}:@*
@*

A few package managers keep a separate notion of patches, as opposed to package updates.
OpenSuSE, for example, is one of these. This provide an analogous command struct to the
packages for patch updates.

@item @code{package_patch_list_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to obtain a list of available patches or updates


@b{Example}:@*
@*

@verbatim

 package_patch_list_command => "/usr/bin/zypper patches";

@end verbatim


@b{Notes}:@*
@*

This command, if it exists at all, is presumed to generate a list of
available patches in a format analogous to (but not necessarily the
same as) the package-list command, of patches that are available
on the system. Patches might formally be available in the packagae
manager's view, but if they have already been installed, cfengine will
ignore them.

@item @code{package_patch_name_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract update name string


@b{Example}:@*
@*

@verbatim

body package_method zypper
{
package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
}
@end verbatim


@b{Notes}:@*
@*

A few package managers keep a separate notion of patches, as opposed to package updates.
OpenSuSE, for example, is one of these. This provide an analogous command struct to the
packages for patch updates.

@item @code{package_patch_version_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract update version string


@b{Example}:@*
@*

@verbatim

body package_method zypper
{
package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
}

@end verbatim


@b{Notes}:@*
@*

A few package managers keep a separate notion of patches, as opposed to package updates.
OpenSuSE, for example, is one of these. This provide an analogous command struct to the
packages for patch updates.

@item @code{package_update_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to update to the latest version a currently installed package


@b{Example}:@*
@*

@verbatim

body package_method zypper
{
package_update_command => "/usr/bin/zypper -non-interactive update";
}

@end verbatim


@b{Notes}:@*
@*

If supported this should be a command that updates the version of a
single currently installed package. If only bulk updates are supported, consider running
this as a single command under @code{commands}.

@item @code{package_verify_command}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Command to verify the correctness of an installed package


@b{Example}:@*
@*

@verbatim
body package_method rpm

{
package_verify_command => "/bin/rpm -V";
}

@end verbatim


@b{Notes}:@*
@*

If available, this is a command to verify an already installed
package. Such commands are not necessarily meaningful in the context
of a tool like cfengine which patches the system by `other means'.

@item @code{package_version_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression with one backreference to extract package version string


@b{Example}:@*
@*

@verbatim

body package_method rpm
{
package_version_regex => "[^\s]+ ([^.]+).*";
}

@end verbatim


@b{Notes}:@*
@*

If the version of a package is not specified separately using
@code{package_version}, then this should be a regular expression that
contains exactly one back-reference that matches the version string in the promiser.

@end table


@node package_policy in packages, package_select in packages, package_method in packages, packages in agent promises
@subsection @code{package_policy}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{add}
          @code{delete}
          @code{reinstall}
          @code{update}
          @code{patch}
          @code{verify}
@end example

@noindent @b{Synopsis}: Criteria for package installation/upgrade on the current system


@noindent @b{Example}:@*
@*

@verbatim
packages:

  "$(match_package)"

     package_policy => "add",
     package_method => "xyz";

@end verbatim


@noindent @b{Notes}:@*
@*

This decides what fate is intended for the named package.



@node package_select in packages, package_version in packages, package_policy in packages, packages in agent promises
@subsection @code{package_select}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{>}
          @code{<}
          @code{==}
          @code{!=}
          @code{>=}
          @code{<=}
@end example

@noindent @b{Synopsis}: A criterion for first acceptable match relative to "package_version"


@noindent @b{Example}:@*
@*

@verbatim
packages:

  "$(exact_package)"

     package_policy => "add",
     package_method => xyz,
     package_select => ">=",
     package_architectures => { "x86_64" },
     package_version => "1.2.3-456";

@end verbatim


@noindent @b{Notes}:@*
@*

This selects the operator that compares the promiser to the state of the system
packages currently installed. If the criterion matches, the policy action is
scheduled for promise-keeping.



@node package_version in packages,  , package_select in packages, packages in agent promises
@subsection @code{package_version}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Version reference point for determining promised version


@noindent @b{Example}:@*
@*

@verbatim
packages:

  "mypackage"

     package_policy => "add",
     package_method => rpm,
     package_select => "=",
     package_version => "1.2.3";

@end verbatim


@noindent @b{Notes}:@*
@*

Used for specifying the targeted package version when the version is written
separately from the name of the command. 



@node processes in agent promises, storage in agent promises, packages in agent promises, Bundles for agent
@section @code{processes} promises in @samp{agent}

@*

Process promises refer to items in the system process table. Note that
this is not the same as commands (which are instructions). A process
is a command in some state of execution (with a Process Control
Block).  Promiser objects here are patterns that match line fragments
in the system process table.

@cartouche
@smallexample

 processes:

   "@var{regex contained in process line}"
     
       process_select => @var{process_filter_body},
       restart_class => "activation class for process",
       ..;

@end smallexample
@end cartouche

In cfengine 2 there was a restart clause for directly executing a
command to restart a process. In cfengine 3 there is instead
a class to activate. You must then desribe a @code{command} in that
class to restart the process.

@verbatim

commands:

  restart_me::

   "/path/executable" ... ;

@end verbatim
This rationalizes complex restart-commands and avoids unnecessary overlap
between @code{processes} and @code{commands}.

The @code{process_stop} is also arguably a command, but it should be
an ephemeral command that does not lead to a persistent process. It is
intended only for commands of the form @samp{/etc/inetd service stop}, not
for processes that persist. Processes are restarted at the end of a bundle's
execution, but stop commands are executed immediately.

@i{Take care to note that process table formats differ between operating systems,
and the use of simple patterns such as program-names is recommended. For
more sophisticated matches, users should use the @code{process_select}
feature.}

Note: @code{process_select} was previously called process @code{filters} in
cfengine 2 and earlier.


@*

@verbatim

bundle agent example
{
processes:

 ".*"

    process_count   => anyprocs,
    process_select  => proc_finder;

reports:

 any_procs::

   "Found processes out of range";
}

########################################################

body process_select proc_finder

{
stime_range => irange(ago(0,0,0,5,30,0),ago(0,0,0,0,20,0));
process_result => "stime";
}

########################################################

body process_count anyprocs

{
match_range => "0,0";
out_of_range_define => { "any_procs" };
}

@end verbatim

@*


In cfengine 2, one has two separate actions:

@smallexample
 processes
 shellcommands
@end smallexample

@noindent In cfengine 3 we have

@smallexample
 processes
 commands
@end smallexample

Cfengine 2 got this ontology about right intuitively, but not
quite. It allowed a @samp{restart} command to appear in a process
promise, which is really a command execution. This has been
changed in cfengine 3 so that there is a cleaner separation. Let's see
why.

Executions are about jobs, services, scripts etc. They are properties
of an executable file. The referring `promiser' is a file
object. On the other hand a process is a property of a "process
identifier" which is a kernel instantiation, a quite different object
altogether. So it makes sense to say that

@itemize
@item
A "PID" (which is not an executable) promises to be reminded of a signal, e.g.
@smallexample
    kill signal pid
@end smallexample
@item
An "command" promises to start or stop itself with a parameterized specification.
@smallexample
    exec command argument1 argument2 ...
@end smallexample
@end itemize

Neither the file nor the pid necessarily promise to respond to these activations, but they
are nonetheless physically meaningful phenomena or attributes associated with these objects.

@itemize
@item 
Executable files do not listen for signals as they have no active state.
@item 
PIDs do not run themselves or stop themselves with new arguments, but they can use signals as they are running.
@end itemize

Executions lead to processes for the duration of their lifetime, so these two issues
are related, although the promises themselves are not. 

@*
@noindent @b{Services verus processes}:
@*

A service is an abstraction that requires processes to run and files
to be configured. It makes a lot of sense to wrap services in modular
bundles. Starting and stopping a service can be handled in at least two ways.
Take the web service as an example.

We can start the service by promising an execution of a daemon (e.g. @code{httpd}).
Normally this execution does not terminate without intervention. We can
terminate it in one of two ways:

@itemize
@item
Using a process signal, by promising a signal to processes matching a certain pid search
@item
Using an execution of a termination command, e.g. @samp{/etc/init.d/apache stop}.
@end itemize

The first case makes sense if we need to qualify the termination by
searching for the processes. The processes section of a cfengine 3
policy includes a control promise to search for matching processes.
If matches are found, signals can be sent to precisely each specific process.

Classes can also be defined, in principle triggering an execution of
the stop script, but then the class refers only to the presence of
matching pids, not to the individual pids concerned.  So it becomes
the responsibility of the execution to locate and interact with the
pids necessary.

@*
@noindent @b{Want it running?}:
@*

How do we say simply that we want a service running?
In the agent control promises, we could check each service
individually.
@verbatim
bundlesequence => { Update, Service("apache"), Service("nfsd") };
@end verbatim
or
@verbatim
bundlesequence => { Update, @(globals.all_services)  };
@end verbatim

The bundle for this can look like this:
@verbatim
bundle agent Service("$(service)")

{
processes:

  "$(service)" 

      process_count => up("$(service)");

commands:

   "$daemons[$(service)]"  

      ifvarclass => "$(service)_up",
      args       => "$args[$(service)]";

}
@end verbatim

An alternative would be self-contained:

@verbatim
bundle agent Service

{
vars:

  "service" slist => { "apache", "nfsd", "bind" };

processes:

  "$(service)" 

      process_count => up("$(service)");

commands:

   "$daemons[$(service)]"  

      ifvarclass => "$(service)_up",
      args       => "$args[$(service)]";

}

######################
# Parameterized body
######################

body process_count("$(s)")

{
match_range => "[0,10]";
out_of_range_define => "$(s)_up";
}

@end verbatim


Is this a step backwards?
The cfengine 3 approach might seem like a step backwards from the simple cfengine 2 statement:
@verbatim
processes:

  "httpd" restart "/etc/init.d/apache restart"
@end verbatim

However, it allows several improvements.

You can do other things in between stopping and starting the service,
like file editing, or security sweeps.  You can use templates to
simplify the syntax in bulk for several process checks or restarts.

@verbatim
processes:

  "$(service.list)"

@end verbatim
If you don't want any delay in stopping and starting the service, then
place these promises in a private bundle with nothing in between them.



@menu
* process_count in processes::  
* process_select in processes::  
* process_stop in processes::   
* restart_class in processes::  
* signals in processes::        
@end menu

@node process_count in processes, process_select in processes, processes in agent promises, processes in agent promises
@subsection @code{process_count} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{in_range_define}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of classes to define if the matches are in range


@b{Example}:@*
@*

@verbatim

body process_count example
{
in_range_define => { "class1", "class2" };
}

@end verbatim


@b{Notes}:@*
@*

Classes are defined if the processes that are found in the process table satisfy the
promised process count, i.e. if the promise about the number of processes matching
the other criteria is kept.

@item @code{match_range}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Integer range for acceptable number of matches for this process


@b{Example}:@*
@*

@verbatim

body process_count example
{
match_range => irange("10","50");
}

@end verbatim


@b{Notes}:@*
@*

This is a numerical range for the number of occurrences of the
process in the process table. As long as it falls within the specified
limits, the promise is considered kept.

@item @code{out_of_range_define}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of classes to define if the matches are out of range


@b{Example}:@*
@*

@verbatim

body process_count example(s)
{
out_of_range_define => { "process_anomaly", "anomaly_$(s)"};
}

@end verbatim


@b{Notes}:@*
@*

Classes to activate remedial promises conditional on this promise failure
to be kept.

@end table


@node process_select in processes, process_stop in processes, process_count in processes, processes in agent promises
@subsection @code{process_select} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{command}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression matching the command/cmd field of a process


@b{Example}:@*
@*

@verbatim

body select_process example

{
command => "cf-.*";

process_result => "command";
}

@end verbatim


@b{Notes}:@*
@*

This expression should match the entire @code{COMMAND} field of the
process table (not just a fragment). This field is usually the last
field on the line and thus starts with the first non-space character
and ends with the end of line.

@item @code{pid}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the process id of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
ppid => irange("1","10");
process_result => "ppid";
}

@end verbatim



@b{Notes}:@*
@*


@item @code{pgid}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the parent group id of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
pgid => irange("1","10");
process_result => "pgid";
}

@end verbatim


@b{Notes}:@*
@*



@item @code{ppid}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the parent process id of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
ppid => irange("407","511");
}

@end verbatim


@b{Notes}:@*
@*


@item @code{priority}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{-20,+20}


@noindent @b{Synopsis}: Range of integers matching the priority field (PRI/NI) of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
priority => irange("-5","0");
}

@end verbatim


@b{Notes}:@*
@*


@item @code{process_owner}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of regexes matching the user of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
process_owner => { "wwwrun", "nobody" };
}

@end verbatim


@b{Notes}:@*
@*

Regular expression should match a legal user name on the system.

@item @code{process_result}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[(process_owner|pid|ppid||pgid|rsize|vsize|status|command|ttime|stime|tty|priority|threads)[|&!.]*]*}


@noindent @b{Synopsis}: Boolean class expression returning the logical combination of classes set by a process selection test


@b{Example}:@*
@*


@verbatim

body process_select proc_finder(p)

{
process_owner  => { "avahi", "bin" };
command        => "$(p)";
pid            => "100,199";
vsize          => "0,1000";
process_result => "command.(process_owner|rsize)";
}

@end verbatim


@b{Notes}:@*
@*

A logical combination of the process selection classifiers. The syntax
is the same as that for class expressions. There should be no spaces
in the expressions.

@item @code{rsize}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the resident memory size of a process


@b{Example}:@*
@*

@verbatim

body process_select
{
rsize => irange("4000","8000");
}


@end verbatim


@b{Notes}:@*
@*


@item @code{status}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression matching the status field of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
status => "Z";
}

@end verbatim


@b{Notes}:@*
@*

For instance, characters in the set @samp{NRS<sl+..}

@item @code{stime_range}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,2147483647}


@noindent @b{Synopsis}: Range of integers matching the start time of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
stime_range => irange(ago(0,0,0,1,0,0,),now);
}

@end verbatim


@b{Notes}:@*
@*


The calculation of time from process table entries is sensitive to
Daylight Savings Time (Summer/Winter Time) so calculations could be a
hour off. This is for now a bug to be fixed.


@item @code{ttime_range}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,2147483647}


@noindent @b{Synopsis}: Range of integers matching the total elapsed time of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
ttime_range => irange(0,accumulated(0,1,0,0,0,0));
}

@end verbatim


@b{Notes}:@*
@*

This is total accumulated time for a process.

@item @code{tty}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression matching the tty field of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
tty => "pts/[0-9]+";
}

@end verbatim


@b{Notes}:@*
@*


@item @code{threads}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the threads (NLWP) field of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
threads => irange(1,5);
}

@end verbatim


@b{Notes}:@*
@*



@item @code{vsize}
@b{Type}: irange [int,int]

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Range of integers matching the virtual memory size of a process


@b{Example}:@*
@*

@verbatim

body process_select example
{
vsize => irange("4000","9000");
}

@end verbatim


@b{Notes}:@*
@*


@end table


@node process_stop in processes, restart_class in processes, process_select in processes, processes in agent promises
@subsection @code{process_stop}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: A command used to stop a running process


@noindent @b{Example}:@*
@*

@verbatim

processes:

 "snmpd"

        process_stop => "/etc/init.d/snmp stop";


@end verbatim


@noindent @b{Notes}:@*
@*

As an alternative to sending a termination or kill signal to a process,
one may call a `stop script' to perform a graceful shutdown.



@node restart_class in processes, signals in processes, process_stop in processes, processes in agent promises
@subsection @code{restart_class}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: @code{[a-zA-Z0-9_$.]+}


@noindent @b{Synopsis}: A class to be set if the process is not running, so that a command: rule can be referred to restart the process


@noindent @b{Example}:@*
@*

@verbatim

processes:

   "cfservd"

     restart_class => "start_cfserv";

commands:

  start_cfserv::

    "/usr/local/sbin/cfservd";

@end verbatim


@noindent @b{Notes}:@*
@*

This is a signal to restart a process that should be running, if it is
not running.  Processes are signalled first and then restarted later,
at the end of bundle execution, after all possible corrective actions have
been made that could influence their execution.



@node signals in processes,  , restart_class in processes, processes in agent promises
@subsection @code{signals}
@noindent @b{Type}: (option list)

@noindent @b{Allowed input range}: @*
@example
          @code{hup}
          @code{int}
          @code{trap}
          @code{kill}
          @code{pipe}
          @code{cont}
          @code{abrt}
          @code{stop}
          @code{quit}
          @code{term}
          @code{child}
          @code{usr1}
          @code{usr2}
          @code{bus}
          @code{segv}
@end example

@noindent @b{Synopsis}: A list of menu options representing signals to be sent to a process


@noindent @b{Example}:@*
@*

@verbatim

processes:

 cfservd_out_of_control::

   "cfservd"

        signals         => { "stop" , "term" },
        restart_class   => "start_cfserv";

 any::

   "snmpd"

        signals         => { "term" , "kill" };
   
@end verbatim


@noindent @b{Notes}:@*
@*

Signals are presented as an ordered list to the process.



@node storage in agent promises,  , processes in agent promises, Bundles for agent
@section @code{storage} promises in @samp{agent}

@*

Storage promises refer to disks and filesystem properties.

@cartouche
@smallexample

 storage:

    "/@var{disk volume or mountpoint}"

      volume => @var{volume_body},
      ...;

@end smallexample
@end cartouche

In cfengine 2, storage promises were divided into @code{disks} or
@code{required}, and @code{misc_mounts} types. The old mount-models
for binary and home servers has been deprecated and removed from
cfengine 3. Users who use these models can reconstruct them from the
low-level tools.

@*

@verbatim

bundle agent storage

{
storage:

  "/usr" volume  => mycheck("10%");
  "/mnt" mount   => nfs("nfsserv.example.org","/home");

}

#######################################################

body volume mycheck(free)   # reusable template

{
check_foreign  => "false";
freespace      => "$(free)";
sensible_size  => "10000";
sensible_count => "2";
}

body mount nfs(server,source)

{
mount_type => "nfs";
mount_source => "$(source)";
mount_server => "$(server)";
edit_fstab => "true";
}
@end verbatim

@*




@menu
* mount in storage::            
* volume in storage::           
@end menu

@node mount in storage, volume in storage, storage in agent promises, storage in agent promises
@subsection @code{mount} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{edit_fstab}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false add or remove entries to the file system table ("fstab")


@b{Example}:@*
@*

@verbatim

body mount example
{
edit_fstab => "true";
}

@end verbatim


@b{Notes}:@*
@*

The default behaviour is to not place edits in the file system table.

@item @code{mount_type}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{nfs}
          @code{nfs2}
          @code{nfs3}
          @code{nfs4}
@end example

@noindent @b{Synopsis}: Protocol type of remote file system


@b{Example}:@*
@*

@verbatim

body mount example
{
mount_type => "nfs3";
}

@end verbatim


@b{Notes}:@*
@*

This field is mainly for future extensions.

@item @code{mount_source}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[cC]:\\.*|/.*}


@noindent @b{Synopsis}: Path of remote file system to mount


@b{Example}:@*
@*
@verbatim

body mount example
{
mount_source "/location/disk/directory";
}

@end verbatim


@b{Notes}:@*
@*

This is the location on the remote device, server, SAN etc.

@item @code{mount_server}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Hostname or IP or remote file system server


@b{Example}:@*
@*

@verbatim

body mount example
{
mount_server => "nfs_host.example.org";
}

@end verbatim


@b{Notes}:@*
@*

Hostname or IP address, this could be on a SAN.

@item @code{mount_options}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of option strings to add to the file system table ("fstab")


@b{Example}:@*
@*

@verbatim
body mount example
{
mount_options => { "rw", "acls" };
}

@end verbatim


@b{Notes}:@*
@*

This list is concatenated in a form appropriate for the filesystem. The options must be
legal options for the system mount commands.

@item @code{unmount}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false unmount a previously mounted filesystem


@b{Example}:@*
@*

@verbatim

body mount example
{
unmount => "true";
}

@end verbatim


@b{Notes}:@*
@*


@end table


@node volume in storage,  , mount in storage, storage in agent promises
@subsection @code{volume} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{check_foreign}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false verify storage that is mounted from a foreign system on this host


@b{Example}:@*
@*

@verbatim

body volume example

{
#..
check_foreign  => "false";
}

@end verbatim


@b{Notes}:@*
@*

Cfengine will not normally perform sanity checks on filesystems which
are not local to the host. If @code{true} it will ignore a partition's
network location and ask the current host to verify storage located
physically on other systems.

@item @code{freespace}
@b{Type}: string

@noindent @b{Allowed input range}: @code{[0-9]+[mb%]}


@noindent @b{Synopsis}: Absolute or percentage minimum disk space that should be available before warning


@b{Example}:@*
@*

@verbatim

body volume example1
{
freespace => "10%";
}

body volume example2
{
freespace => "50M";
}

@end verbatim


@b{Notes}:@*
@*

The amount of freespace that is promised on a storage device. Once
this promise is found not to be kept, warnings are generated.

@item @code{sensible_size}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Minimum size in bytes that should be used on a sensible-looking storage device


@b{Example}:@*
@*

@verbatim

body volume example
{
sensible_size => "20K";
}

@end verbatim





@b{Notes}:@*
@*

@verbatim

body volume control
{
sensible_size => "20K";
}

@end verbatim




@item @code{sensible_count}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Minimum number of files that should be defined on a sensible-looking storage device


@b{Example}:@*
@*

@verbatim

body volume example
{
sensible_count => "20";
}

@end verbatim


@b{Notes}:@*
@*

Files must be readable by the agent, i.e. it is assumed that the agent has privileges
on volumes being checked.

@item @code{scan_arrivals}
@b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false generate pseudo-periodic disk change arrival distribution


@b{Example}:@*
@*

@verbatim 

body volume example
{
scan_arrivals => "true";
}

@end verbatim


@b{Notes}:@*
@*

This operation should not be left `on' for more than a single run
(maximum once per week).  It causes cfengine to perform an extensive
disk scan noting the schedule of changes between files. This can be
used for a number of analyses including optimum backup schedule computation.

@end table
@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Bundles for server, Bundles for knowledge, Bundles for agent, Top
@chapter Bundles of @code{server}

@*

@cartouche
@smallexample

bundle server access_rules()

@{
access:

  "/home/mark/PrivateFiles"

    admit   => @{ ".*\.example\.org" @};

  "/home/mark/.cfagent/bin/cf-agent"

    admit   => @{ ".*\.example\.org" @};

roles:

  ".*"  authorize => @{ "mark" @};
@}


@end smallexample
@end cartouche

@*

Bundles in the server describe access promises on specific file and class
objects supplied by the server to clients.



@menu
* access in server promises::   
* roles in server promises::    
@end menu

@node access in server promises, roles in server promises, Bundles for server, Bundles for server
@section @code{access} promises in @samp{server}

@*

Access promises are conditional promises made by the server about file
objects. The promise has two consequences. For file copy requests, the
file becomes transferrable to the remote client according to the
conditions specified in the server promse (i.e. if the connection
encryption requirements are met, and if the client has been granted
appropriate privileges with @code{maproot} (like its NFS counterpart)
to be able to see file objects not owned by the server process owner).

The promise has two mutally exclusive attributes @samp{admit} and
@samp{deny}. Use of @samp{admit} is preferred as mistakes and
omissions can easily be made when excluding from a group.

When access is granted to a directory, the promise is automatically
given about all of its contents and sub-directories.
The access promise allows overlapping promises to be made, and these
are kept in a first-come-first-served fashion. Thus file
objects (promisers) should be listed in order of most-specific file
first. In this way, specific promises will override less specific ones.

@cartouche
@smallexample

 access:

    @var{"/path/file_object"}

      admit   => @{ @var{"hostname"}, @var{"ipv4_address"}, @var{"ipv6_address"}  @};


@end smallexample
@end cartouche


@*

@menu
* Access Example::              
* admit in access::             
* deny in access::              
* maproot in access::           
* ifencrypted in access::       
* resource_type in access::     
@end menu

@node Access Example, admit in access, access in server promises, access in server promises
@subsection Access Example 

@verbatim

#########################################################
# Server config
#########################################################

body server control 

{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };
}

#########################################################

bundle server access_rules()

{
access:

  "/home/mark/LapTop"

    admit   => { "127.0.0.1" };
}

@end verbatim

@*

Entries may be literal addresses of IPv4 or IPv6, or any name registered
in the POSIX @code{gethostbyname} service.



@node admit in access, deny in access, Access Example, access in server promises
@subsection @code{admit}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of host names or IP addresses to grant access to file objects


@noindent @b{Example}:@*
@*


@verbatim
access:

  "/home/mark/LapTop"

    admit   => { "127.0.0.1", "192.168.0.1/24", ".*.domain.tld"  };

@end verbatim


@noindent @b{Notes}:@*
@*

Admit promises grant access to file objects on the server. Arguments
may be IP addresses or hostnames, provided DNS name resolution is
active. In order to reach this stage, a client must first have passed
all of the standard connection tests in the control body.

The lists may contain network addresses in CIDR notation or regular
expressions to match the IP address or name of the connecting host.



@node deny in access, maproot in access, admit in access, access in server promises
@subsection @code{deny}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of host names or IP addresses to deny access to file objects


@noindent @b{Example}:@*
@*


@verbatim

bundle server access_rules()

{
access:

  "/path"

    admit   => { ".*\.example\.org" },
    deny    => { "badhost_1\.example\.org", "badhost_1\.example\.org" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

Denial is for special exceptions. A better strategy is always to grant
on a need to know basis. A security policy based on exceptions is a
weak one.



@node maproot in access, ifencrypted in access, deny in access, access in server promises
@subsection @code{maproot}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of host names or IP addresses to grant full read-privilege on the server


@noindent @b{Example}:@*
@*

@verbatim

access:

 "/home"

       admit => { "backup_host.example.org" },
 ifencrypted => "true",

     # Backup needs to have access to all users

     maproot => { "backup_host.example.org" };

@end verbatim


@noindent @b{Notes}:@*
@*

Normally users authenticated by the server are granted access only to
files owned by them and no-one else.
Even if the @code{cf-serverd} process runs with root privileges on the
server side of a client-server connection, the client is not automatically
granted access to download files owned by non-privileged users. If @code{maproot}
is true then remote @code{root} users are granted access to all files.

A typical case where mapping is important is in making backups of many user
files.



@node ifencrypted in access, resource_type in access, maproot in access, access in server promises
@subsection @code{ifencrypted}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{true}
          @code{false}
          @code{yes}
          @code{no}
          @code{on}
          @code{off}
@end example

@noindent @b{Synopsis}: true/false whether the current file access promise is conditional on the connection from the client being encrypted


@noindent @b{Example}:@*
@*

@verbatim

access:

   "/path/file"

    admit     => { ".*.example.org" },
    ifencrypted => "true";

@end verbatim


@noindent @b{Notes}:@*
@*

If this flag is true a client cannot access the file object unless
its connection is encrypted.




@node resource_type in access,  , ifencrypted in access, access in server promises
@subsection @code{resource_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{path}
          @code{literal}
@end example

@noindent @b{Synopsis}: The type of object being granted access. The default is access to files.


@noindent @b{Example}:@*
@*

@verbatim


bundle server access_rules()

{
vars:

  "localvar" string => "literal string";

access:

  "This is a $(localvar) for remote access"
 
        handle  => "test_scalar",
  resource_type => "literal",
        admit   => { "127.0.0.1" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

By default, access to resources granted by the server are
files. However, sometimes it is useful to cache @code{literal}
strings, hints and data in the server, e.g. the contents of variables,
hashed passwords etc for easy access. In the case of literal data, the
promise handle serves as the reference identifier for queries. Queries
are instigated by function calls by any agent.



@node roles in server promises,  , access in server promises, Bundles for server
@section @code{roles} promises in @samp{server}

@*


Roles promises are server-side decisions about which users are allowed
to define soft-classes on the server's system during remote invocation
of @code{cf-agent}. This implements a form of Role Based Access
Control (RBAC) for pre-assigned class-promise bindings. The user names
cited must be attached to trusted public keys in order to be accepted.

@cartouche
@smallexample

 roles:

   "@var{regex}"

      authorize => @{ "@var{usernames}", ... @};

@end smallexample
@end cartouche

@i{It is worth re-iterating here that it is not possible to send
commands or modify promise definitions by remote access. At best users
may try to send classes when using @code{cf-runagent} in order to
activate sleeping promises. This mechanism limits their ability to
do this}.



@*

@verbatim

bundle server access_rules()

{
roles:

  # Allow mark

  "Mark_.*"  authorize => { "mark" };
}

@end verbatim

@*

In this example user @samp{mark} is granted permission to remotely
activate classes matching the regular expression when using the
@code{cf-runagent} to activate cfengine. In this way one can
implement a form of Role Based Access Control (RBAC), provided
users do not have privileged access on the host directly.



@menu
* authorize in roles::          
@end menu

@node authorize in roles,  , roles in server promises, roles in server promises
@subsection @code{authorize}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of public-key user names that are allowed to activate the promised class during remote agent activation


@noindent @b{Example}:@*
@*


@verbatim

roles:

  ".*"  authorize => { "mark", "marks_friend" };

@end verbatim


@noindent @b{Notes}:@*
@*

Part of Role Based Access Control (RBAC) in cfengine. The users listed
in this section are granted access to set certain classes by using the
remote @code{cf-runagent}. The user-names will refer to public key
identities already trusted on the system.

@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Bundles for knowledge, Bundles for monitor, Bundles for server, Top
@chapter Bundles of @code{knowledge}

@*

@cartouche
@smallexample

bundle knowledge system

@{
topics:

 Troubleshooting::

  "Segmentation fault"       
       association => a("is caused by","Bad memory reference","can cause");

  "Remote connection problem";
  "Web server not running";
  "Print server not running";
  "Bad memory reference";
@}

@end smallexample
@end cartouche


@*


Knowledge bundles describe topic maps, i.e. Topics, Associations and
Occurrences (of topics in documents). This is for knowledge modelling
and has no functional effect on a system.




@menu
* topics in knowledge promises::  
* occurrences in knowledge promises::  
@end menu

@node topics in knowledge promises, occurrences in knowledge promises, Bundles for knowledge, Bundles for knowledge
@section @code{topics} promises in @samp{knowledge}

@*

Topic promises are part of the knowledge management engine. A topic is
any string that refers to a concept or subject that we wish to include
in a knowledge base. If a topic has a very long name, it is best to made the
promiser object a short name and use the @code{comment} field
to add the long explanation (e.g. unique acronym and full text).

@cartouche
@smallexample

 topics:

  "@var{topic string}"

   comment => "@var{long name..}",
   ...;

@end smallexample
@end cartouche

Topics form associative structures based entirely on an abstract space
of natural language. Actually, this is only slightly more abstract
than files, processes and commands etc. The main difference in
knowledge management is that there are no corrective or maintenance
operations associated with knowledge promises.

Class membership in knowledge management is subtly different from
other parts of cfengine. If a topic lies in a certain class context,
the topic uses it as a type-label. This is used for disambiguation of
subject-area in searches rather than for disambiguation of rules between
physical environments.

@*

@verbatim

bundle knowledge example
{
topics:

   "Distro"
      comment     => "Distribution of linux",              
      association => a("is a packaging of","Linux","is packaged as a");
}

@end verbatim

@*

Topics are basically identifiers, where the comment field here is a
long form of the subject string. Associations form semantic links
between topics. Topics can appear multiple times in order to form
multiple associations.



@menu
* association in topics::       
* comment in topics::           
@end menu

@node association in topics, comment in topics, topics in knowledge promises, topics in knowledge promises
@subsection @code{association} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{forward_relationship}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of forward association between promiser topic and associates


@b{Example}:@*
@*


@verbatim

body association example
{
forward_relation => "is bigger than";
}

@end verbatim


@b{Notes}:@*
@*


@item @code{backward_relationship}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Name of backward/inverse association from associates to promiser topic


@b{Example}:@*
@*

@verbatim
body association example
{
# ..
backward_relationship => "is less than";
}

@end verbatim


@b{Notes}:@*
@*

Denotes the inverse name which is used to `moralizing' the association graph.


@item @code{associates}
@b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of associated topics by this forward relationship


@b{Example}:@*
@*


@verbatim

body association example(literal,scalar,list)

{
#...
associates => { "literal", $(scalar),  @(list)};
}

@end verbatim


@b{Notes}:@*
@*

An element of an association which is a list of topics to which the
current topic is associated.

@end table


@node comment in topics,  , association in topics, topics in knowledge promises
@subsection @code{comment}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Retained comment about this promise's real intention


@noindent @b{Example}:@*
@*

@verbatim

comment => "This comment follows the data for reference ...",

@end verbatim


@noindent @b{Notes}:@*
@*

Comments written in code follow the program, they are not merely discarded.
They appear in reports and error messages.



@node occurrences in knowledge promises,  , topics in knowledge promises, Bundles for knowledge
@section @code{occurrences} promises in @samp{knowledge}

@*


Occurrences are documents or information resources that discuss
topics. An occurrence promise asserts that a particular document of
text resource in fact represents information about one or more topics.
This is used to construct references to actual information in a topic
map.

@cartouche
@smallexample

 occurrences:

   @var{topic_name}::

     "@var{URL reference or literal string}"

         represents => @{ "@var{sub-topic disambiguator}", ... @},
         representation => "@var{literal or url}";

@end smallexample
@end cartouche

@*

@verbatim

 Mark_Burgess::

     "http://www.iu.hio.no/~mark"
            represents => { "Home Page" };

 lvalue::

     "A variable identifier, i.e. the left hand side of an '=' association. The promiser in a variable promise."
            represents => { "Definitions" },
            representation => "literal";

 Editing_Files::

 "http://www.cfengine.org/confdir/customizepasswd.html" 
   represents => { "Setting up users" };


@end verbatim

@*

Occurrences are pointers to information about topics. This
might be a literal text string or a URL reference to an external
document.



@menu
* represents in occurrences::   
* representation in occurrences::  
* web_root in occurrences::     
* path_root in occurrences::    
@end menu

@node represents in occurrences, representation in occurrences, occurrences in knowledge promises, occurrences in knowledge promises
@subsection @code{represents}
@noindent @b{Type}: slist

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: List of subtopics that explains the type(s) of information represented by the occurrence


@noindent @b{Example}:@*
@*

@verbatim

occurrences:

  Promise_Theory::

    "A theory of autonomous actors that offer certainty through promises"

      represents     => { "Definitions" },
      representation => "literal";

@end verbatim


@noindent @b{Notes}:@*
@*

The sub-topic or occurrence-type represented by the document reference
in a knowledge base. This string is intended as an annotation to the
reader about the nature of the inforation located in the occurrence
document. It should be used `creatively'.

If the document type is an image and one of the items in this list is
a url, beginning with either @samp{/} or @samp{http}, then
@code{cf-know} treats the reference as a url to be reached when the
image is clicked on. 



@node representation in occurrences, web_root in occurrences, represents in occurrences, occurrences in knowledge promises
@subsection @code{representation}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{literal}
          @code{url}
          @code{db}
          @code{file}
          @code{web}
          @code{image}
          @code{portal}
@end example

@noindent @b{Synopsis}: How to interpret the promiser string e.g. actual data or reference to data


@noindent @b{Example}:@*
@*

@verbatim
occurrences:

  Promise_Theory::

    "A theory of autonomous actors that offer certainty through promises"

      represents     => { "Definitions" },
      representation => "literal";


@end verbatim


@noindent @b{Notes}:@*
@*

The form of knowledge representation in a topic map occurrence reference.
If the type @code{portal} is used it assumes that a new website should open in a new
target window.



@node web_root in occurrences, path_root in occurrences, representation in occurrences, occurrences in knowledge promises
@subsection @code{web_root}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Base URL of the occurrence when rendered as a web-URL (replaces path_root)


@noindent @b{Example}:@*
@*

@verbatim
bundle knowledge demo
{
occurrences:

 mytopic:

   "reports/(.*)/mytopic_file.html"

            represents => { "found in directory $(match.1)" },
            representation => "file",
            path_root => "$(enterprise_start.doc_root)",
            web_root => "";
}

@end verbatim


@noindent @b{Notes}:@*
@*

When identifying occurrences by searching for files on the local file system,
the web root provides the HTTP prefix for the document root under which we
are searching so that path names can be mapped into URLs, @xref{path_root in occurrences}.



@node path_root in occurrences,  , web_root in occurrences, occurrences in knowledge promises
@subsection @code{path_root}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Base path of the occurrence when locating file (replaced by web_root)


@noindent @b{Example}:@*
@*
@verbatim



bundle knowledge demo
{
occurrences:

 mytopic:

   "reports/(.*)/mytopic_file.html"

            represents => { "found in directory $(match.1)" },
            representation => "file",
            path_root => "$(enterprise_start.doc_root)",
            web_root => "";
}    

@end verbatim


@noindent @b{Notes}:@*
@*

When searching a local file system for document occurrences, the @code{path_root}
points to the local file system's name for the document root. This will be
translated into the URL prefix defined by @code{web_root}, @xref{web_root in occurrences}.

@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Bundles for monitor, Special functions, Bundles for knowledge, Top
@chapter Bundles of @code{monitor}

@*

@cartouche

@smallexample

bundle monitor example
@{
measurements:

     # Discover disk device information

  "/bin/df"

      handle => "free_memory_watch",
      stream_type => "pipe",
      data_type => "slist",
      history_type => "static",
      units => "device",
      match_value => file_systems;


@}

@end smallexample

@end cartouche

Monitor bundles contain user defined promises for system discovery and monitoring.

@*





@menu
* measurements in monitor promises::  
@end menu

@node measurements in monitor promises,  , Bundles for monitor, Bundles for monitor
@section @code{measurements} promises in @samp{monitor}

@*

@i{These features are available only in Enterprise versions of cfengine.}

Cfengine's monitoring component @code{cf-monitord} records a number
of performance data about the system by default. These include
process counts, service traffic, load average and cpu utilization and
temperature when available.

Cfengine Nova extends this in two ways. First it adds a three year
trend summary based any `shift'-averages. Second, it addd customizable
promises to monitor or log specific quite specific user data through a
generic interface. The end result is to either generate a periodic
time series, like the above mentioned values, or to log the results to
custom-defined reports.


Cfengine Nova adds a new promise type in bundles for the monitoring
agent. These are written just like all other promises within a bundle
destined for the agent concerned. In this case:

@verbatim
bundle monitor watch

{
measurements:

  # promises ...

}

@end verbatim

It is important to specificy a promise @code{handle} for measurement
promises, as the names defined in the handle are used to determine the
name of the log file or variable to which data will be reported. Log
files are created under @file{WORKDIR/state}. Data that have no history
type are stored in a special variable context called @samp{mon}, analogous
to the system variables in @samp{sys}. Thus the values may be used
in other promises in the form @code{$(mon.handle)}.

@*

@verbatim

  # Follow a special process over time
  # using cfengine's process cache to avoid resampling

   "/var/cfengine/state/cf_rootprocs"

      handle => "monitor_self_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "none",
      units => "kB",
      match_value => proc_value(".*cf-monitord.*",
        
         "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");


  # Discover disk device information

  "/bin/df"

      handle => "free_memory_watch",
      stream_type => "pipe",
      data_type => "slist",
      history_type => "static",
      units => "device",
      match_value => file_systems;
      # Update this as often as possible

}


@end verbatim

@*

The general pattern of these promises is to decide the source of the information either file or pipe,
determine the data type (integer, string etc.), specify a pattern to match the result in the file stream
and then specify what to do with the result afterwards.



@menu
* stream_type in measurements::  
* data_type in measurements::   
* history_type in measurements::  
* units in measurements::       
* match_value in measurements::  
@end menu

@node stream_type in measurements, data_type in measurements, measurements in monitor promises, measurements in monitor promises
@subsection @code{stream_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{pipe}
          @code{file}
@end example

@noindent @b{Synopsis}: The datatype being collected.


@noindent @b{Example}:@*
@*

@verbatim

stream_type => "pipe";

@end verbatim


@noindent @b{Notes}:@*
@*

Cfengine treats all input using a stream abstraction. The preferred interface is files, since they
can be read without incurring the cost of a process. However pipes from executed commands may also
be invoked.



@node data_type in measurements, history_type in measurements, stream_type in measurements, measurements in monitor promises
@subsection @code{data_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{counter}
          @code{int}
          @code{real}
          @code{string}
          @code{slist}
@end example

@noindent @b{Synopsis}: The datatype being collected.


@noindent @b{Example}:@*
@*

@verbatim

  "/bin/df"

      handle => "free_disk_watch",
      stream_type => "pipe",

      data_type => "slist",

      history_type => "static",
      units => "device",
      match_value => file_systems,
      action => sample_min(10,15);


@end verbatim


@noindent @b{Notes}:@*
@*

When cfengine (Nova) observes data, such as the attached partitions in
the example above, the datatype determines how that data will be
handled.  Integer and real values, counters etc., are recorded as
time-series if the history type is `weekly', or as single values
otherwise. If multiple items are matched by an observation,
e.g. several lines in a file match the given regular expression,
then these can be made into a list by choosing @code{slist}, else
the first matching item will be selected.




@node history_type in measurements, units in measurements, data_type in measurements, measurements in monitor promises
@subsection @code{history_type}
@noindent @b{Type}: (menu option)

@noindent @b{Allowed input range}: @*
@example
          @code{weekly}
          @code{scalar}
          @code{static}
          @code{log}
@end example

@noindent @b{Synopsis}: Whether the data can be seen as a time-series or just an isolated value


@noindent @b{Example}:@*
@*

@verbatim

 "/proc/meminfo"

      handle => "free_memory_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "weekly",
      units => "kB",
      match_value => free_memory;

@end verbatim


@noindent @b{Notes}:@*
@*

@table @samp
@item scalar
A single value, with compressed statistics is retained.
@item static
The value of the data is not expected to change for the lifetime of the daemon.
@item log
The measured value is logged as an infinite time-series.
@item weekly
A standard cfengine two-dimensional time average (over a weekly period) is retained.
@end table



@node units in measurements, match_value in measurements, history_type in measurements, measurements in monitor promises
@subsection @code{units}
@noindent @b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: The engineering dimensions of this value or a note about its intent used in plots


@noindent @b{Example}:@*
@*

@verbatim

   "/var/cfengine/state/cf_rootprocs"

      handle => "monitor_self_watch",
      stream_type => "file",
      data_type => "int",
      history_type => "none",
      units => "kB",
      match_value => proc_value(".*cf-monitord.*",
        
         "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");

@end verbatim


@noindent @b{Notes}:@*
@*

This is an arbitary string used in documentation only.



@node match_value in measurements,  , units in measurements, measurements in monitor promises
@subsection @code{match_value} (compound body)
@noindent @b{Type}: (ext body)

@table @samp
@item @code{select_line_matching}
@b{Type}: string

@noindent @b{Allowed input range}: @code{.*}


@noindent @b{Synopsis}: Regular expression for matching line location


@b{Example}:@*
@*

@verbatim

body match_value example
{
select_line_matching => "^Expression match.* whole line$";
}

@end verbatim


@b{Notes}:@*
@*

The @samp{^$} are not necessary, just remember that the expression must match
a whole line, not a fragment within a line.

@item @code{select_line_number}
@b{Type}: int

@noindent @b{Allowed input range}: @code{0,99999999999}


@noindent @b{Synopsis}: Read from the n-th line of the output (fixed format)


@b{Example}:@*
@*

@verbatim

body match_value find_line
{
select_line_number => "2";
#...
}

@end verbatim


@b{Notes}:@*
@*

This is mutually exclusive with @code{select_line_matching}.

@item @code{extraction_regex}
@b{Type}: string

@noindent @b{Allowed input range}: (arbitrary string)


@noindent @b{Synopsis}: Regular expression that should contain a single backreference for extracting a value


@b{Example}:@*
@*

@verbatim

body match_value free_memory
{
select_line_matching => "MemFree:.*";
extraction_regex => "MemFree:\s+([0-9]+).*";
}

@end verbatim


@b{Notes}:@*
@*

A single backreference should be given to lift the value to be measured out of the text stream.

@end table
@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Special functions, Special Variables, Bundles for monitor, Top
@chapter Special functions

@menu
* Function accessedbefore::     
* Function accumulated::        
* Function ago::                
* Function canonify::           
* Function changedbefore::      
* Function classify::           
* Function classmatch::         
* Function execresult::         
* Function fileexists::         
* Function filesexist::         
* Function getindices::         
* Function getgid::             
* Function getuid::             
* Function groupexists::        
* Function hash::               
* Function hashmatch::          
* Function hostrange::          
* Function hostinnetgroup::     
* Function iprange::            
* Function irange::             
* Function isdir::              
* Function isgreaterthan::      
* Function islessthan::         
* Function islink::             
* Function isnewerthan::        
* Function isplain::            
* Function isvariable::         
* Function lastnode::           
* Function ldaparray::          
* Function ldaplist::           
* Function ldapvalue::          
* Function now::                
* Function on::                 
* Function peers::              
* Function peerleader::         
* Function peerleaders::        
* Function randomint::          
* Function readfile::           
* Function readintarray::       
* Function readintlist::        
* Function readrealarray::      
* Function readreallist::       
* Function readstringarray::    
* Function readstringlist::     
* Function readtcp::            
* Function regarray::           
* Function regcmp::             
* Function registryvalue::      
* Function regline::            
* Function reglist::            
* Function regldap::            
* Function remotescalar::       
* Function returnszero::        
* Function rrange::             
* Function selectservers::      
* Function splayclass::         
* Function splitstring::        
* Function strcmp::             
* Function usemodule::          
* Function userexists::         
@end menu

@node Function accessedbefore, Function accumulated, Special functions, Special functions
@section Function accessedbefore 


@noindent @b{Synopsis}: accessedbefore(2 args) returns type class


@noindent True if arg1 was accessed before arg2 (atime)


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "do_it" and => { accessedbefore("/tmp/earlier","/tmp/later"), "linux" }; 

reports:

  do_it::

    "The secret changes have been accessed after the reference time";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The function accesses the @code{atime} fields of a file and makes a comparison.

@smallexample

 touch /tmp/reference
 touch /tmp/secretfile

 /usr/local/sbin/cf-agent -f ./unit_accessed_before.cf -K
 R: The secret changes have been accessed after the reference time

@end smallexample


@node Function accumulated, Function ago, Function accessedbefore, Special functions
@section Function accumulated 


@noindent @b{Synopsis}: accumulated(6 args) returns type int


@noindent Convert an accumulated amount of time into a system representation


@noindent @b{Example}:@*
@*

@verbatim

bundle agent testbundle

{
processes:

 ".*"

    process_count   => anyprocs,
    process_select  => proc_finder;

reports:

 any_procs::

   "Found processes in range";
}

########################################################

body process_select proc_finder

{
ttime_range => irange(accumulated(0,0,0,0,2,0),accumulated(0,0,0,0,20,0));
process_result => "ttime";
}

########################################################

body process_count anyprocs

{
match_range => "0,0";
out_of_range_define => { "any_procs" };
}

@end verbatim



@noindent @b{Notes}:@*
@*

In the example we look for processes that have accumulated between 2 and 20 minutes of
total run time.

@noindent @b{ARGUMENTS}:

@table @samp
@item Years
The year, e.g. 2009
@item Month
The Month, 1-12
@item Day
The day 1-31
@item Hours
The hour 0-23
@item Minutes
The minutes
0-59
@item Seconds
The number of seconds 0-59
@end table

@node Function ago, Function canonify, Function accumulated, Special functions
@section Function ago 


@noindent @b{Synopsis}: ago(6 args) returns type int


@noindent Convert a time relative to now to an integer system representation


@noindent @b{Example}:@*
@*

@verbatim

bundle agent testbundle

{
processes:

 ".*"

    process_count   => anyprocs,
    process_select  => proc_finder;

reports:

 any_procs::

   "Found processes out of range";
}

########################################################

body process_select proc_finder

{
stime_range => irange(ago(0,0,0,5,30,0),ago(0,0,0,0,20,0));
process_result => "stime";
}

########################################################

body process_count anyprocs

{
match_range => "0,0";
out_of_range_define => { "any_procs" };
}

@end verbatim


@noindent @b{Notes}:@*
@*

The @code{ago} function measures time relative to now.

@noindent @b{ARGUMENTS}:

@table @samp
@item Years
The year, e.g. 2009
@item Months
The Month, 1-12
@item Days
The day 1-31
@item Hours
The hour 0-23
@item Minutes
The minutes
0-59
@item Seconds
The number of seconds 0-59
@end table

@node Function canonify, Function changedbefore, Function ago, Special functions
@section Function canonify 


@noindent @b{Synopsis}: canonify(1 args) returns type string


@noindent Convert an abitrary string into a legal class name


@noindent @b{Example}:@*
@*

@verbatim

commands:

   "/var/cfengine/bin/$(component)"

       ifvarclass => canonify("start_$(component)");

@end verbatim



@noindent @b{Notes}:@*
@*

This is for use in turning arbitrary text into class data.


@node Function changedbefore, Function classify, Function canonify, Special functions
@section Function changedbefore 


@noindent @b{Synopsis}: changedbefore(2 args) returns type class


@noindent True if arg1 was changed before arg2 (ctime)


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "do_it" and => { changedbefore("/tmp/earlier","/tmp/later"), "linux" }; 

reports:

  do_it::

    "The derived file needs updating";

}

@end verbatim


@noindent @b{Notes}:@*
@*

Change times include both file permissions and file contents. Comparisons like this are normally
used for updating files (like the `make' command).

@node Function classify, Function classmatch, Function changedbefore, Special functions
@section Function classify 


@noindent @b{Synopsis}: classify(1 args) returns type class


@noindent True if the canonicalization of the argument is a currently defined class


@noindent @b{Example}:@*
@*

@verbatim

classes:

 "i_am_the_policy_host" expression => classify("master.example.org");

@end verbatim


@noindent @b{Notes}:@*
@*

This function returns true of the classification (canonical form) of
the argument is already a defined class. This is useful for
transforming variables into classes for instance. See also @code{canonify()}.

@node Function classmatch, Function execresult, Function classify, Special functions
@section Function classmatch 


@noindent @b{Synopsis}: classmatch(1 args) returns type class


@noindent True if the regular expression matches any currently defined class


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "do_it" and => { classmatch(".*_cfengine_com"), "linux" }; 

reports:

  do_it::

    "Host matches pattern";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The regular expression is matched against the current list of defined classes.


@node Function execresult, Function fileexists, Function classmatch, Special functions
@section Function execresult 


@noindent @b{Synopsis}: execresult(2 args) returns type string


@noindent Execute named command and assign output to variable


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "my_result" string => execresult("/bin/ls /tmp","noshell");

reports:

  linux::

    "Variable is $(my_result)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The second argument (@samp{useshell}/@samp{noshell}) decides whether a shell will be used to
encapsulate the command.  This is necessary in order to combine
commands with pipes etc, but remember that each command requires
a new process that reads in files beyond cfengine's control. Thus
using a shell is both a performance hog and a potential security
issue.

Note: you should never use this function to execute comands that make
changes to the system. Such an operation is beyind cfengine's ability
to guarantee convergence, and on multiple passes and during syntax 
verification, these function calls are executed resulting in system
changes that are `covert'. Calls to @code{execresult} should be
for discovery and information extraction only.

@node Function fileexists, Function filesexist, Function execresult, Special functions
@section Function fileexists 


@noindent @b{Synopsis}: fileexists(1 args) returns type class


@noindent True if the named file can be accessed


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "exists" expression => fileexists("/etc/passwd");

reports:

  exists::

    "File exists";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The user must have access permissions to the file for this to work
faithfully.

@node Function filesexist, Function getindices, Function fileexists, Special functions
@section Function filesexist 


@noindent @b{Synopsis}: filesexist(1 args) returns type class


@noindent True if the named list of files can ALL be accessed


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "mylist" slist => { "/tmp/a", "/tmp/b", "/tmp/c" };

classes:

  "exists" expression => filesexist("@(mylist)");

reports:

  exists::

    "Files exist";

  !exists::

    "Do not exist";

}



@end verbatim


@noindent @b{Notes}:@*
@*

The user must have access permissions to the file for this to work
faithfully.

@node Function getindices, Function getgid, Function filesexist, Special functions
@section Function getindices 


@noindent @b{Synopsis}: getindices(1 args) returns type slist


@noindent Get a list of keys to the array whose id is the argument and assign to variable


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
any::

  bundlesequence  => { "testsetvar" };   
}


#######################################################

bundle agent testsetvar

{
vars:

  "v[index_1]" string => "value_1";
  "v[index_2]" string => "value_2";

  "parameter_name" slist => getindices("v");

reports:

  Yr2008::

   "Found index: $(parameter_name)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

Make sure you specify the correct scope when supplying the name of the variable.

@node Function getgid, Function getuid, Function getindices, Special functions
@section Function getgid 


@noindent @b{Synopsis}: getgid(1 args) returns type int


@noindent Return the integer group id of the named group on this host


@noindent @b{Example}:@*
@*
@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "gid" int => getgid("users");

reports:

  Yr2008::

    "Users gid is $(gid)";

}

@end verbatim



@noindent @b{Notes}:@*
@*

If the named group does not exist, the variable will not be defined.

@node Function getuid, Function groupexists, Function getgid, Special functions
@section Function getuid 


@noindent @b{Synopsis}: getuid(1 args) returns type int


@noindent Return the integer user id of the named user on this host


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "uid" int => getuid("mark");

reports:

  Yr2008::

    "Users gid is $(uid)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

If the named user is not registered the variable will not be defined.

@node Function groupexists, Function hash, Function getuid, Special functions
@section Function groupexists 


@noindent @b{Synopsis}: groupexists(1 args) returns type class


@noindent True if group or numerical id exists on this host


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "gname" expression => groupexists("users");
  "gid"   expression => groupexists("100");

reports:

  gname::

    "Group exists by name";

  gid::

    "Group exists by id";

}

@end verbatim



@noindent @b{Notes}:@*
@*

The group may be specified by name or number.

@node Function hash, Function hashmatch, Function groupexists, Special functions
@section Function hash 


@noindent @b{Synopsis}: hash(2 args) returns type string


@noindent Return the hash of arg1, type arg2 and assign to a variable


@noindent @b{Example}:@*
@*

@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "md5" string => hash("Cfengine is not cryptic","md5");

reports:

  Yr2008::

    "Hashed to: $(md5)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

Hash functions are extremely sensitive to input. You should not expect
to get the same answer from this function as you would from every other
tool, since it depends on how whitespace and end of file characters are
handled.

@node Function hashmatch, Function hostrange, Function hash, Special functions
@section Function hashmatch 


@noindent @b{Synopsis}: hashmatch(3 args) returns type class


@noindent Compute the hash of arg1, of type arg2 and test if it matches the value in arg 3


@noindent @b{Example}:@*
@*

@verbatim

bundle agent example

{     
classes:

  "matches" expression => hashmatch("/etc/passwd","md5","c5068b7c2b1707f8939b283a2758a691");

reports:

  matches::

    "File has correct version";

}

@end verbatim


@noindent @b{Notes}:@*
@*


@cartouche
@example

(class) hashmatch(@var{file},@var{md5|sha1|crypt},@var{hash-comparison});

@end example
@end cartouche

This function may be used to determine whether a system has a particular
version of a binary file (e.g. software patch).

@noindent @b{ARGUMENTS}:

@itemize
@item The file concerned
@item The type of hash
@item A string of the hash to which we expect the file to conform.
@end itemize

@node Function hostrange, Function hostinnetgroup, Function hashmatch, Special functions
@section Function hostrange 


@noindent @b{Synopsis}: hostrange(2 args) returns type class


@noindent True if the current host lies in the range of enumerated hostnames specified


@noindent @b{Example}:@*
@*


@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "compute_nodes" expression => hostrange("cpu-","01-32");

reports:

  compute_nodes::

    "No computer is a cluster";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This is a pattern matching function for non-regular (enumerated) expressions.

@node Function hostinnetgroup, Function iprange, Function hostrange, Special functions
@section Function hostinnetgroup 


@noindent @b{Synopsis}: hostinnetgroup(1 args) returns type class


@noindent True if the current host is in the named netgroup


@noindent @b{Example}:@*
@*

@verbatim

classes:

  "ingroup" expression => hostinnetgroup("my_net_group");

@end verbatim


@noindent @b{Notes}:@*
@*


@node Function iprange, Function irange, Function hostinnetgroup, Special functions
@section Function iprange 


@noindent @b{Synopsis}: iprange(1 args) returns type class


@noindent True if the current host lies in the range of IP addresses specified


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "adhoc_group_1" expression => iprange("128.39.89.10-15");
  "adhoc_group_2" expression => iprange("128.39.74.1/23");

reports:

  adhoc_group_1::

    "Some numerology";

  adhoc_group_2::

    "The masked warriors";
}

@end verbatim



@noindent @b{Notes}:@*
@*

Pattern matching based on IP addresses.


@node Function irange, Function isdir, Function iprange, Special functions
@section Function irange 


@noindent @b{Synopsis}: irange(2 args) returns type irange [int,int]


@noindent Define a range of integer values for cfengine internal use


@noindent @b{Example}:@*
@*

@verbatim


@end verbatim


@noindent @b{Notes}:@*
@*

Not currently used.


@node Function isdir, Function isgreaterthan, Function irange, Special functions
@section Function isdir 


@noindent @b{Synopsis}: isdir(1 args) returns type class


@noindent True if the named object is a directory


@noindent @b{Example}:@*
@*

@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "isdir" expression => isdir("/etc");

reports:

  isdir::

    "Directory exists..";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The cfengine process must have access to the object concerned in order for
this to work.


@node Function isgreaterthan, Function islessthan, Function isdir, Special functions
@section Function isgreaterthan 


@noindent @b{Synopsis}: isgreaterthan(2 args) returns type class


@noindent True if arg1 is numerically greater than arg2, else compare strings like strcmp


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "test"  };
}

###########################################################

bundle agent test

{
classes:

  "ok" expression => isgreaterthan("1","0");

reports:

  ok::

    "Assertion is true";

 !ok::

  "Assertion is false";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The comparison is made numerically if possible. If the values are
strings, the result is identical to that of comparing with @samp{strcmp()}.

@node Function islessthan, Function islink, Function isgreaterthan, Special functions
@section Function islessthan 


@noindent @b{Synopsis}: islessthan(2 args) returns type class


@noindent True if arg1 is numerically less than arg2, else compare strings like NOT strcmp


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "test"  };
}

###########################################################

bundle agent test

{
classes:

  "ok" expression => islessthan("0","1");

reports:

  ok::

    "Assertion is true";

 !ok::

  "Assertion is false";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The complement of @code{isgreaterthan}. 
The comparison is made numerically if possible. If the values are
strings, the result is identical to that of comparing with @samp{strcmp()}.


@node Function islink, Function isnewerthan, Function islessthan, Special functions
@section Function islink 


@noindent @b{Synopsis}: islink(1 args) returns type class


@noindent True if the named object is a symbolic link


@noindent @b{Example}:@*
@*


@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "isdir" expression => islink("/tmp/link");

reports:

  isdir::

    "Directory exists..";

}

@end verbatim



@noindent @b{Notes}:@*
@*

The link node must both exist and be a symbolic link. Hard links cannot be
detected using this function. A hard link is a regular file or directory.

@node Function isnewerthan, Function isplain, Function islink, Special functions
@section Function isnewerthan 


@noindent @b{Synopsis}: isnewerthan(2 args) returns type class


@noindent True if arg1 is newer (modified later) than arg2 (mtime)


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "do_it" and => { isnewerthan("/tmp/later","/tmp/earlier"), "linux" }; 

reports:

  do_it::

    "The derived file needs updating";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This function compares the modification time of the file, referring to changes
of content only.

@node Function isplain, Function isvariable, Function isnewerthan, Special functions
@section Function isplain 


@noindent @b{Synopsis}: isplain(1 args) returns type class


@noindent True if the named object is a plain/regular file


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "isplain" expression => isplain("/etc/passwd");

reports:

  isplain::

    "File exists..";

}

@end verbatim


@noindent @b{Notes}:@*
@*


@node Function isvariable, Function lastnode, Function isplain, Special functions
@section Function isvariable 


@noindent @b{Synopsis}: isvariable(1 args) returns type class


@noindent True if the named variable is defined


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "bla" string => "xyz..";

classes:

  "exists" expression => isvariable("bla");

reports:

  exists::

    "Variable exists: \"$(bla)\"..";

}

@end verbatim


@noindent @b{Notes}:@*
@*

The variable need only exist. This says nothing about its value. Use @code{regcmp}
to check variable values.

@node Function lastnode, Function ldaparray, Function isvariable, Special functions
@section Function lastnode 


@noindent @b{Synopsis}: lastnode(2 args) returns type string


@noindent Extract the last of a separated string, e.g. filename from a path


@noindent @b{Example}:@*
@*

@verbatim

bundle agent yes
{
vars:

  "path1" string => "/one/two/last1";
  "path2" string => "one:two:last2";

  "last1" string => lastnode("$(path1)","/");
  "last2" string => lastnode("$(path2)",":");

  "last3" string => lastnode("$(path2)","/");

reports:

  Yr2009::

    "Last = $(last1),$(last2),$(last3)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This function returns the final node in a chain, given a regular expression to split on.
This is mainly useful for finding leaf-names of files, from a fully qualified path name.

@node Function ldaparray, Function ldaplist, Function lastnode, Special functions
@section Function ldaparray 


@noindent @b{Synopsis}: ldaparray(6 args) returns type class


@noindent Extract all values from an ldap record


@noindent @b{Example}:@*
@*

@verbatim

classes:

   "gotdata" expression => ldaparray(
                                    "myarray",
                                    "ldap://ldap.example.org",
                                    "dc=cfengine,dc=com",
                                    "(uid=mark)",
                                    "subtree",
                                    "none");

@end verbatim



@noindent @b{Notes}:@*
@*

@cartouche
@example

(class) ldaparray (@var{array},@var{uri},@var{dn},@var{filter},@var{scope},@var{security})

@end example
@end cartouche

This function retrieves an entire record with all elements and
populates an associative array with the entries. It returns a class
which is true if there was a match for the search and false if nothing
was retrieved.

@noindent @b{ARGUMENTS}:

@table @samp
@item array
String name of the array to populate with the result of the search
@item uri
String value of the ldap server. e.g. @code{"ldap://ldap.cfengine.com.no"}
@item dn
Distinguished name, an ldap formatted name built from components, e.g. "dc=cfengine,dc=com".
@item filter
String filter criterion, in ldap search, e.g. "(sn=User)".
@item scope
Menu option, the type of ldap search, from 
@smallexample
    subtree
    onelevel
    base
@end smallexample

@item security
Menu option indicating the encryption and authentication settings
for communication with the LDAP server. These features might be subject
to machine and server capabilites.
@smallexample
     none
     ssl
     sasl
@end smallexample
@end table
                             

@node Function ldaplist, Function ldapvalue, Function ldaparray, Special functions
@section Function ldaplist 


@noindent @b{Synopsis}: ldaplist(6 args) returns type slist


@noindent Extract all named values from multiple ldap records


@noindent @b{Example}:@*
@*

@verbatim
vars:

   # Get all matching values for "uid" - should be a single record match

  "list" slist =>  ldaplist(
                           "ldap://ldap.example.org",
                           "dc=cfengine,dc=com",
                           "(sn=User)",
                           "uid",
                           "subtree",
                           "none"
                           );

@end verbatim


@noindent @b{Notes}:@*
@*

@cartouche
@example

(slist) ldaplist(@var{uri},@var{dn},@var{filter},@var{name},@var{scope},@var{security})

@end example
@end cartouche

This function retrieves a single field from all matching LDAP records identified by the search
parameters.

@noindent @b{ARGUMENTS}:

@table @samp
@item uri
String value of the ldap server. e.g. @code{"ldap://ldap.cfengine.com.no"}
@item dn
Distinguished name, an ldap formatted name built from components, e.g. "dc=cfengine,dc=com".
@item filter
String filter criterion, in ldap search, e.g. "(sn=User)".
@item name
String value, the name of a single record to be retrieved, e.g. @code{uid}.
@item scope
Menu option, the type of ldap search, from the specified root. May take values:
@smallexample
    subtree
    onelevel
    base
@end smallexample

@item security
Menu option indicating the encryption and authentication settings
for communication with the LDAP server. These features might be subject
to machine and server capabilites.
@smallexample
     none
     ssl
     sasl
@end smallexample
@end table

@node Function ldapvalue, Function now, Function ldaplist, Special functions
@section Function ldapvalue 


@noindent @b{Synopsis}: ldapvalue(6 args) returns type string


@noindent Extract the first matching named value from ldap


@noindent @b{Example}:@*
@*

@verbatim

vars:

   # Get the first matching value for "uid" in schema

  "value" string => ldapvalue(
                             "ldap://ldap.example.org", 
                             "dc=cfengine,dc=com",
                             "(sn=User)",
                             "uid",
                             "subtree",
                             "none"
                             );

@end verbatim


@noindent @b{Notes}:@*
@*


@cartouche
@example

(string) ldapvalue(@var{uri},@var{dn},@var{filter},@var{name},@var{scope},@var{security})

@end example
@end cartouche

This function retrieves a single field from a single LDAP record identified by the search
parameters. The first matching value it taken.

@noindent @b{ARGUMENTS}:

@table @samp
@item uri
String value of the ldap server. e.g. @code{"ldap://ldap.cfengine.com.no"}
@item dn
Distinguished name, an ldap formatted name built from components, e.g. "dc=cfengine,dc=com".
@item filter
String filter criterion, in ldap search, e.g. "(sn=User)".
@item name
String value, the name of a single record to be retrieved, e.g. @code{uid}.
@item scope
Menu option, the type of ldap search, from the specified root. May take values:
@smallexample
    subtree
    onelevel
    base
@end smallexample
@end table

@node Function now, Function on, Function ldapvalue, Special functions
@section Function now 


@noindent @b{Synopsis}: now(0 args) returns type int


@noindent Convert the current time into system representation


@noindent @b{Example}:@*
@*

@verbatim

body file_select zero_age
{
mtime       => irange(ago(1,0,0,0,0,0),now);
file_result => "mtime";
}

@end verbatim


@noindent @b{Notes}:@*
@*


@node Function on, Function peers, Function now, Special functions
@section Function on 


@noindent @b{Synopsis}: on(6 args) returns type int


@noindent Convert an exact date/time to an integer system representation


@noindent @b{Example}:@*
@*

@verbatim

body file_select zero_age
{
mtime       => irange(on(2000,1,1,0,0,0),now);
file_result => "mtime";
}

@end verbatim


@noindent @b{Notes}:@*
@*

An absolute date. 
Note that in process matching dates could be wrong by an hour
depending on Daylight Savings Time / Summer Time. This is a known bug to be fixed.

@noindent @b{ARGUMENTS}:

@table @samp
@item Years
The year, e.g. 2009
@item Month
The Month, 1-12
@item Day
The day 1-31
@item Hours
The hour 0-23
@item Minutes
The minutes
0-59
@item Seconds
The number of seconds 0-59
@end table

@node Function peers, Function peerleader, Function on, Special functions
@section Function peers 


@noindent @b{Synopsis}: peers(3 args) returns type slist


@noindent Get a list of peers (not including ourself) from the partition to which we belong


@noindent @b{Example}:@*
@*

@verbatim

bundle agent peers
{
vars:

  "mygroup" slist => peers("/tmp/hostlist","#.*",4);

  "myleader" string => peerleader("/tmp/hostlist","#.*",4);

  "all_leaders" slist => peerleaders("/tmp/hostlist","#.*",4);

reports:

 linux::

   "mypeer $(mygroup)";
   "myleader $(myleader)";
   "another leader $(all_leaders)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

@cartouche
@example

(slist) peers(@var{file of hosts},@var{comment pattern},@var{group size});

@end example
@end cartouche

This function returns a list of hostnames that may be considered peers
of the current host. Peers are defined according to a list of hosts,
provided as a file in the first argument. This file should contain a
list (one per line), possible with comments, of fully qualified host
names. Cfengine breaks up this list into non-overlapping groups of up to
@var{groupsize}, each of which has a leader which is the first host
in the group.


The current host should belong to this file if it is expected to interact
with the others. The function returns nothing if the host does not belong
to the list.

@noindent @b{ARGUMENTS}:

@table @samp
@item File of hosts
A path to a list of hosts.
@item Comment pattern
A pattern that matches a legal comment in the file
@item Group size
A number between 2 and 64 which represents the number of peers in a peer-group.
An arbitary limit of 64 is set on groups to avoid nonsensical promises.
@end table


Example file:

@smallexample
one
two
three # this is a comment
four
five
six
seven
eight
nine
ten
eleven
twelve
etc

@end smallexample

@node Function peerleader, Function peerleaders, Function peers, Special functions
@section Function peerleader 


@noindent @b{Synopsis}: peerleader(3 args) returns type string


@noindent Get the assigned peer-leader of the partition to which we belong


@noindent @b{Example}:@*
@*

@verbatim
bundle agent peers
{
vars:

  "mygroup" slist => peers("/tmp/hostlist","#.*",4);

  "myleader" string => peerleader("/tmp/hostlist","#.*",4);

  "all_leaders" slist => peerleaders("/tmp/hostlist","#.*",4);

reports:

 linux::

   "mypeer $(mygroup)";
   "myleader $(myleader)";
   "another leader $(all_leaders)";

}
@end verbatim


@noindent @b{Notes}:@*
@*


@cartouche
@example

(string) peerleader(@var{file of hosts},@var{comment pattern},@var{group size});

@end example
@end cartouche

This function returns the name of a ost that may be considered the
leader of a group of peers of the current host. Peers are defined
according to a list of hosts, provided as a file in the first
argument. This file should contain a list (one per line), possible
with comments, of fully qualified host names. Cfengine breaks up this
list into non-overlapping groups of up to @var{groupsize}, each of
which has a leader which is the first host in the group.

The current host should belong to this file if it is expected to interact
with the others. The function returns nothing if the host does not belong
to the list.

@noindent @b{ARGUMENTS}:

@table @samp
@item File of hosts
A path to a list of hosts.
@item Comment pattern
A pattern that matches a legal comment in the file
@item Group size
A number between 2 and 64 which represents the number of peers in a peer-group.
An arbitary limit of 64 is set on groups to avoid nonsensical promises.
@end table

Example file:

@smallexample
one
two
three # this is a comment
four
five
six
seven
eight
nine
ten
eleven
twelve
etc

@end smallexample

@node Function peerleaders, Function randomint, Function peerleader, Special functions
@section Function peerleaders 


@noindent @b{Synopsis}: peerleaders(3 args) returns type slist


@noindent Get a list of peer leaders from the named partitioning


@noindent @b{Example}:@*
@*

@verbatim
bundle agent peers
{
vars:

  "mygroup" slist => peers("/tmp/hostlist","#.*",4);

  "myleader" string => peerleader("/tmp/hostlist","#.*",4);

  "all_leaders" slist => peerleaders("/tmp/hostlist","#.*",4);

reports:

 linux::

   "mypeer $(mygroup)";
   "myleader $(myleader)";
   "another leader $(all_leaders)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

@cartouche
@example

(slist) peers(@var{file of hosts},@var{comment pattern},@var{group size});

@end example
@end cartouche

This function returns a list of hostnames that may be considered peer
leaders in the partitioning scheme described in the file of
hosts. Peers are defined according to a list of hosts, provided as a
file in the first argument. This file should contain a list (one per
line), possible with comments, of fully qualified host names. Cfengine
breaks up this list into non-overlapping groups of up to
@var{groupsize}, each of which has a leader which is the first host in
the group.

The current host need not belong to this file.

@noindent @b{ARGUMENTS}:

@table @samp
@item File of hosts
A path to a list of hosts.
@item Comment pattern
A pattern that matches a legal comment in the file
@item Group size
A number between 2 and 64 which represents the number of peers in a peer-group.
An arbitary limit of 64 is set on groups to avoid nonsensical promises.
@end table


Example file:

@smallexample
one
two
three # this is a comment
four
five
six
seven
eight
nine
ten
eleven
twelve
etc

@end smallexample

@node Function randomint, Function readfile, Function peerleaders, Special functions
@section Function randomint 


@noindent @b{Synopsis}: randomint(2 args) returns type int


@noindent Generate a random integer between the given limits


@noindent @b{Example}:@*
@*

@verbatim

vars:

 "ran"    int => randomint(4,88);

@end verbatim


@noindent @b{Notes}:@*
@*

The limits must be integer values and the resulting numbers are based
on the entropy of the md5 algorithm.

@node Function readfile, Function readintarray, Function randomint, Special functions
@section Function readfile 


@noindent @b{Synopsis}: readfile(2 args) returns type string


@noindent Read max number of bytes from named file and assign to variable


@noindent @b{Example}:@*
@*

@verbatim

vars:

 "xxx"   

    string => readfile( "/home/mark/tmp/testfile" , "33" );

@end verbatim


@noindent @b{Notes}:@*
@*

The file (fragment) is read into a single scalar variable.

@node Function readintarray, Function readintlist, Function readfile, Special functions
@section Function readintarray 


@noindent @b{Synopsis}: readintarray(6 args) returns type int


@noindent Read an array of integers from a file and assign the dimension to a variable


@noindent @b{Example}:@*
@*

@verbatim
vars:

  "dim_array" 

     int =>  readintarray("array_name","/tmp/array","#[^\n]*",":",10,4000);

@end verbatim



@noindent @b{Notes}:@*
@*

Reads a two dimensional array from a file. One dimension is separated by
the character specified in the argument, the other by the the lines in the file.
The first field of the lines names the first array argument.

@smallexample

1: 5:7:21:13
2:19:8:14:14
3:45:1:78:22
4:64:2:98:99
@end smallexample

@noindent Results in

@smallexample
array_name[1][0]   1
array_name[1][1]   5
array_name[1][2]   7
array_name[1][3]   21
array_name[1][4]   13
array_name[2][0]   2
array_name[2][1]   19
array_name[2][2]   8
array_name[2][3]   14
array_name[2][4]   14
array_name[3][0]   3
array_name[3][1]   45
array_name[3][2]   1
array_name[3][3]   78
array_name[3][4]   22
array_name[4][0]   4
array_name[4][1]   64
array_name[4][2]   2
array_name[4][3]   98
array_name[4][4]   99
@end smallexample

@node Function readintlist, Function readrealarray, Function readintarray, Special functions
@section Function readintlist 


@noindent @b{Synopsis}: readintlist(5 args) returns type ilist


@noindent Read and assign a list variable from a file of separated ints


@noindent @b{Example}:@*
@*

@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "mylist" ilist => { readintlist("/tmp/listofint","#.*","[\n]",10,400) };

reports:

  Yr2008::

    "List entry: $(mylist)";

}

@end verbatim


@noindent @b{ARGUMENTS}:

@table @samp
@item filename
The name of a text file containing text to be split up as a list.
@item comment
A regex pattern which is to be ignored in the file
@item split
A regex pattern which is to be used to split up the file into items
@item maxent
The maximum number of list items to read from the file
@item maxsize
The maximum number of bytes to read from the file
@end table


@noindent @b{Notes}:@*
@*


@node Function readrealarray, Function readreallist, Function readintlist, Special functions
@section Function readrealarray 


@noindent @b{Synopsis}: readrealarray(6 args) returns type int


@noindent Read an array of real numbers from a file and assign the dimension to a variable


@noindent @b{Example}:@*
@*

@verbatim
vars:

  "dim_array" 

     int =>  readrealarray("array_name","/tmp/array","#[^\n]*",":",10,4000);

@end verbatim



@noindent @b{Notes}:@*
@*


See the notes for @code{readintarray}.

@node Function readreallist, Function readstringarray, Function readrealarray, Special functions
@section Function readreallist 


@noindent @b{Synopsis}: readreallist(5 args) returns type rlist


@noindent Read and assign a list variable from a file of separated real numbers


@noindent @b{Example}:@*
@*

@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "mylist" ilist => { readreallist("/tmp/listofreal","#.*","[\n]",10,400) };

reports:

  Yr2008::

    "List entry: $(mylist)";

}

@end verbatim


@noindent @b{ARGUMENTS}:

@table @samp
@item filename
The name of a text file containing text to be split up as a list.
@item comment
A regex pattern which is to be ignored in the file
@item split
A regex pattern which is to be used to split up the file into items
@item maxent
The maximum number of list items to read from the file
@item maxsize
The maximum number of bytes to read from the file
@end table


@noindent @b{Notes}:@*
@*

@node Function readstringarray, Function readstringlist, Function readreallist, Special functions
@section Function readstringarray 


@noindent @b{Synopsis}: readstringarray(6 args) returns type int


@noindent Read an array of strings from a file and assign the dimension to a variable


@noindent @b{Example}:@*
@*


@verbatim
vars:

  "dim_array" 

     int =>  readstringarray("array_name","/tmp/array","#[^\n]*",":",10,4000);

@end verbatim

@noindent Returns an integer number of keys in the array.

@noindent @b{ARGUMENTS}:

@table @samp
@item array_name
The name to be used for the container array.
@item filename
The name of a text file containing text to be split up as a list.
@item comment
A regex pattern which is to be ignored in the file
@item split
A regex pattern which is to be used to split up the file into items
@item maxent
The maximum number of list items to read from the file
@item maxsize
The maximum number of bytes to read from the file
@end table


@noindent @b{Notes}:@*
@*



Reads a two dimensional array from a file. One dimension is separated by
the character specified in the argument, the other by the the lines in the file.
The first field of the lines names the first array argument.

@smallexample

at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash
avahi:x:103:105:User for Avahi:/var/run/avahi-daemon:/bin/false
beagleindex:x:104:106:User for Beagle indexing:/var/cache/beagle:/bin/bash
bin:x:1:1:bin:/bin:/bin/bash
daemon:x:2:2:Daemon:/sbin:/bin/bash

@end smallexample

@noindent Results in a systematically indexed map of the file. Some samples
are show below to illustrate the pattern.

@smallexample
...
array_name[daemon][0]   daemon
array_name[daemon][1]   x
array_name[daemon][2]   2
array_name[daemon][3]   2
array_name[daemon][4]   Daemon
array_name[daemon][5]   /sbin
array_name[daemon][6]   /bin/bash
...
array_name[at][3]       25
array_name[at][4]       Batch jobs daemon
array_name[at][5]       /var/spool/atjobs
array_name[at][6]       /bin/bash
...
array_name[games][3]    100
array_name[games][4]    Games account
array_name[games][5]    /var/games
array_name[games][6]    /bin/bash
...

@end smallexample

@node Function readstringlist, Function readtcp, Function readstringarray, Special functions
@section Function readstringlist 


@noindent @b{Synopsis}: readstringlist(5 args) returns type slist


@noindent Read and assign a list variable from a file of separated strings


@noindent @b{Example}:@*
@*


@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
vars:

  "mylist" ilist => { readstringlist("/tmp/listofint","#.*","[\n]",10,400) };

reports:

  Yr2008::

    "List entry: $(mylist)";

}

@end verbatim


@noindent @b{ARGUMENTS}:

@table @samp
@item filename
The name of a text file containing text to be split up as a list.
@item comment
A regex pattern which is to be ignored in the file
@item split
A regex pattern which is to be used to split up the file into items
@item maxent
The maximum number of list items to read from the file
@item maxsize
The maximum number of bytes to read from the file
@end table



@noindent @b{Notes}:@*
@*

The following example file would be split into a list of the
first ten Green letters.

@smallexample

alpha
beta
gamma # This is a comment
delta
epsilon
zeta
eta
theta
iota
kappa
lambda
mu
nu
etc


@end smallexample

@node Function readtcp, Function regarray, Function readstringlist, Special functions
@section Function readtcp 


@noindent @b{Synopsis}: readtcp(4 args) returns type string


@noindent Connect to tcp port, send string and assign result to variable


@noindent @b{Example}:@*
@*

@verbatim

bundle agent example

{     
vars:

  "my80" string => readtcp("research.iu.hio.no","80","GET /index.php HTTP/1.1$(const.r)$(const.n)Host: research.iu.hio.no$(const.r)$(const.n)$(const.r)$(const.n)",20);

classes:

  "server_ok" expression => regcmp(".*200 OK.*\n.*","$(my80)");

reports:

  server_ok::

    "Server is alive";

  !server_ok::

    "Server is not responding - got $(my80)";
}

@end verbatim

@table @samp
@item hostnameip
The host name or IP address of a tcp socket.
@item port
The port number to connect to.
@item sendstring
A string to send to the TCP port to illicit a response
@item maxbytes
The maximum number of bytes to read in response.
@end table

Important note: not all Unix TCP read operations respond to signals for interruption so
poorly formed requests can hang. Always test TCP connections fully before deploying.
When matching multi-line responses, not that regular expressions do not cross newline
boundaries.


@noindent @b{Notes}:@*
@*

If the send string is empty, no data are sent or received from the socket. Then the
function only tests whether the TCP port is alive and returns an empty variable.

Note that on some systems the timeout mechanism does not seem to successfully interrupt
the waiting system calls so this might hang if you send a query string that is incorrect.
This should not happen, but the cause has yet to be diagnosed.

@node Function regarray, Function regcmp, Function readtcp, Special functions
@section Function regarray 


@noindent @b{Synopsis}: regarray(2 args) returns type class


@noindent True if arg1 matches any item in the associative array with id=arg2


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "testbundle"  };
}

###########################################

bundle agent testbundle
{
vars:

  "myarray[0]" string => "bla1";
  "myarray[1]" string => "bla2";
  "myarray[3]" string => "bla";
  "myarray"    string => "345";  
  "not"        string => "345";  

classes:

  "ok" expression => regarray("myarray","b.*2");

reports:

 ok::

    "Found in list";

 !ok::

    "Not found in list";

}

@end verbatim


@noindent @b{Notes}:@*
@*

Tests whether an associative array contains elements matching a certain regular expression.
The result is a class.

@noindent @b{ARGUMENTS}:

@table @samp
@item array_name
The name of the array, with no @samp{$()} surrounding, etc.
@item regex
A regular expression to match the content.
@end table

@node Function regcmp, Function registryvalue, Function regarray, Special functions
@section Function regcmp 


@noindent @b{Synopsis}: regcmp(2 args) returns type class


@noindent True if arg2 is a regular expression matching arg1


@noindent @b{Example}:@*
@*

@verbatim

bundle agent subtest(user)

{
classes:

  "invalid" not => regcmp("[a-z][a-z][a-z][a-z]","$(user)");

reports:

 !invalid::

  "User name $(user) is valid at 4 letters";

 invalid::

  "User name $(user) is invalid";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Compares a string to a regular expression.

@noindent @b{ARGUMENTS}:

@table @samp
@item regex
A regular expression to match the test data.
@item string
Test data for the regular expression.
@end table

If there are multiple-lines in the data, it is necessary to code these explicitely
as regular expressions do not nomally match the end of line as a regular character.
e.g.

@smallexample

body common control
@{
bundlesequence => @{ "example" @};
@}

bundle agent example
@{
vars:

  "x" string => "
NAME: apache2 - Apache 2.2 web server
CATEGORY: application
ARCH: all
VERSION: 2.2.3,REV=2006.09.01
BASEDIR: /
VENDOR: http://httpd.apache.org/ packaged for CSW by Cory Omand
PSTAMP: comand@@thor-20060901022929
INSTDATE: Dec 14 2006 16:05
HOTLINE: http://www.blastwave.org/bugtrack/
EMAIL: comand@@blastwave.org
STATUS: completely installed
";

classes:

"pkg_installed" expression => regcmp("(.*\n)*STATUS:\s+completely installed.*\n.*",$(x));

reports:

  pkg_installed::

    "yes"; 
@}


@end smallexample 

@node Function registryvalue, Function regline, Function regcmp, Special functions
@section Function registryvalue 


@noindent @b{Synopsis}: registryvalue(2 args) returns type string


@noindent Returns a value for an MS-Win registry key,value pair


@noindent @b{Example}:@*
@*

@verbatim

bundle agent reg
{
vars:

  "value" string => registryvalue("HKEY_LOCAL_MACHINE\SOFTWARE\Cfengine AS\Cfengine","value3");

reports:

  WinXP::

   "Value extracted: $(value)";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This function applies only to Windows based systems. it reads a data field for the value named
in the second argument, which lies within the registry key given by the first argument.

@node Function regline, Function reglist, Function registryvalue, Special functions
@section Function regline 


@noindent @b{Synopsis}: regline(2 args) returns type class


@noindent True if arg2 is a regular expression matching a line in file arg1


@noindent @b{Example}:@*
@*

@verbatim

bundle agent testbundle

{
files:

  "/tmp/testfile" edit_line => test;
}

########################################################

bundle edit_line test
{
classes:

    "ok" expression => regline(".*XYZ.*","$(edit.filename)");

reports:

 ok::

   "File $(edit.filename) has a line with \"XYZ\" in it";

}

@end verbatim


@noindent @b{Notes}:@*
@*

Note that the regular expression must match an entire line of the
file in order to give a true result. This function is useful for
editfiles applications, where one might want to set a class for
detecting the presence of a string which does not exactly match
one being inserted. e.g.

@verbatim

bundle edit_line upgrade_cfexecd
  {
  classes:

    # Check there is not already a crontab line, not identical to
    # the one proposed below...

    "exec_fix" not => regline(".*cf-execd.*","$(edit.filename)");

  insert_lines:

    exec_fix::

     "0,5,10,15,20,25,30,35,40,45,50,55 * * * * /var/cfengine/bin/cf-execd -F";

  reports:

    exec_fix::

     "Added a 5 minute schedule to crontabs";
  }

@end verbatim

@node Function reglist, Function regldap, Function regline, Special functions
@section Function reglist 


@noindent @b{Synopsis}: reglist(2 args) returns type class


@noindent True if arg2 matches any item in the list with id=arg1


@noindent @b{Example}:@*
@*

@verbatim

vars:

 "nameservers" slist => {
                        "128.39.89.10",
                        "128.39.74.16",
                        "192.168.1.103"
                        };
classes:

  "am_name_server" expression => reglist("@(nameservers)","$(sys.ipv4[eth0])");

@end verbatim



@noindent @b{Notes}:@*
@*

Matches a list of test strings to a regular expression.

@noindent @b{ARGUMENTS}:

@table @samp

@item list
The list of strings.
@item regex
The scalar regular expression string.
@end table

@node Function regldap, Function remotescalar, Function reglist, Special functions
@section Function regldap 


@noindent @b{Synopsis}: regldap(7 args) returns type class


@noindent True if arg6 is a regular expression matching a value item in an ldap search


@noindent @b{Example}:@*
@*

@verbatim

classes:

   "found" expression => regldap(
                                "ldap://ldap.example.org",
                                "dc=cfengine,dc=com",
                                "(sn=User)",
                                "uid",
                                "subtree",
                                "jon.*",
                                "none"
                                );

@end verbatim


@noindent @b{Notes}:@*
@*


@cartouche
@example

(class) regldap(@var{uri},@var{dn},@var{filter},@var{name},@var{scope},@var{regex},@var{security})

@end example
@end cartouche

This function retrieves a single field from all matching LDAP records identified by the search
parameters and compares it to a regular expression. If there is a match, true is returned
else false.

@noindent @b{ARGUMENTS}:

@table @samp
@item uri
String value of the ldap server. e.g. @code{"ldap://ldap.cfengine.com.no"}
@item dn
Distinguished name, an ldap formatted name built from components, e.g. "dc=cfengine,dc=com".
@item filter
String filter criterion, in ldap search, e.g. "(sn=User)".
@item name
String value, the name of a single record to be retrieved, e.g. @code{uid}.
@item scope
Menu option, the type of ldap search, from the specified root. May take values:
@smallexample
    subtree
    onelevel
    base
@end smallexample

@item regex
A regular expression string to match to the results of an LDAP search. If any
item matches, the result will be true.

@item security
Menu option indicating the encryption and authentication settings
for communication with the LDAP server. These features might be subject
to machine and server capabilites.
@smallexample
     none
     ssl
     sasl
@end smallexample
@end table
     

@node Function remotescalar, Function returnszero, Function regldap, Special functions
@section Function remotescalar 


@noindent @b{Synopsis}: remotescalar(3 args) returns type string


@noindent Read a scalar value from a remote cfengine server


@noindent @b{Example}:@*
@*

@verbatim

vars:

 "remote" string => remotescalar("test_scalar","127.0.0.1","yes");

@end verbatim


@noindent @b{Notes}:@*
@*

@cartouche
@example

(string) remotescalar(@var{resource handle},@var{host/IP address},@var{encrypt});

@end example
@end cartouche

This function downloads a string from a remote server, using the promise handle
as a variable identifier. Availability: Enterprise editions of Cfengine only.

@noindent @b{ARGUMENTS}:

@table @samp
@item resource handle
The name of the promise on the server side
@item host or IP address
The location of the server on which the resource resides.
@item encrypt
Whether to encrypt the connection to the server.
@smallexample
     true
     yes
     false
     no
@end smallexample
@end table

@node Function returnszero, Function rrange, Function remotescalar, Special functions
@section Function returnszero 


@noindent @b{Synopsis}: returnszero(2 args) returns type class


@noindent True if named shell command has exit status zero


@noindent @b{Example}:@*
@*


@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "my_result" expression => returnszero("/usr/local/bin/mycommand","noshell");

reports:

  !my_result::

    "Command failed";

}

@end verbatim


@noindent @b{Notes}:@*
@*

This is the complement of @code{execresult}, but it returns a class
result rather than the output of the command.

@node Function rrange, Function selectservers, Function returnszero, Special functions
@section Function rrange 


@noindent @b{Synopsis}: rrange(2 args) returns type rrange [real,real]


@noindent Define a range of real numbers for cfengine internal use


@noindent @b{Example}:@*
@*

@verbatim

?

@end verbatim


@noindent @b{Notes}:@*
@*

This is not yet used.

@node Function selectservers, Function splayclass, Function rrange, Special functions
@section Function selectservers 


@noindent @b{Synopsis}: selectservers(6 args) returns type int


@noindent Select tcp servers which respond correctly to a query and return their number, set array of names


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "test"  };
}

###########################################################

bundle agent test

{     
vars:

 "hosts" slist => { "slogans.iu.hio.no", "eternity.iu.hio.no", "nexus.iu.hio.no" };
 
 "up_servers" int =>  selectservers("@(hosts)","80","","","100","alive_servers");

classes:

  "someone_alive" expression => isgreaterthan("$(up_servers)","0");

  "i_am_a_server" expression => regarray("up_servers","$(host)|$(fqhost)");

reports:

  someone_alive::

    "Number of active servers $(up_servers)";
    "First server $(alive_servers[0]) fails over to $(alive_servers[1])";

}

@end verbatim


@noindent @b{Notes}:@*
@*


This function selects all the TCP ports that are active and
functioning from an ordered list and builds an array of their names.
This allows us to select a current list of failover alternatives
that are pretested.

@table @samp
@item hostlist
A list of host names or IP addresses to attempt to connect to.
@item port
The port number for the service.
@item sendstr
An optional string to send to the server to illicit a response.
@item regex_on_reply
If a string is sent, this regex must match the resulting reply.
@item maxbytesread_reply
The maximum number of bytes to read as the server's reply.
@item array_name
The name of the array to build containing the names of hosts
that pass the above tests. The array is ordered @code{array_name[0],..} etc.
@end table

@node Function splayclass, Function splitstring, Function selectservers, Special functions
@section Function splayclass 


@noindent @b{Synopsis}: splayclass(2 args) returns type class


@noindent True if the first argument's time-slot has arrived, according to a policy in arg2


@noindent @b{Example}:@*
@*


@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "my_result" expression => splayclass("$(sys.host)$(sys.ipv4)","daily");

reports:

  my_result::

    "Load balanced class activated";

}

@end verbatim


@noindent @b{Notes}:@*
@*


The lvalue class evaluates to true if the system clock lies within a scheduled
time-interval that maps to a hash of the first argument. Different strings will
hash to different time intervals, and thus one can map tasks to time-intervals.

This function may be used to distribute a task in time over a day or
an hourly period, depending on the policy in the second argument.
This is useful for copying resources from a single server, e.g.
software updates when simultaneous scheduling would lead to a bottleneck.

The function is similar to the splaytime feature in cf-execd, except
that it allows you to base the decision on any string-criterion on a
give host.  The entropy (or string-variation) in the first argument
determines how effectively cfengine will be able to distribute tasks.
Cfengine instances with the same first argument will yield a true
result at the same time. Thus tasks could be scheduled according to
group names for predictability.


@node Function splitstring, Function strcmp, Function splayclass, Special functions
@section Function splitstring 


@noindent @b{Synopsis}: splitstring(3 args) returns type slist


@noindent Convert a string in arg1 into a list of max arg3 strings by splitting on a regular expression in arg2


@noindent @b{Example}:@*
@*

@verbatim

bundle agent test

{
vars:

  "split1" slist => splitstring("one:two:three",":","10");
  "split2" slist => splitstring("alpha:xyz:beta","xyz","10");

reports:

 linux::

  "Found key $(split1)";
  "Found key $(split2)";

}

@end verbatim

@noindent Returns a list of strings from a string.

@noindent @b{ARGUMENTS}:

@table @samp
@item string
The string to be split.
@item regex
A regular expression that is to be the delimiter.
@item maxent
The maximum number of list items to be created.
@end table


@noindent @b{Notes}:@*
@*
 
If the maximum number is insufficient to accomodate all entries, the
final entry will contain the rest of the string.

@node Function strcmp, Function usemodule, Function splitstring, Special functions
@section Function strcmp 


@noindent @b{Synopsis}: strcmp(2 args) returns type class


@noindent True if the two strings match exactly


@noindent @b{Example}:@*
@*

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "same" expression => strcmp("test","test");

reports:

  same::

    "Strings are equal";

 !same::

    "Strings are not equal";
}

@end verbatim


@noindent @b{Notes}:@*
@*

@node Function usemodule, Function userexists, Function strcmp, Special functions
@section Function usemodule 


@noindent @b{Synopsis}: usemodule(2 args) returns type class


@noindent Execute cfengine module script and set class if successful


@noindent @b{Example}:@*
@*


@verbatim

body common control
   {
   any::

      bundlesequence  => {
                         test
                         };
   }

###################################################################

bundle agent test

{
classes:

  # returns $(user)

  "done" expression => usemodule("getusers","");

commands:

  "/bin/echo promiser text" args => "test $(user)";
}

@end verbatim


@noindent @b{Notes}:@*
@*

Modules must reside in @file{WORKDIR/modules} but no longer require
a special naming convention.

@noindent @b{ARGUMENTS}:

@table @samp

@item Module name
The name of the module without its leading path, since it is assuemed
to be in the registered modules directory.

@item Argument string
Any command link arguments to pass to the module.

@end table

@node Function userexists,  , Function usemodule, Special functions
@section Function userexists 


@noindent @b{Synopsis}: userexists(1 args) returns type class


@noindent True if user name or numerical id exists on this host


@noindent @b{Example}:@*
@*

@verbatim


body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{     
classes:

  "ok" expression => userexists("root");

reports:

  ok::

    "Root exists";

 !ok::

    "Root does not exist";
}


@end verbatim


@noindent @b{Notes}:@*
@*

Checks whether the user is in the password database for the current host.
The argument must be a user name or user id.

@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Special Variables, Logs and records, Special functions, Top
@chapter Special Variables



@menu
* Variable context const::      
* Variable context sys::        
* Variable context mon::        
@end menu

@node Variable context const, Variable context sys, Special Variables, Special Variables
@section Variable context @code{const}

@*

Cfengine defines a number of variables for embedding unprintable values 
or values with special meanings in strings.

@menu
* Variable const.dollar::       
* Variable const.endl::         
* Variable const.n::            
* Variable const.r::            
@end menu

@node Variable const.dollar, Variable const.endl, Variable context const, Variable context const
@subsection Variable const.dollar 

@*

@verbatim

reports:

  some::

   "The value of $(const.dollar)(const.dollar) is $(const.dollar)";

   "But the value of \$(dollar) is \$(dollar)";

@end verbatim

@node Variable const.endl, Variable const.n, Variable const.dollar, Variable context const
@subsection Variable const.endl 

@*

@verbatim

reports:

  "A newline with either $(const.endl) or with $(const.n) is ok";

@end verbatim

@node Variable const.n, Variable const.r, Variable const.endl, Variable context const
@subsection Variable const.n 

@*

@verbatim

reports:

  "A newline with either $(const.n) or with $(const.endl) is ok";

@end verbatim

@node Variable const.r,  , Variable const.n, Variable context const
@subsection Variable const.r 

@*

@verbatim

reports:

  "A carriage return character is $(const.r)";

@end verbatim



@node Variable context sys, Variable context mon, Variable context const, Special Variables
@section Variable context @code{sys}

@*

System variables are derived from cfengine's automated discovery of system values.
They are provided as variables in order to make automatically adaptive rules for
configuration, e.g.

@verbatim

files:

 any::

  "$(sys.resolv)"

      create        => "true",
      edit_line     => doresolv("@(this.list1)","@(this.list2)"),
      edit_defaults => reconstruct;

@end verbatim

@noindent The above rule requires no class specification because the
variable itself is class-specific.

@menu
* Variable sys.arch::           
* Variable sys.cdate::          
* Variable sys.class::          
* Variable sys.date::           
* Variable sys.domain::         
* Variable sys.fqhost::         
* Variable sys.fstab::          
* Variable sys.host::           
* Variable sys.long_arch::      
* Variable sys.maildir::        
* Variable sys.os::             
* Variable sys.ostype::         
* Variable sys.release::        
* Variable sys.resolv::         
* Variable sys.uqhost::         
* Variable sys.workdir::        
@end menu

@node Variable sys.arch, Variable sys.cdate, Variable context sys, Variable context sys
@subsection Variable sys.arch 

@*


The variable gives the kernel's short architecture description.

@verbatim

# arch = x86_64

@end verbatim

@node Variable sys.cdate, Variable sys.class, Variable sys.arch, Variable context sys
@subsection Variable sys.cdate 

@*

The date of the system in canonical form, i.e. in the form of a class.

@verbatim

# cdate = Sun_Dec__7_10_39_53_2008_

@end verbatim

@node Variable sys.class, Variable sys.date, Variable sys.cdate, Variable context sys
@subsection Variable sys.class 

@*

This variable contains the name of the hard-class category for this host, i.e. its
top level operating system type classification.

@verbatim

# class = linux

@end verbatim

@node Variable sys.date, Variable sys.domain, Variable sys.class, Variable context sys
@subsection Variable sys.date 

@*

The date of the system as a text string.

@verbatim

# date = Sun Dec  7 10:39:53 2008

@end verbatim

@node Variable sys.domain, Variable sys.fqhost, Variable sys.date, Variable context sys
@subsection Variable sys.domain 

@*

The domain name as divined by cfengine. If the DNS is in use, it could
be possible to derive the domain name from its DNS regisration, but in
general there is no way to discover this value automatically. The
@code{common control} body permits the ultimate specification of this
value.

@verbatim

# domain = example.org
 
@end verbatim

@node Variable sys.fqhost, Variable sys.fstab, Variable sys.domain, Variable context sys
@subsection Variable sys.fqhost 

@*

The fully qualified name of the host. In order to compute this value properly, the domain
name must be defined.

@verbatim

# fqhost = host.example.org

@end verbatim

@node Variable sys.fstab, Variable sys.host, Variable sys.fqhost, Variable context sys
@subsection Variable sys.fstab 

@*

The location of the system filesystem (mount) table.

@verbatim

# fstab = /etc/fstab

@end verbatim

@node Variable sys.host, Variable sys.long_arch, Variable sys.fstab, Variable context sys
@subsection Variable sys.host 

@*

The name of the current host, according to the kernel. It is undefined whether this
is qualified or unqualified with a domain name.

@verbatim

# host = myhost

@end verbatim

@node Variable sys.long_arch, Variable sys.maildir, Variable sys.host, Variable context sys
@subsection Variable sys.long_arch 

@*

The long architecture name for this system kernel. This name is sometimes quite unwieldy
but can be useful for logging purposes.

@verbatim

# long_arch = linux_x86_64_2_6_22_19_0_1_default__1_SMP_2008_10_14_22_17_43__0200

@end verbatim

@node Variable sys.maildir, Variable sys.os, Variable sys.long_arch, Variable context sys
@subsection Variable sys.maildir 

@*

The name of the system email spool directory.

@verbatim

# maildir = /var/spool/mail

@end verbatim

@node Variable sys.os, Variable sys.ostype, Variable sys.maildir, Variable context sys
@subsection Variable sys.os 

@*

The name of the operating system according to the kernel.

@verbatim

# os = linux

@end verbatim

@node Variable sys.ostype, Variable sys.release, Variable sys.os, Variable context sys
@subsection Variable sys.ostype 

@*

Another name for the operating system.

@verbatim

# ostype = linux_x86_64

@end verbatim

@node Variable sys.release, Variable sys.resolv, Variable sys.ostype, Variable context sys
@subsection Variable sys.release 

@*

The kernel release of the operating system.

@verbatim

# release = 2.6.22.19-0.1-default

@end verbatim

@node Variable sys.resolv, Variable sys.uqhost, Variable sys.release, Variable context sys
@subsection Variable sys.resolv 

@*

The location of the system resolver file.

@verbatim

# resolv = /etc/resolv.conf

@end verbatim

@node Variable sys.uqhost, Variable sys.workdir, Variable sys.resolv, Variable context sys
@subsection Variable sys.uqhost 

@*


The unqualified name of the current host. See also @code{sys.fqhost}.

@verbatim

# uqhost = myhost

@end verbatim

@node Variable sys.workdir,  , Variable sys.uqhost, Variable context sys
@subsection Variable sys.workdir 

@*

The location of the cfengine work directory and cache. For the
system privileged user this is normally:

@verbatim

# workdir = /var/cfengine

@end verbatim

For non-privileged users it is in the user's home directory:

@verbatim

# workdir = /home/user/.cfagent

@end verbatim



@node Variable context mon,  , Variable context sys, Special Variables
@section Variable context @code{mon}

@*

The variables discovered by @code{cf-monitord} are placed in this monitoring
context. Monitoring variables are expected to be ephemeral properties, rapidly changing.

In enterprise versions of cfengine, custom defined monitoring targets also become
variables in this context, named by the handle of the promise that defined them.


@menu
* Variable mon.value_users::    
* Variable mon.average_users::  
* Variable mon.stddev_users::   
* Variable mon.value_rootprocs::  
* Variable mon.average_rootprocs::  
* Variable mon.stddev_rootprocs::  
* Variable mon.value_otherprocs::  
* Variable mon.average_otherprocs::  
* Variable mon.stddev_otherprocs::  
* Variable mon.value_diskfree::  
* Variable mon.average_diskfree::  
* Variable mon.stddev_diskfree::  
* Variable mon.value_loadavg::  
* Variable mon.average_loadavg::  
* Variable mon.stddev_loadavg::  
* Variable mon.value_netbiosns_in::  
* Variable mon.average_netbiosns_in::  
* Variable mon.stddev_netbiosns_in::  
* Variable mon.value_netbiosns_out::  
* Variable mon.average_netbiosns_out::  
* Variable mon.stddev_netbiosns_out::  
* Variable mon.value_netbiosdgm_in::  
* Variable mon.average_netbiosdgm_in::  
* Variable mon.stddev_netbiosdgm_in::  
* Variable mon.value_netbiosdgm_out::  
* Variable mon.average_netbiosdgm_out::  
* Variable mon.stddev_netbiosdgm_out::  
* Variable mon.value_netbiosssn_in::  
* Variable mon.average_netbiosssn_in::  
* Variable mon.stddev_netbiosssn_in::  
* Variable mon.value_netbiosssn_out::  
* Variable mon.average_netbiosssn_out::  
* Variable mon.stddev_netbiosssn_out::  
* Variable mon.value_irc_in::   
* Variable mon.average_irc_in::  
* Variable mon.stddev_irc_in::  
* Variable mon.value_irc_out::  
* Variable mon.average_irc_out::  
* Variable mon.stddev_irc_out::  
* Variable mon.value_cfengine_in::  
* Variable mon.average_cfengine_in::  
* Variable mon.stddev_cfengine_in::  
* Variable mon.value_cfengine_out::  
* Variable mon.average_cfengine_out::  
* Variable mon.stddev_cfengine_out::  
* Variable mon.value_nfsd_in::  
* Variable mon.average_nfsd_in::  
* Variable mon.stddev_nfsd_in::  
* Variable mon.value_nfsd_out::  
* Variable mon.average_nfsd_out::  
* Variable mon.stddev_nfsd_out::  
* Variable mon.value_smtp_in::  
* Variable mon.average_smtp_in::  
* Variable mon.stddev_smtp_in::  
* Variable mon.value_smtp_out::  
* Variable mon.average_smtp_out::  
* Variable mon.stddev_smtp_out::  
* Variable mon.value_www_in::   
* Variable mon.average_www_in::  
* Variable mon.stddev_www_in::  
* Variable mon.value_www_out::  
* Variable mon.average_www_out::  
* Variable mon.stddev_www_out::  
* Variable mon.value_ftp_in::   
* Variable mon.average_ftp_in::  
* Variable mon.stddev_ftp_in::  
* Variable mon.value_ftp_out::  
* Variable mon.average_ftp_out::  
* Variable mon.stddev_ftp_out::  
* Variable mon.value_ssh_in::   
* Variable mon.average_ssh_in::  
* Variable mon.stddev_ssh_in::  
* Variable mon.value_ssh_out::  
* Variable mon.average_ssh_out::  
* Variable mon.stddev_ssh_out::  
* Variable mon.value_wwws_in::  
* Variable mon.average_wwws_in::  
* Variable mon.stddev_wwws_in::  
* Variable mon.value_wwws_out::  
* Variable mon.average_wwws_out::  
* Variable mon.stddev_wwws_out::  
* Variable mon.value_icmp_in::  
* Variable mon.average_icmp_in::  
* Variable mon.stddev_icmp_in::  
* Variable mon.value_icmp_out::  
* Variable mon.average_icmp_out::  
* Variable mon.stddev_icmp_out::  
* Variable mon.value_udp_in::   
* Variable mon.average_udp_in::  
* Variable mon.stddev_udp_in::  
* Variable mon.value_udp_out::  
* Variable mon.average_udp_out::  
* Variable mon.stddev_udp_out::  
* Variable mon.value_dns_in::   
* Variable mon.average_dns_in::  
* Variable mon.stddev_dns_in::  
* Variable mon.value_dns_out::  
* Variable mon.average_dns_out::  
* Variable mon.stddev_dns_out::  
* Variable mon.value_tcpsyn_in::  
* Variable mon.average_tcpsyn_in::  
* Variable mon.stddev_tcpsyn_in::  
* Variable mon.value_tcpsyn_out::  
* Variable mon.average_tcpsyn_out::  
* Variable mon.stddev_tcpsyn_out::  
* Variable mon.value_tcpack_in::  
* Variable mon.average_tcpack_in::  
* Variable mon.stddev_tcpack_in::  
* Variable mon.value_tcpack_out::  
* Variable mon.average_tcpack_out::  
* Variable mon.stddev_tcpack_out::  
* Variable mon.value_tcpfin_in::  
* Variable mon.average_tcpfin_in::  
* Variable mon.stddev_tcpfin_in::  
* Variable mon.value_tcpfin_out::  
* Variable mon.average_tcpfin_out::  
* Variable mon.stddev_tcpfin_out::  
* Variable mon.value_tcpmisc_in::  
* Variable mon.average_tcpmisc_in::  
* Variable mon.stddev_tcpmisc_in::  
* Variable mon.value_tcpmisc_out::  
* Variable mon.average_tcpmisc_out::  
* Variable mon.stddev_tcpmisc_out::  
* Variable mon.value_webaccess::  
* Variable mon.average_webaccess::  
* Variable mon.stddev_webaccess::  
* Variable mon.value_weberrors::  
* Variable mon.average_weberrors::  
* Variable mon.stddev_weberrors::  
* Variable mon.value_syslog::   
* Variable mon.average_syslog::  
* Variable mon.stddev_syslog::  
* Variable mon.value_messages::  
* Variable mon.average_messages::  
* Variable mon.stddev_messages::  
* Variable mon.value_temp0::    
* Variable mon.average_temp0::  
* Variable mon.stddev_temp0::   
* Variable mon.value_temp1::    
* Variable mon.average_temp1::  
* Variable mon.stddev_temp1::   
* Variable mon.value_temp2::    
* Variable mon.average_temp2::  
* Variable mon.stddev_temp2::   
* Variable mon.value_temp3::    
* Variable mon.average_temp3::  
* Variable mon.stddev_temp3::   
* Variable mon.value_cpu::      
* Variable mon.average_cpu::    
* Variable mon.stddev_cpu::     
* Variable mon.value_cpu0::     
* Variable mon.average_cpu0::   
* Variable mon.stddev_cpu0::    
* Variable mon.value_cpu1::     
* Variable mon.average_cpu1::   
* Variable mon.stddev_cpu1::    
* Variable mon.value_cpu2::     
* Variable mon.average_cpu2::   
* Variable mon.stddev_cpu2::    
* Variable mon.value_cpu3::     
* Variable mon.average_cpu3::   
* Variable mon.stddev_cpu3::    
@end menu

@node Variable mon.value_users, Variable mon.average_users, Variable context mon, Variable context mon
@subsection Variable mon.value_users 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Users logged in}.
@node Variable mon.average_users, Variable mon.stddev_users, Variable mon.value_users, Variable context mon
@subsection Variable mon.average_users 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Users logged in}.
@node Variable mon.stddev_users, Variable mon.value_rootprocs, Variable mon.average_users, Variable context mon
@subsection Variable mon.stddev_users 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Users logged in}.
@node Variable mon.value_rootprocs, Variable mon.average_rootprocs, Variable mon.stddev_users, Variable context mon
@subsection Variable mon.value_rootprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Privileged system processes}.
@node Variable mon.average_rootprocs, Variable mon.stddev_rootprocs, Variable mon.value_rootprocs, Variable context mon
@subsection Variable mon.average_rootprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Privileged system processes}.
@node Variable mon.stddev_rootprocs, Variable mon.value_otherprocs, Variable mon.average_rootprocs, Variable context mon
@subsection Variable mon.stddev_rootprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Privileged system processes}.
@node Variable mon.value_otherprocs, Variable mon.average_otherprocs, Variable mon.stddev_rootprocs, Variable context mon
@subsection Variable mon.value_otherprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Non-privileged process}.
@node Variable mon.average_otherprocs, Variable mon.stddev_otherprocs, Variable mon.value_otherprocs, Variable context mon
@subsection Variable mon.average_otherprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Non-privileged process}.
@node Variable mon.stddev_otherprocs, Variable mon.value_diskfree, Variable mon.average_otherprocs, Variable context mon
@subsection Variable mon.stddev_otherprocs 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Non-privileged process}.
@node Variable mon.value_diskfree, Variable mon.average_diskfree, Variable mon.stddev_otherprocs, Variable context mon
@subsection Variable mon.value_diskfree 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Free disk on / partition}.
@node Variable mon.average_diskfree, Variable mon.stddev_diskfree, Variable mon.value_diskfree, Variable context mon
@subsection Variable mon.average_diskfree 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Free disk on / partition}.
@node Variable mon.stddev_diskfree, Variable mon.value_loadavg, Variable mon.average_diskfree, Variable context mon
@subsection Variable mon.stddev_diskfree 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Free disk on / partition}.
@node Variable mon.value_loadavg, Variable mon.average_loadavg, Variable mon.stddev_diskfree, Variable context mon
@subsection Variable mon.value_loadavg 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{% kernel load utilization}.
@node Variable mon.average_loadavg, Variable mon.stddev_loadavg, Variable mon.value_loadavg, Variable context mon
@subsection Variable mon.average_loadavg 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{% kernel load utilization}.
@node Variable mon.stddev_loadavg, Variable mon.value_netbiosns_in, Variable mon.average_loadavg, Variable context mon
@subsection Variable mon.stddev_loadavg 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{% kernel load utilization}.
@node Variable mon.value_netbiosns_in, Variable mon.average_netbiosns_in, Variable mon.stddev_loadavg, Variable context mon
@subsection Variable mon.value_netbiosns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (in)}.
@node Variable mon.average_netbiosns_in, Variable mon.stddev_netbiosns_in, Variable mon.value_netbiosns_in, Variable context mon
@subsection Variable mon.average_netbiosns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (in)}.
@node Variable mon.stddev_netbiosns_in, Variable mon.value_netbiosns_out, Variable mon.average_netbiosns_in, Variable context mon
@subsection Variable mon.stddev_netbiosns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (in)}.
@node Variable mon.value_netbiosns_out, Variable mon.average_netbiosns_out, Variable mon.stddev_netbiosns_in, Variable context mon
@subsection Variable mon.value_netbiosns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (out)}.
@node Variable mon.average_netbiosns_out, Variable mon.stddev_netbiosns_out, Variable mon.value_netbiosns_out, Variable context mon
@subsection Variable mon.average_netbiosns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (out)}.
@node Variable mon.stddev_netbiosns_out, Variable mon.value_netbiosdgm_in, Variable mon.average_netbiosns_out, Variable context mon
@subsection Variable mon.stddev_netbiosns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name lookups (out)}.
@node Variable mon.value_netbiosdgm_in, Variable mon.average_netbiosdgm_in, Variable mon.stddev_netbiosns_out, Variable context mon
@subsection Variable mon.value_netbiosdgm_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (in)}.
@node Variable mon.average_netbiosdgm_in, Variable mon.stddev_netbiosdgm_in, Variable mon.value_netbiosdgm_in, Variable context mon
@subsection Variable mon.average_netbiosdgm_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (in)}.
@node Variable mon.stddev_netbiosdgm_in, Variable mon.value_netbiosdgm_out, Variable mon.average_netbiosdgm_in, Variable context mon
@subsection Variable mon.stddev_netbiosdgm_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (in)}.
@node Variable mon.value_netbiosdgm_out, Variable mon.average_netbiosdgm_out, Variable mon.stddev_netbiosdgm_in, Variable context mon
@subsection Variable mon.value_netbiosdgm_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (out)}.
@node Variable mon.average_netbiosdgm_out, Variable mon.stddev_netbiosdgm_out, Variable mon.value_netbiosdgm_out, Variable context mon
@subsection Variable mon.average_netbiosdgm_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (out)}.
@node Variable mon.stddev_netbiosdgm_out, Variable mon.value_netbiosssn_in, Variable mon.average_netbiosdgm_out, Variable context mon
@subsection Variable mon.stddev_netbiosdgm_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name datagrams (out)}.
@node Variable mon.value_netbiosssn_in, Variable mon.average_netbiosssn_in, Variable mon.stddev_netbiosdgm_out, Variable context mon
@subsection Variable mon.value_netbiosssn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (in)}.
@node Variable mon.average_netbiosssn_in, Variable mon.stddev_netbiosssn_in, Variable mon.value_netbiosssn_in, Variable context mon
@subsection Variable mon.average_netbiosssn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (in)}.
@node Variable mon.stddev_netbiosssn_in, Variable mon.value_netbiosssn_out, Variable mon.average_netbiosssn_in, Variable context mon
@subsection Variable mon.stddev_netbiosssn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (in)}.
@node Variable mon.value_netbiosssn_out, Variable mon.average_netbiosssn_out, Variable mon.stddev_netbiosssn_in, Variable context mon
@subsection Variable mon.value_netbiosssn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (out)}.
@node Variable mon.average_netbiosssn_out, Variable mon.stddev_netbiosssn_out, Variable mon.value_netbiosssn_out, Variable context mon
@subsection Variable mon.average_netbiosssn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (out)}.
@node Variable mon.stddev_netbiosssn_out, Variable mon.value_irc_in, Variable mon.average_netbiosssn_out, Variable context mon
@subsection Variable mon.stddev_netbiosssn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{netbios name sessions (out)}.
@node Variable mon.value_irc_in, Variable mon.average_irc_in, Variable mon.stddev_netbiosssn_out, Variable context mon
@subsection Variable mon.value_irc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (in)}.
@node Variable mon.average_irc_in, Variable mon.stddev_irc_in, Variable mon.value_irc_in, Variable context mon
@subsection Variable mon.average_irc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (in)}.
@node Variable mon.stddev_irc_in, Variable mon.value_irc_out, Variable mon.average_irc_in, Variable context mon
@subsection Variable mon.stddev_irc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (in)}.
@node Variable mon.value_irc_out, Variable mon.average_irc_out, Variable mon.stddev_irc_in, Variable context mon
@subsection Variable mon.value_irc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (out)}.
@node Variable mon.average_irc_out, Variable mon.stddev_irc_out, Variable mon.value_irc_out, Variable context mon
@subsection Variable mon.average_irc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (out)}.
@node Variable mon.stddev_irc_out, Variable mon.value_cfengine_in, Variable mon.average_irc_out, Variable context mon
@subsection Variable mon.stddev_irc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{IRC connections (out)}.
@node Variable mon.value_cfengine_in, Variable mon.average_cfengine_in, Variable mon.stddev_irc_out, Variable context mon
@subsection Variable mon.value_cfengine_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (in)}.
@node Variable mon.average_cfengine_in, Variable mon.stddev_cfengine_in, Variable mon.value_cfengine_in, Variable context mon
@subsection Variable mon.average_cfengine_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (in)}.
@node Variable mon.stddev_cfengine_in, Variable mon.value_cfengine_out, Variable mon.average_cfengine_in, Variable context mon
@subsection Variable mon.stddev_cfengine_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (in)}.
@node Variable mon.value_cfengine_out, Variable mon.average_cfengine_out, Variable mon.stddev_cfengine_in, Variable context mon
@subsection Variable mon.value_cfengine_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (out)}.
@node Variable mon.average_cfengine_out, Variable mon.stddev_cfengine_out, Variable mon.value_cfengine_out, Variable context mon
@subsection Variable mon.average_cfengine_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (out)}.
@node Variable mon.stddev_cfengine_out, Variable mon.value_nfsd_in, Variable mon.average_cfengine_out, Variable context mon
@subsection Variable mon.stddev_cfengine_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{cfengine connections (out)}.
@node Variable mon.value_nfsd_in, Variable mon.average_nfsd_in, Variable mon.stddev_cfengine_out, Variable context mon
@subsection Variable mon.value_nfsd_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (in)}.
@node Variable mon.average_nfsd_in, Variable mon.stddev_nfsd_in, Variable mon.value_nfsd_in, Variable context mon
@subsection Variable mon.average_nfsd_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (in)}.
@node Variable mon.stddev_nfsd_in, Variable mon.value_nfsd_out, Variable mon.average_nfsd_in, Variable context mon
@subsection Variable mon.stddev_nfsd_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (in)}.
@node Variable mon.value_nfsd_out, Variable mon.average_nfsd_out, Variable mon.stddev_nfsd_in, Variable context mon
@subsection Variable mon.value_nfsd_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (out)}.
@node Variable mon.average_nfsd_out, Variable mon.stddev_nfsd_out, Variable mon.value_nfsd_out, Variable context mon
@subsection Variable mon.average_nfsd_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (out)}.
@node Variable mon.stddev_nfsd_out, Variable mon.value_smtp_in, Variable mon.average_nfsd_out, Variable context mon
@subsection Variable mon.stddev_nfsd_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{nfs connections (out)}.
@node Variable mon.value_smtp_in, Variable mon.average_smtp_in, Variable mon.stddev_nfsd_out, Variable context mon
@subsection Variable mon.value_smtp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (in)}.
@node Variable mon.average_smtp_in, Variable mon.stddev_smtp_in, Variable mon.value_smtp_in, Variable context mon
@subsection Variable mon.average_smtp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (in)}.
@node Variable mon.stddev_smtp_in, Variable mon.value_smtp_out, Variable mon.average_smtp_in, Variable context mon
@subsection Variable mon.stddev_smtp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (in)}.
@node Variable mon.value_smtp_out, Variable mon.average_smtp_out, Variable mon.stddev_smtp_in, Variable context mon
@subsection Variable mon.value_smtp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (out)}.
@node Variable mon.average_smtp_out, Variable mon.stddev_smtp_out, Variable mon.value_smtp_out, Variable context mon
@subsection Variable mon.average_smtp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (out)}.
@node Variable mon.stddev_smtp_out, Variable mon.value_www_in, Variable mon.average_smtp_out, Variable context mon
@subsection Variable mon.stddev_smtp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{smtp connections (out)}.
@node Variable mon.value_www_in, Variable mon.average_www_in, Variable mon.stddev_smtp_out, Variable context mon
@subsection Variable mon.value_www_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (in)}.
@node Variable mon.average_www_in, Variable mon.stddev_www_in, Variable mon.value_www_in, Variable context mon
@subsection Variable mon.average_www_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (in)}.
@node Variable mon.stddev_www_in, Variable mon.value_www_out, Variable mon.average_www_in, Variable context mon
@subsection Variable mon.stddev_www_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (in)}.
@node Variable mon.value_www_out, Variable mon.average_www_out, Variable mon.stddev_www_in, Variable context mon
@subsection Variable mon.value_www_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (out)}.
@node Variable mon.average_www_out, Variable mon.stddev_www_out, Variable mon.value_www_out, Variable context mon
@subsection Variable mon.average_www_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (out)}.
@node Variable mon.stddev_www_out, Variable mon.value_ftp_in, Variable mon.average_www_out, Variable context mon
@subsection Variable mon.stddev_www_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{www connections (out)}.
@node Variable mon.value_ftp_in, Variable mon.average_ftp_in, Variable mon.stddev_www_out, Variable context mon
@subsection Variable mon.value_ftp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (in)}.
@node Variable mon.average_ftp_in, Variable mon.stddev_ftp_in, Variable mon.value_ftp_in, Variable context mon
@subsection Variable mon.average_ftp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (in)}.
@node Variable mon.stddev_ftp_in, Variable mon.value_ftp_out, Variable mon.average_ftp_in, Variable context mon
@subsection Variable mon.stddev_ftp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (in)}.
@node Variable mon.value_ftp_out, Variable mon.average_ftp_out, Variable mon.stddev_ftp_in, Variable context mon
@subsection Variable mon.value_ftp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (out)}.
@node Variable mon.average_ftp_out, Variable mon.stddev_ftp_out, Variable mon.value_ftp_out, Variable context mon
@subsection Variable mon.average_ftp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (out)}.
@node Variable mon.stddev_ftp_out, Variable mon.value_ssh_in, Variable mon.average_ftp_out, Variable context mon
@subsection Variable mon.stddev_ftp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ftp connections (out)}.
@node Variable mon.value_ssh_in, Variable mon.average_ssh_in, Variable mon.stddev_ftp_out, Variable context mon
@subsection Variable mon.value_ssh_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (in)}.
@node Variable mon.average_ssh_in, Variable mon.stddev_ssh_in, Variable mon.value_ssh_in, Variable context mon
@subsection Variable mon.average_ssh_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (in)}.
@node Variable mon.stddev_ssh_in, Variable mon.value_ssh_out, Variable mon.average_ssh_in, Variable context mon
@subsection Variable mon.stddev_ssh_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (in)}.
@node Variable mon.value_ssh_out, Variable mon.average_ssh_out, Variable mon.stddev_ssh_in, Variable context mon
@subsection Variable mon.value_ssh_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (out)}.
@node Variable mon.average_ssh_out, Variable mon.stddev_ssh_out, Variable mon.value_ssh_out, Variable context mon
@subsection Variable mon.average_ssh_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (out)}.
@node Variable mon.stddev_ssh_out, Variable mon.value_wwws_in, Variable mon.average_ssh_out, Variable context mon
@subsection Variable mon.stddev_ssh_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ssh connections (out)}.
@node Variable mon.value_wwws_in, Variable mon.average_wwws_in, Variable mon.stddev_ssh_out, Variable context mon
@subsection Variable mon.value_wwws_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (in)}.
@node Variable mon.average_wwws_in, Variable mon.stddev_wwws_in, Variable mon.value_wwws_in, Variable context mon
@subsection Variable mon.average_wwws_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (in)}.
@node Variable mon.stddev_wwws_in, Variable mon.value_wwws_out, Variable mon.average_wwws_in, Variable context mon
@subsection Variable mon.stddev_wwws_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (in)}.
@node Variable mon.value_wwws_out, Variable mon.average_wwws_out, Variable mon.stddev_wwws_in, Variable context mon
@subsection Variable mon.value_wwws_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (out)}.
@node Variable mon.average_wwws_out, Variable mon.stddev_wwws_out, Variable mon.value_wwws_out, Variable context mon
@subsection Variable mon.average_wwws_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (out)}.
@node Variable mon.stddev_wwws_out, Variable mon.value_icmp_in, Variable mon.average_wwws_out, Variable context mon
@subsection Variable mon.stddev_wwws_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{wwws connections (out)}.
@node Variable mon.value_icmp_in, Variable mon.average_icmp_in, Variable mon.stddev_wwws_out, Variable context mon
@subsection Variable mon.value_icmp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (in)}.
@node Variable mon.average_icmp_in, Variable mon.stddev_icmp_in, Variable mon.value_icmp_in, Variable context mon
@subsection Variable mon.average_icmp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (in)}.
@node Variable mon.stddev_icmp_in, Variable mon.value_icmp_out, Variable mon.average_icmp_in, Variable context mon
@subsection Variable mon.stddev_icmp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (in)}.
@node Variable mon.value_icmp_out, Variable mon.average_icmp_out, Variable mon.stddev_icmp_in, Variable context mon
@subsection Variable mon.value_icmp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (out)}.
@node Variable mon.average_icmp_out, Variable mon.stddev_icmp_out, Variable mon.value_icmp_out, Variable context mon
@subsection Variable mon.average_icmp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (out)}.
@node Variable mon.stddev_icmp_out, Variable mon.value_udp_in, Variable mon.average_icmp_out, Variable context mon
@subsection Variable mon.stddev_icmp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{ICMP packets (out)}.
@node Variable mon.value_udp_in, Variable mon.average_udp_in, Variable mon.stddev_icmp_out, Variable context mon
@subsection Variable mon.value_udp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (in)}.
@node Variable mon.average_udp_in, Variable mon.stddev_udp_in, Variable mon.value_udp_in, Variable context mon
@subsection Variable mon.average_udp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (in)}.
@node Variable mon.stddev_udp_in, Variable mon.value_udp_out, Variable mon.average_udp_in, Variable context mon
@subsection Variable mon.stddev_udp_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (in)}.
@node Variable mon.value_udp_out, Variable mon.average_udp_out, Variable mon.stddev_udp_in, Variable context mon
@subsection Variable mon.value_udp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (out)}.
@node Variable mon.average_udp_out, Variable mon.stddev_udp_out, Variable mon.value_udp_out, Variable context mon
@subsection Variable mon.average_udp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (out)}.
@node Variable mon.stddev_udp_out, Variable mon.value_dns_in, Variable mon.average_udp_out, Variable context mon
@subsection Variable mon.stddev_udp_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{UDP dgrams (out)}.
@node Variable mon.value_dns_in, Variable mon.average_dns_in, Variable mon.stddev_udp_out, Variable context mon
@subsection Variable mon.value_dns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (in)}.
@node Variable mon.average_dns_in, Variable mon.stddev_dns_in, Variable mon.value_dns_in, Variable context mon
@subsection Variable mon.average_dns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (in)}.
@node Variable mon.stddev_dns_in, Variable mon.value_dns_out, Variable mon.average_dns_in, Variable context mon
@subsection Variable mon.stddev_dns_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (in)}.
@node Variable mon.value_dns_out, Variable mon.average_dns_out, Variable mon.stddev_dns_in, Variable context mon
@subsection Variable mon.value_dns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (out)}.
@node Variable mon.average_dns_out, Variable mon.stddev_dns_out, Variable mon.value_dns_out, Variable context mon
@subsection Variable mon.average_dns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (out)}.
@node Variable mon.stddev_dns_out, Variable mon.value_tcpsyn_in, Variable mon.average_dns_out, Variable context mon
@subsection Variable mon.stddev_dns_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{DNS requests (out)}.
@node Variable mon.value_tcpsyn_in, Variable mon.average_tcpsyn_in, Variable mon.stddev_dns_out, Variable context mon
@subsection Variable mon.value_tcpsyn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (in)}.
@node Variable mon.average_tcpsyn_in, Variable mon.stddev_tcpsyn_in, Variable mon.value_tcpsyn_in, Variable context mon
@subsection Variable mon.average_tcpsyn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (in)}.
@node Variable mon.stddev_tcpsyn_in, Variable mon.value_tcpsyn_out, Variable mon.average_tcpsyn_in, Variable context mon
@subsection Variable mon.stddev_tcpsyn_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (in)}.
@node Variable mon.value_tcpsyn_out, Variable mon.average_tcpsyn_out, Variable mon.stddev_tcpsyn_in, Variable context mon
@subsection Variable mon.value_tcpsyn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (out)}.
@node Variable mon.average_tcpsyn_out, Variable mon.stddev_tcpsyn_out, Variable mon.value_tcpsyn_out, Variable context mon
@subsection Variable mon.average_tcpsyn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (out)}.
@node Variable mon.stddev_tcpsyn_out, Variable mon.value_tcpack_in, Variable mon.average_tcpsyn_out, Variable context mon
@subsection Variable mon.stddev_tcpsyn_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP sessions (out)}.
@node Variable mon.value_tcpack_in, Variable mon.average_tcpack_in, Variable mon.stddev_tcpsyn_out, Variable context mon
@subsection Variable mon.value_tcpack_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (in)}.
@node Variable mon.average_tcpack_in, Variable mon.stddev_tcpack_in, Variable mon.value_tcpack_in, Variable context mon
@subsection Variable mon.average_tcpack_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (in)}.
@node Variable mon.stddev_tcpack_in, Variable mon.value_tcpack_out, Variable mon.average_tcpack_in, Variable context mon
@subsection Variable mon.stddev_tcpack_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (in)}.
@node Variable mon.value_tcpack_out, Variable mon.average_tcpack_out, Variable mon.stddev_tcpack_in, Variable context mon
@subsection Variable mon.value_tcpack_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (out)}.
@node Variable mon.average_tcpack_out, Variable mon.stddev_tcpack_out, Variable mon.value_tcpack_out, Variable context mon
@subsection Variable mon.average_tcpack_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (out)}.
@node Variable mon.stddev_tcpack_out, Variable mon.value_tcpfin_in, Variable mon.average_tcpack_out, Variable context mon
@subsection Variable mon.stddev_tcpack_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP acks (out)}.
@node Variable mon.value_tcpfin_in, Variable mon.average_tcpfin_in, Variable mon.stddev_tcpack_out, Variable context mon
@subsection Variable mon.value_tcpfin_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (in)}.
@node Variable mon.average_tcpfin_in, Variable mon.stddev_tcpfin_in, Variable mon.value_tcpfin_in, Variable context mon
@subsection Variable mon.average_tcpfin_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (in)}.
@node Variable mon.stddev_tcpfin_in, Variable mon.value_tcpfin_out, Variable mon.average_tcpfin_in, Variable context mon
@subsection Variable mon.stddev_tcpfin_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (in)}.
@node Variable mon.value_tcpfin_out, Variable mon.average_tcpfin_out, Variable mon.stddev_tcpfin_in, Variable context mon
@subsection Variable mon.value_tcpfin_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (out)}.
@node Variable mon.average_tcpfin_out, Variable mon.stddev_tcpfin_out, Variable mon.value_tcpfin_out, Variable context mon
@subsection Variable mon.average_tcpfin_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (out)}.
@node Variable mon.stddev_tcpfin_out, Variable mon.value_tcpmisc_in, Variable mon.average_tcpfin_out, Variable context mon
@subsection Variable mon.stddev_tcpfin_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP finish (out)}.
@node Variable mon.value_tcpmisc_in, Variable mon.average_tcpmisc_in, Variable mon.stddev_tcpfin_out, Variable context mon
@subsection Variable mon.value_tcpmisc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (in)}.
@node Variable mon.average_tcpmisc_in, Variable mon.stddev_tcpmisc_in, Variable mon.value_tcpmisc_in, Variable context mon
@subsection Variable mon.average_tcpmisc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (in)}.
@node Variable mon.stddev_tcpmisc_in, Variable mon.value_tcpmisc_out, Variable mon.average_tcpmisc_in, Variable context mon
@subsection Variable mon.stddev_tcpmisc_in 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (in)}.
@node Variable mon.value_tcpmisc_out, Variable mon.average_tcpmisc_out, Variable mon.stddev_tcpmisc_in, Variable context mon
@subsection Variable mon.value_tcpmisc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (out)}.
@node Variable mon.average_tcpmisc_out, Variable mon.stddev_tcpmisc_out, Variable mon.value_tcpmisc_out, Variable context mon
@subsection Variable mon.average_tcpmisc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (out)}.
@node Variable mon.stddev_tcpmisc_out, Variable mon.value_webaccess, Variable mon.average_tcpmisc_out, Variable context mon
@subsection Variable mon.stddev_tcpmisc_out 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{TCP misc (out)}.
@node Variable mon.value_webaccess, Variable mon.average_webaccess, Variable mon.stddev_tcpmisc_out, Variable context mon
@subsection Variable mon.value_webaccess 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver hits}.
@node Variable mon.average_webaccess, Variable mon.stddev_webaccess, Variable mon.value_webaccess, Variable context mon
@subsection Variable mon.average_webaccess 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver hits}.
@node Variable mon.stddev_webaccess, Variable mon.value_weberrors, Variable mon.average_webaccess, Variable context mon
@subsection Variable mon.stddev_webaccess 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver hits}.
@node Variable mon.value_weberrors, Variable mon.average_weberrors, Variable mon.stddev_webaccess, Variable context mon
@subsection Variable mon.value_weberrors 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver errors}.
@node Variable mon.average_weberrors, Variable mon.stddev_weberrors, Variable mon.value_weberrors, Variable context mon
@subsection Variable mon.average_weberrors 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver errors}.
@node Variable mon.stddev_weberrors, Variable mon.value_syslog, Variable mon.average_weberrors, Variable context mon
@subsection Variable mon.stddev_weberrors 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{Webserver errors}.
@node Variable mon.value_syslog, Variable mon.average_syslog, Variable mon.stddev_weberrors, Variable context mon
@subsection Variable mon.value_syslog 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (Syslog)}.
@node Variable mon.average_syslog, Variable mon.stddev_syslog, Variable mon.value_syslog, Variable context mon
@subsection Variable mon.average_syslog 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (Syslog)}.
@node Variable mon.stddev_syslog, Variable mon.value_messages, Variable mon.average_syslog, Variable context mon
@subsection Variable mon.stddev_syslog 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (Syslog)}.
@node Variable mon.value_messages, Variable mon.average_messages, Variable mon.stddev_syslog, Variable context mon
@subsection Variable mon.value_messages 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (messages)}.
@node Variable mon.average_messages, Variable mon.stddev_messages, Variable mon.value_messages, Variable context mon
@subsection Variable mon.average_messages 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (messages)}.
@node Variable mon.stddev_messages, Variable mon.value_temp0, Variable mon.average_messages, Variable context mon
@subsection Variable mon.stddev_messages 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{New log entries (messages)}.
@node Variable mon.value_temp0, Variable mon.average_temp0, Variable mon.stddev_messages, Variable context mon
@subsection Variable mon.value_temp0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 0}.
@node Variable mon.average_temp0, Variable mon.stddev_temp0, Variable mon.value_temp0, Variable context mon
@subsection Variable mon.average_temp0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 0}.
@node Variable mon.stddev_temp0, Variable mon.value_temp1, Variable mon.average_temp0, Variable context mon
@subsection Variable mon.stddev_temp0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 0}.
@node Variable mon.value_temp1, Variable mon.average_temp1, Variable mon.stddev_temp0, Variable context mon
@subsection Variable mon.value_temp1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 1}.
@node Variable mon.average_temp1, Variable mon.stddev_temp1, Variable mon.value_temp1, Variable context mon
@subsection Variable mon.average_temp1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 1}.
@node Variable mon.stddev_temp1, Variable mon.value_temp2, Variable mon.average_temp1, Variable context mon
@subsection Variable mon.stddev_temp1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 1}.
@node Variable mon.value_temp2, Variable mon.average_temp2, Variable mon.stddev_temp1, Variable context mon
@subsection Variable mon.value_temp2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 2}.
@node Variable mon.average_temp2, Variable mon.stddev_temp2, Variable mon.value_temp2, Variable context mon
@subsection Variable mon.average_temp2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 2}.
@node Variable mon.stddev_temp2, Variable mon.value_temp3, Variable mon.average_temp2, Variable context mon
@subsection Variable mon.stddev_temp2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 2}.
@node Variable mon.value_temp3, Variable mon.average_temp3, Variable mon.stddev_temp2, Variable context mon
@subsection Variable mon.value_temp3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 3}.
@node Variable mon.average_temp3, Variable mon.stddev_temp3, Variable mon.value_temp3, Variable context mon
@subsection Variable mon.average_temp3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 3}.
@node Variable mon.stddev_temp3, Variable mon.value_cpu, Variable mon.average_temp3, Variable context mon
@subsection Variable mon.stddev_temp3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{CPU Temperature 3}.
@node Variable mon.value_cpu, Variable mon.average_cpu, Variable mon.stddev_temp3, Variable context mon
@subsection Variable mon.value_cpu 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization (all)}.
@node Variable mon.average_cpu, Variable mon.stddev_cpu, Variable mon.value_cpu, Variable context mon
@subsection Variable mon.average_cpu 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization (all)}.
@node Variable mon.stddev_cpu, Variable mon.value_cpu0, Variable mon.average_cpu, Variable context mon
@subsection Variable mon.stddev_cpu 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization (all)}.
@node Variable mon.value_cpu0, Variable mon.average_cpu0, Variable mon.stddev_cpu, Variable context mon
@subsection Variable mon.value_cpu0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 0}.
@node Variable mon.average_cpu0, Variable mon.stddev_cpu0, Variable mon.value_cpu0, Variable context mon
@subsection Variable mon.average_cpu0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 0}.
@node Variable mon.stddev_cpu0, Variable mon.value_cpu1, Variable mon.average_cpu0, Variable context mon
@subsection Variable mon.stddev_cpu0 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 0}.
@node Variable mon.value_cpu1, Variable mon.average_cpu1, Variable mon.stddev_cpu0, Variable context mon
@subsection Variable mon.value_cpu1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 1}.
@node Variable mon.average_cpu1, Variable mon.stddev_cpu1, Variable mon.value_cpu1, Variable context mon
@subsection Variable mon.average_cpu1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 1}.
@node Variable mon.stddev_cpu1, Variable mon.value_cpu2, Variable mon.average_cpu1, Variable context mon
@subsection Variable mon.stddev_cpu1 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 1}.
@node Variable mon.value_cpu2, Variable mon.average_cpu2, Variable mon.stddev_cpu1, Variable context mon
@subsection Variable mon.value_cpu2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 2}.
@node Variable mon.average_cpu2, Variable mon.stddev_cpu2, Variable mon.value_cpu2, Variable context mon
@subsection Variable mon.average_cpu2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 2}.
@node Variable mon.stddev_cpu2, Variable mon.value_cpu3, Variable mon.average_cpu2, Variable context mon
@subsection Variable mon.stddev_cpu2 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 2}.
@node Variable mon.value_cpu3, Variable mon.average_cpu3, Variable mon.stddev_cpu2, Variable context mon
@subsection Variable mon.value_cpu3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 3}.
@node Variable mon.average_cpu3, Variable mon.stddev_cpu3, Variable mon.value_cpu3, Variable context mon
@subsection Variable mon.average_cpu3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 3}.
@node Variable mon.stddev_cpu3,  , Variable mon.average_cpu3, Variable context mon
@subsection Variable mon.stddev_cpu3 

Observational measure collected every 2.5 minutes from cf-monitord, description: @var{%CPU utilization 3}.@c *****************************************************
@c * CHAPTER 
@c *****************************************************
@node Logs and records,  , Special Variables, Top
@chapter Logs and records

@*

Cfengine writes numerous logs and records to its private workspace,
referred to as @file{WORKDIR}. This chapter makes some brief notes
about these files. Cfengine approaches monitoring and reporting from
the viewpoint of scalability so there is no default centralizatio of
reporting information, as this is untenable for more than a few
hundred hosts. Instead, in the classic cfengine way, every host
is reponsible for its own data. Solutions for centralization and
netwide reporting will be given elsewhere.

The filenames referred to in this section are all relative to the
cfengine work directory @file{WORKDIR}.


@menu
* Embedded Databases::          
* Text logs::                   
* Reports in outputs::          
* Additional reports in commcerical cfengine versions::  
* State information::           
@end menu

@node Embedded Databases, Text logs, Logs and records, Logs and records
@section Embedded Databases

The embedded databases can be viewed and printed using the reporting
tool @code{cf-report}.

@table @file
@item cf_Audit.db    
A compressed database of auditing information. This file grows very large
is auditing is switched on. By default, only minor information about cfengine runs
are recorded. This file should be archived and deleted regularly to avoid choking
the system.
@item cf_LastSeen.db       
A database of hosts that last contacted this host, or were contacted by this
host which includes the times at which they were last observed. 
@item cf_classes.db  
A database of classes that have been defined on the current host, including
their relative frequences, scaled like a probability.

@item checksum_digests.db
The database of hash values used in cfengine's change management functions.
@item performance.db
A database of last, average and deviation times of jobs recorded by @code{cf-agent}. 
Most promises take an immeasurablely short time to check, but longer
tasks such as command execution and file copying are measured by default.
Other checks can be instrumented by setting a @code{measurement_class}
in the @code{action} body of a promise.
@item cfengine_lock_db
A database of active and inactive locks and their expiry times. Deleting
this database will reset all lock protections in cfengine.

@item stats.db  
A database of external file attributes for change management functionality.

@item state/history.db  
Enterprise level versions of cfengine maintain this long-term trend database.

@item state/cf_observations.db  
This database contains the current state of the observational history
of the host as recorded by @code{cf-monitord}.

@item state/promise_compliance.db  
Enterprise cfengine (Nova and above) database of individual promise compliance history. 
The database is approximate because promise references can change as policy is
edited. It quickly approaches accuracy as a policy goes unchanged for more than a day.

@item state/cf_state.db
A database of persistent classes active on this current host.

@item state/nova_measures.db
Enterprise cfengine (Nova and above) database of custom measurables.
@item state/nova_static.db
Enterprise cfengine (Nova and above) database of static system discovery data.
@end table

@node Text logs, Reports in outputs, Embedded Databases, Logs and records
@section Text logs

@table @file
@item promise.log
A time-stamped log of the percentage fraction of promises kept after each run.
@item cf3.HOSTNAME.runlog
A time-stamped log of when each lock was released. This shows the last
time each individual promise was verified.
@item cfagent.HOSTNAME.log 
Although ambiguously named (for historical reasons) this log contains the current
list of setuid/setgid programs observed on the system. Cfengine warns about
new additions to this list.


@item reports/*
Enterprise versions of cfengine use this directory as a default place for
outputting reports.

@item reports/class_notes
Class data in csv format for export to CMDB.

@item state/file_hash_event_history
A time-stamped log of which files have experienced content changes
since the last observation, as determined by the hashing algorithms in
cfengine.

@item state/nova_*.db
Enterprise level cfengine's use these data for storing custom system measurements.

@item state/vars.out
Enterprise level versions of cfengine use this log to communicate variable
data.

@item state/*_measure.log
Enterprise level versions of cfengine maintain user-defined logs based on
specifically promised observations of the system.


@end table

@node Reports in outputs, Additional reports in commcerical cfengine versions, Text logs, Logs and records
@section Reports in outputs

The @file{outputs} directory contains a time-stamped list of outputs
generated by @code{cf-agent}. These are collected by @code{cf-execd}
and are often E-mailed as reports. However, not all hosts have an
E-mail capability or are online, so the reports are kept here. Reports
are not tidied automatically, so you should delete these files after a
time to avoid a build up.


@node Additional reports in commcerical cfengine versions, State information, Reports in outputs, Logs and records
@section Additional reports in commcerical cfengine versions




@node State information,  , Additional reports in commcerical cfengine versions, Logs and records
@section State information

The cfengine components keep their current process identifier number
in `pid files' in the work directory: e.g.

@verbatim
cf-execd.pid
cf-serverd.pid
@end verbatim

Most other state data refer to the running condition of the host and
are generated by @code{cf-monitord} (@code{cfenvd} in earlier versions
of cfengine).

@table @file
@item state/env_data
This file contains a list of currently discovered classes and variable values
that characterize the anomaly alert environment. They are altered by the monitor
daemon.
@item state/all_classes
A list of all the classes that were defined the last time that cfengine
was run. 
@item state/cf_*
All files that begin with this prefix refer to cached data that were observed
by the monitor daemon, and may be used by @code{cf-agent} in @code{reports} with @code{showstate}.
@end table



@c =========================================================================
@c @node Index,  , Cfengine Methods, Top
@c @unnumbered Concept Index
@c @printindex cp
@c =========================================================================
@ifhtml
@html
<a name="Contents">
@contents
@end html
@end ifhtml
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml
@bye
