A patch that allow cfengine3 to be built against openssl 1.1 which is currently
in experimental.

--- a/libutils/hashes.c
+++ b/libutils/hashes.c
@@ -47,20 +47,22 @@
             return 0;
         }
 
-        EVP_MD_CTX context;
-        EVP_DigestInit(&context, md);
+        EVP_MD_CTX *context = EVP_MD_CTX_create();
+        EVP_DigestInit(context, md);
 
         int len = 0;
         unsigned char buffer[1024];
         while ((len = fread(buffer, 1, 1024, file)))
         {
-            EVP_DigestUpdate(&context, buffer, len);
+            EVP_DigestUpdate(context, buffer, len);
         }
 
         unsigned int md_len = 0;
-        EVP_DigestFinal(&context, digest, &md_len);
+        EVP_DigestFinal(context, digest, &md_len);
         fclose(file);
 
+        EVP_MD_CTX_destroy(context);
+
         return md_len;
     }
 }
--- a/libutils/hash.c
+++ b/libutils/hash.c
@@ -205,20 +205,23 @@
     int buffer_length = 0;
     int actual_length = 0;
 
-    if (rsa->n)
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(rsa, &n, &e, &d);
+
+    if (n)
     {
-        buffer_length = (size_t) BN_num_bytes(rsa->n);
+        buffer_length = (size_t) BN_num_bytes(n);
     }
     else
     {
         buffer_length = 0;
     }
 
-    if (rsa->e)
+    if (e)
     {
-        if (buffer_length < (size_t) BN_num_bytes(rsa->e))
+        if (buffer_length < (size_t) BN_num_bytes(e))
         {
-            buffer_length = (size_t) BN_num_bytes(rsa->e);
+            buffer_length = (size_t) BN_num_bytes(e);
         }
     }
     md = EVP_get_digestbyname(CF_DIGEST_TYPES[method]);
@@ -231,9 +234,9 @@
     context = EVP_MD_CTX_create();
     EVP_DigestInit_ex(context, md, NULL);
     buffer = xmalloc(buffer_length);
-    actual_length = BN_bn2bin(rsa->n, buffer);
+    actual_length = BN_bn2bin(n, buffer);
     EVP_DigestUpdate(context, buffer, actual_length);
-    actual_length = BN_bn2bin(rsa->e, buffer);
+    actual_length = BN_bn2bin(e, buffer);
     EVP_DigestUpdate(context, buffer, actual_length);
     EVP_DigestFinal_ex(context, hash->digest, &md_len);
     EVP_MD_CTX_destroy(context);
--- a/libcfnet/client_protocol.c
+++ b/libcfnet/client_protocol.c
@@ -196,7 +196,7 @@
         return false;
     }
 
-    conn->session_key = (unsigned char *) bp->d;
+    conn->session_key = (unsigned char *) BN_get_word(bp);
     return true;
 }
 
@@ -290,16 +290,18 @@
     BN_free(nonce_challenge);
     free(out);
 
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(PUBKEY, &n, &e, &d);
 /*Send the public key - we don't know if server has it */
 /* proposition C2 */
 
     memset(sendbuffer, 0, CF_EXPANDSIZE);
-    len = BN_bn2mpi(PUBKEY->n, sendbuffer);
+    len = BN_bn2mpi(n, sendbuffer);
     SendTransaction(conn->conn_info, sendbuffer, len, CF_DONE);        /* No need to encrypt the public key ... */
 
 /* proposition C3 */
     memset(sendbuffer, 0, CF_EXPANDSIZE);
-    len = BN_bn2mpi(PUBKEY->e, sendbuffer);
+    len = BN_bn2mpi(e, sendbuffer);
     SendTransaction(conn->conn_info, sendbuffer, len, CF_DONE);
 
 /* check reply about public key - server can break conn_info here */
@@ -432,7 +434,9 @@
             return false;
         }
 
-        if ((newkey->n = BN_mpi2bn(in, len, NULL)) == NULL)
+        const BIGNUM *n, *e, *d;
+        RSA_get0_key(newkey, &n, &e, &d);
+        if ((n = BN_mpi2bn(in, len, NULL)) == NULL)
         {
             Log(LOG_LEVEL_ERR,
                 "Private key decrypt failed. (BN_mpi2bn: %s)",
@@ -451,7 +455,7 @@
             return false;
         }
 
-        if ((newkey->e = BN_mpi2bn(in, len, NULL)) == NULL)
+        if ((e = BN_mpi2bn(in, len, NULL)) == NULL)
         {
             Log(LOG_LEVEL_ERR,
                 "Public key decrypt failed. (BN_mpi2bn: %s)",
--- a/libcfnet/client_code.c
+++ b/libcfnet/client_code.c
@@ -537,7 +537,7 @@
     unsigned char iv[32] =
         { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
     long n_read_total = 0;
-    EVP_CIPHER_CTX crypto_ctx;
+    EVP_CIPHER_CTX *crypto_ctx = EVP_CIPHER_CTX_new();
 
     snprintf(cfchangedstr, 255, "%s%s", CF_CHANGEDSTR1, CF_CHANGEDSTR2);
 
@@ -566,7 +566,7 @@
     }
 
     workbuf[0] = '\0';
-    EVP_CIPHER_CTX_init(&crypto_ctx);
+    EVP_CIPHER_CTX_init(crypto_ctx);
 
     snprintf(in, CF_BUFSIZE - CF_PROTO_OFFSET, "GET dummykey %s", source);
     cipherlen = EncryptString(conn->encryption_type, in, out, conn->session_key, strlen(in) + 1);
@@ -604,6 +604,7 @@
             Log(LOG_LEVEL_INFO, "Network access to '%s:%s' denied", conn->this_server, source);
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -612,22 +613,25 @@
             Log(LOG_LEVEL_INFO, "Source '%s:%s' changed while copying", conn->this_server, source);
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
-        EVP_DecryptInit_ex(&crypto_ctx, CfengineCipher(CfEnterpriseOptions()), NULL, conn->session_key, iv);
+        EVP_DecryptInit_ex(crypto_ctx, CfengineCipher(CfEnterpriseOptions()), NULL, conn->session_key, iv);
 
-        if (!EVP_DecryptUpdate(&crypto_ctx, workbuf, &plainlen, buf, cipherlen))
+        if (!EVP_DecryptUpdate(crypto_ctx, workbuf, &plainlen, buf, cipherlen))
         {
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
-        if (!EVP_DecryptFinal_ex(&crypto_ctx, workbuf + plainlen, &finlen))
+        if (!EVP_DecryptFinal_ex(crypto_ctx, workbuf + plainlen, &finlen))
         {
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -646,7 +650,8 @@
             free(buf);
             unlink(dest);
             close(dd);
-            EVP_CIPHER_CTX_cleanup(&crypto_ctx);
+            EVP_CIPHER_CTX_cleanup(crypto_ctx);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
     }
@@ -663,13 +668,15 @@
         free(buf);
         unlink(dest);
         close(dd);
-        EVP_CIPHER_CTX_cleanup(&crypto_ctx);
+        EVP_CIPHER_CTX_cleanup(crypto_ctx);
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
     close(dd);
     free(buf);
-    EVP_CIPHER_CTX_cleanup(&crypto_ctx);
+    EVP_CIPHER_CTX_cleanup(crypto_ctx);
+    EVP_CIPHER_CTX_free(crypto_ctx);
     return true;
 }
 
@@ -695,7 +702,7 @@
     const int buf_size = 2048;
 
     off_t n_read_total = 0;
-    EVP_CIPHER_CTX crypto_ctx;
+    EVP_CIPHER_CTX *crypto_ctx = EVP_CIPHER_CTX_new();
 
     /* We encrypt only for CLASSIC protocol. The TLS protocol is always over
      * encrypted layer, so it does not support encrypted (S*) commands. */
@@ -703,6 +710,7 @@
 
     if (encrypt)
     {
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return EncryptCopyRegularFileNet(source, dest, size, conn);
     }
 
@@ -711,6 +719,7 @@
     if ((strlen(dest) > CF_BUFSIZE - 20))
     {
         Log(LOG_LEVEL_ERR, "Filename too long");
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
@@ -723,6 +732,7 @@
             "Copy from server '%s' to destination '%s' failed (open: %s)",
             conn->this_server, dest, GetErrorStr());
         unlink(dest);
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
@@ -733,6 +743,7 @@
         Log(LOG_LEVEL_ERR, "Failed to compose GET command for file %s",
             source);
         close(dd);
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
@@ -742,6 +753,7 @@
     {
         Log(LOG_LEVEL_ERR, "Couldn't send GET command");
         close(dd);
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
@@ -786,6 +798,7 @@
 
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -797,6 +810,7 @@
                 conn->this_server, source);
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -806,6 +820,7 @@
                 conn->this_server, source);
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -821,6 +836,7 @@
                 conn->this_server, source);
             close(dd);
             free(buf);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -837,7 +853,8 @@
             unlink(dest);
             close(dd);
             FlushFileStream(conn->conn_info->sd, size - n_read_total);
-            EVP_CIPHER_CTX_cleanup(&crypto_ctx);
+            EVP_CIPHER_CTX_cleanup(crypto_ctx);
+            EVP_CIPHER_CTX_free(crypto_ctx);
             return false;
         }
 
@@ -857,10 +874,12 @@
         unlink(dest);
         close(dd);
         FlushFileStream(conn->conn_info->sd, size - n_read_total);
+        EVP_CIPHER_CTX_free(crypto_ctx);
         return false;
     }
 
     close(dd);
     free(buf);
+    EVP_CIPHER_CTX_free(crypto_ctx);
     return true;
 }
--- a/libcfnet/tls_generic.c
+++ b/libcfnet/tls_generic.c
@@ -88,7 +88,7 @@
             TLSErrorString(ERR_get_error()));
         goto ret1;
     }
-    if (EVP_PKEY_type(cert_pkey->type) != EVP_PKEY_RSA)
+    if (EVP_PKEY_base_id(cert_pkey) != EVP_PKEY_RSA)
     {
         Log(LOG_LEVEL_ERR,
             "Received key of unknown type, only RSA currently supported!");
@@ -300,7 +300,7 @@
         retval = -1;
         goto ret2;
     }
-    if (EVP_PKEY_type(received_pubkey->type) != EVP_PKEY_RSA)
+    if (EVP_PKEY_base_id(received_pubkey) != EVP_PKEY_RSA)
     {
         Log(LOG_LEVEL_ERR,
             "Received key of unknown type, only RSA currently supported!");
--- a/libpromises/crypto.c
+++ b/libpromises/crypto.c
@@ -220,11 +220,16 @@
         fclose(fp);
     }
 
-    if (NULL != PUBKEY
-        && ((BN_num_bits(PUBKEY->e) < 2) || (!BN_is_odd(PUBKEY->e))))
+    if (NULL != PUBKEY)
     {
-        Log(LOG_LEVEL_ERR, "The public key RSA exponent is too small or not odd");
-        return false;
+        const BIGNUM *n, *e, *d;
+        RSA_get0_key(PUBKEY, &n, &e, &d);
+
+        if ((BN_num_bits(e) < 2) || (!BN_is_odd(e)))
+        {
+            Log(LOG_LEVEL_ERR, "The public key RSA exponent is too small or not odd");
+            return false;
+        }
     }
 
     return true;
@@ -366,7 +371,9 @@
 
     fclose(fp);
 
-    if ((BN_num_bits(newkey->e) < 2) || (!BN_is_odd(newkey->e)))
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(newkey, &n, &e, &d);
+    if ((BN_num_bits(e) < 2) || (!BN_is_odd(e)))
     {
         Log(LOG_LEVEL_ERR, "RSA Exponent too small or not odd for key: %s",
             newname);
@@ -437,28 +444,31 @@
     int cipherlen = 0, tmplen;
     unsigned char iv[32] =
         { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     if (key == NULL)
         ProgrammingError("EncryptString: session key == NULL");
 
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_EncryptInit_ex(&ctx, CfengineCipher(type), NULL, key, iv);
+    EVP_CIPHER_CTX_init(ctx);
+    EVP_EncryptInit_ex(ctx, CfengineCipher(type), NULL, key, iv);
 
-    if (!EVP_EncryptUpdate(&ctx, out, &cipherlen, in, plainlen))
+    if (!EVP_EncryptUpdate(ctx, out, &cipherlen, in, plainlen))
     {
-        EVP_CIPHER_CTX_cleanup(&ctx);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
         return -1;
     }
 
-    if (!EVP_EncryptFinal_ex(&ctx, out + cipherlen, &tmplen))
+    if (!EVP_EncryptFinal_ex(ctx, out + cipherlen, &tmplen))
     {
-        EVP_CIPHER_CTX_cleanup(&ctx);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
         return -1;
     }
 
     cipherlen += tmplen;
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
     return cipherlen;
 }
 
@@ -469,33 +479,36 @@
     int plainlen = 0, tmplen;
     unsigned char iv[32] =
         { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     if (key == NULL)
         ProgrammingError("DecryptString: session key == NULL");
 
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_DecryptInit_ex(&ctx, CfengineCipher(type), NULL, key, iv);
+    EVP_CIPHER_CTX_init(ctx);
+    EVP_DecryptInit_ex(ctx, CfengineCipher(type), NULL, key, iv);
 
-    if (!EVP_DecryptUpdate(&ctx, out, &plainlen, in, cipherlen))
+    if (!EVP_DecryptUpdate(ctx, out, &plainlen, in, cipherlen))
     {
         Log(LOG_LEVEL_ERR, "Failed to decrypt string");
-        EVP_CIPHER_CTX_cleanup(&ctx);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
         return -1;
     }
 
-    if (!EVP_DecryptFinal_ex(&ctx, out + plainlen, &tmplen))
+    if (!EVP_DecryptFinal_ex(ctx, out + plainlen, &tmplen))
     {
         unsigned long err = ERR_get_error();
 
         Log(LOG_LEVEL_ERR, "Failed to decrypt at final of cipher length %d. (EVP_DecryptFinal_ex: %s)", cipherlen, ERR_error_string(err, NULL));
-        EVP_CIPHER_CTX_cleanup(&ctx);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
         return -1;
     }
 
     plainlen += tmplen;
 
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     return plainlen;
 }
--- a/libpromises/files_hashes.c
+++ b/libpromises/files_hashes.c
@@ -40,7 +40,7 @@
 void HashFile(const char *filename, unsigned char digest[EVP_MAX_MD_SIZE + 1], HashMethod type)
 {
     FILE *file;
-    EVP_MD_CTX context;
+    EVP_MD_CTX *context = EVP_MD_CTX_new();
     int len, md_len;
     unsigned char buffer[1024];
     const EVP_MD *md = NULL;
@@ -53,25 +53,26 @@
     {
         md = EVP_get_digestbyname(HashNameFromId(type));
 
-        EVP_DigestInit(&context, md);
+        EVP_DigestInit(context, md);
 
         while ((len = fread(buffer, 1, 1024, file)))
         {
-            EVP_DigestUpdate(&context, buffer, len);
+            EVP_DigestUpdate(context, buffer, len);
         }
 
-        EVP_DigestFinal(&context, digest, &md_len);
+        EVP_DigestFinal(context, digest, &md_len);
 
         /* Digest length stored in md_len */
         fclose(file);
     }
+    EVP_MD_CTX_free(context);
 }
 
 /*******************************************************************/
 
 void HashString(const char *buffer, int len, unsigned char digest[EVP_MAX_MD_SIZE + 1], HashMethod type)
 {
-    EVP_MD_CTX context;
+    EVP_MD_CTX *context = EVP_MD_CTX_new();
     const EVP_MD *md = NULL;
     int md_len;
 
@@ -89,10 +90,10 @@
         {
             Log(LOG_LEVEL_INFO, "Digest type %s not supported by OpenSSL library", HashNameFromId(type));
         }
-        else if (EVP_DigestInit(&context, md))
+        else if (EVP_DigestInit(context, md))
         {
-            EVP_DigestUpdate(&context, (unsigned char *) buffer, (size_t) len);
-            EVP_DigestFinal(&context, digest, &md_len);
+            EVP_DigestUpdate(context, (unsigned char *) buffer, (size_t) len);
+            EVP_DigestFinal(context, digest, &md_len);
         }
         else
         {
@@ -102,29 +103,33 @@
 
         break;
     }
+    EVP_MD_CTX_free(context);
 }
 
 /*******************************************************************/
 
 void HashPubKey(RSA *key, unsigned char digest[EVP_MAX_MD_SIZE + 1], HashMethod type)
 {
-    EVP_MD_CTX context;
+    EVP_MD_CTX *context = EVP_MD_CTX_new();
     const EVP_MD *md = NULL;
     int md_len, i, buf_len, actlen;
     unsigned char *buffer;
 
-    if (key->n)
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(key, &n, &e, &d);
+
+    if (n)
     {
-        buf_len = (size_t) BN_num_bytes(key->n);
+        buf_len = (size_t) BN_num_bytes(n);
     }
     else
     {
         buf_len = 0;
     }
 
-    if (key->e)
+    if (e)
     {
-        if (buf_len < (i = (size_t) BN_num_bytes(key->e)))
+        if (buf_len < (i = (size_t) BN_num_bytes(e)))
         {
             buf_len = i;
         }
@@ -146,16 +151,17 @@
             Log(LOG_LEVEL_INFO, "Digest type %s not supported by OpenSSL library", HashNameFromId(type));
         }
 
-        EVP_DigestInit(&context, md);
+        EVP_DigestInit(context, md);
 
-        actlen = BN_bn2bin(key->n, buffer);
-        EVP_DigestUpdate(&context, buffer, actlen);
-        actlen = BN_bn2bin(key->e, buffer);
-        EVP_DigestUpdate(&context, buffer, actlen);
-        EVP_DigestFinal(&context, digest, &md_len);
+        actlen = BN_bn2bin(n, buffer);
+        EVP_DigestUpdate(context, buffer, actlen);
+        actlen = BN_bn2bin(e, buffer);
+        EVP_DigestUpdate(context, buffer, actlen);
+        EVP_DigestFinal(context, digest, &md_len);
         break;
     }
 
+    EVP_MD_CTX_free(context);
     free(buffer);
 }
 
--- a/libpromises/generic_agent.c
+++ b/libpromises/generic_agent.c
@@ -1146,19 +1146,20 @@
     }
 
     // fallback, produce some pseudo sha1 hash
-    EVP_MD_CTX crypto_ctx;
-    EVP_DigestInit(&crypto_ctx, EVP_get_digestbyname(HashNameFromId(GENERIC_AGENT_CHECKSUM_METHOD)));
+    EVP_MD_CTX *crypto_ctx = EVP_MD_CTX_new();
+    EVP_DigestInit(crypto_ctx, EVP_get_digestbyname(HashNameFromId(GENERIC_AGENT_CHECKSUM_METHOD)));
 
     bool success = HashDirectoryTree(policy_dir,
                                      (const char *[]) { ".cf", ".dat", ".txt", ".conf", ".mustache", ".json", ".yaml", NULL},
-                                     &crypto_ctx);
+                                     crypto_ctx);
 
     int md_len;
     unsigned char digest[EVP_MAX_MD_SIZE + 1] = { 0 };
-    EVP_DigestFinal(&crypto_ctx, digest, &md_len);
+    EVP_DigestFinal(crypto_ctx, digest, &md_len);
 
     HashPrintSafe(release_id_out, out_size, digest,
                   GENERIC_AGENT_CHECKSUM_METHOD, false);
+    EVP_MD_CTX_free(crypto_ctx);
     return success;
 }
 
--- a/libpromises/locks.c
+++ b/libpromises/locks.c
@@ -510,7 +510,7 @@
 {
     static const char PACK_UPIFELAPSED_SALT[] = "packageuplist";
 
-    EVP_MD_CTX context;
+    EVP_MD_CTX *context = EVP_MD_CTX_new();
     int md_len;
     const EVP_MD *md = NULL;
     Rlist *rp;
@@ -521,29 +521,29 @@
 
     md = EVP_get_digestbyname(HashNameFromId(type));
 
-    EVP_DigestInit(&context, md);
+    EVP_DigestInit(context, md);
 
 // multiple packages (promisers) may share same package_list_update_ifelapsed lock
     if ( (!salt) || strcmp(salt, PACK_UPIFELAPSED_SALT) )
     {
-        EVP_DigestUpdate(&context, pp->promiser, strlen(pp->promiser));
+        EVP_DigestUpdate(context, pp->promiser, strlen(pp->promiser));
     }
 
     if (pp->comment)
     {
-        EVP_DigestUpdate(&context, pp->comment, strlen(pp->comment));
+        EVP_DigestUpdate(context, pp->comment, strlen(pp->comment));
     }
 
     if (pp->parent_promise_type && pp->parent_promise_type->parent_bundle)
     {
         if (pp->parent_promise_type->parent_bundle->ns)
         {
-            EVP_DigestUpdate(&context, pp->parent_promise_type->parent_bundle->ns, strlen(pp->parent_promise_type->parent_bundle->ns));
+            EVP_DigestUpdate(context, pp->parent_promise_type->parent_bundle->ns, strlen(pp->parent_promise_type->parent_bundle->ns));
         }
 
         if (pp->parent_promise_type->parent_bundle->name)
         {
-            EVP_DigestUpdate(&context, pp->parent_promise_type->parent_bundle->name, strlen(pp->parent_promise_type->parent_bundle->name));
+            EVP_DigestUpdate(context, pp->parent_promise_type->parent_bundle->name, strlen(pp->parent_promise_type->parent_bundle->name));
         }
     }
 
@@ -551,7 +551,7 @@
 
     if (salt)
     {
-        EVP_DigestUpdate(&context, salt, strlen(salt));
+        EVP_DigestUpdate(context, salt, strlen(salt));
     }
 
     if (pp->conlist)
@@ -560,7 +560,7 @@
         {
             Constraint *cp = SeqAt(pp->conlist, i);
 
-            EVP_DigestUpdate(&context, cp->lval, strlen(cp->lval));
+            EVP_DigestUpdate(context, cp->lval, strlen(cp->lval));
 
             // don't hash rvals that change (e.g. times)
             doHash = true;
@@ -582,13 +582,13 @@
             switch (cp->rval.type)
             {
             case RVAL_TYPE_SCALAR:
-                EVP_DigestUpdate(&context, cp->rval.item, strlen(cp->rval.item));
+                EVP_DigestUpdate(context, cp->rval.item, strlen(cp->rval.item));
                 break;
 
             case RVAL_TYPE_LIST:
                 for (rp = cp->rval.item; rp != NULL; rp = rp->next)
                 {
-                    EVP_DigestUpdate(&context, RlistScalarValue(rp), strlen(RlistScalarValue(rp)));
+                    EVP_DigestUpdate(context, RlistScalarValue(rp), strlen(RlistScalarValue(rp)));
                 }
                 break;
 
@@ -598,18 +598,18 @@
 
                 fp = (FnCall *) cp->rval.item;
 
-                EVP_DigestUpdate(&context, fp->name, strlen(fp->name));
+                EVP_DigestUpdate(context, fp->name, strlen(fp->name));
 
                 for (rp = fp->args; rp != NULL; rp = rp->next)
                 {
                     switch (rp->val.type)
                     {
                     case RVAL_TYPE_SCALAR:
-                        EVP_DigestUpdate(&context, RlistScalarValue(rp), strlen(RlistScalarValue(rp)));
+                        EVP_DigestUpdate(context, RlistScalarValue(rp), strlen(RlistScalarValue(rp)));
                         break;
 
                     case RVAL_TYPE_FNCALL:
-                        EVP_DigestUpdate(&context, RlistFnCallValue(rp)->name, strlen(RlistFnCallValue(rp)->name));
+                        EVP_DigestUpdate(context, RlistFnCallValue(rp)->name, strlen(RlistFnCallValue(rp)->name));
                         break;
 
                     default:
@@ -625,8 +625,8 @@
         }
     }
 
-    EVP_DigestFinal(&context, digest, &md_len);
-
+    EVP_DigestFinal(context, digest, &md_len);
+    EVP_MD_CTX_free(context);
 /* Digest length stored in md_len */
 }
 
--- a/configure.ac
+++ b/configure.ac
@@ -422,7 +422,7 @@
 
 CF3_WITH_LIBRARY(openssl, [
    AC_CHECK_LIB(crypto, RSA_generate_key_ex, [], [])
-   AC_CHECK_LIB(ssl, SSL_library_init, [], [])
+   AC_CHECK_LIB(ssl, OPENSSL_init_ssl, [], [])
    AC_CHECK_DECLS([SSL_CTX_clear_options], [], [], [[#include <openssl/ssl.h>]])
    AC_CHECK_HEADERS([openssl/opensslv.h], [], [AC_MSG_ERROR(Cannot find OpenSSL)])
 
--- a/cf-key/cf-key-functions.c
+++ b/cf-key/cf-key-functions.c
@@ -69,7 +69,10 @@
 
     fclose(fp);
 
-    if (BN_num_bits(key->e) < 2 || !BN_is_odd(key->e))
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(key, &n, &e, &d);
+
+    if (BN_num_bits(e) < 2 || !BN_is_odd(e))
     {
         Log(LOG_LEVEL_ERR, "Error while reading public key '%s' - RSA Exponent is too small or not odd. (BN_num_bits: %s)",
             filename, GetErrorStr());
--- a/cf-serverd/server_common.c
+++ b/cf-serverd/server_common.c
@@ -557,7 +557,7 @@
     unsigned char iv[32] =
         { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
     int blocksize = CF_BUFSIZE - 4 * CF_INBAND_OFFSET;
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
     char *key, enctype;
     struct stat sb;
     ConnectionInfo *conn_info = args->conn->conn_info;
@@ -581,7 +581,7 @@
         FailedTransfer(conn_info);
     }
 
-    EVP_CIPHER_CTX_init(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
 
     if ((fd = safe_open(filename, O_RDONLY)) == -1)
     {
@@ -630,20 +630,22 @@
 
             if (n_read > 0)
             {
-                EVP_EncryptInit_ex(&ctx, CfengineCipher(enctype), NULL, key, iv);
+                EVP_EncryptInit_ex(ctx, CfengineCipher(enctype), NULL, key, iv);
 
-                if (!EVP_EncryptUpdate(&ctx, out, &cipherlen, sendbuffer, n_read))
+                if (!EVP_EncryptUpdate(ctx, out, &cipherlen, sendbuffer, n_read))
                 {
                     FailedTransfer(conn_info);
-                    EVP_CIPHER_CTX_cleanup(&ctx);
+                    EVP_CIPHER_CTX_cleanup(ctx);
+                    EVP_CIPHER_CTX_free(ctx);
                     close(fd);
                     return;
                 }
 
-                if (!EVP_EncryptFinal_ex(&ctx, out + cipherlen, &finlen))
+                if (!EVP_EncryptFinal_ex(ctx, out + cipherlen, &finlen))
                 {
                     FailedTransfer(conn_info);
-                    EVP_CIPHER_CTX_cleanup(&ctx);
+                    EVP_CIPHER_CTX_cleanup(ctx);
+                    EVP_CIPHER_CTX_free(ctx);
                     close(fd);
                     return;
                 }
@@ -654,7 +656,8 @@
                 if (SendTransaction(conn_info, out, cipherlen + finlen, CF_DONE) == -1)
                 {
                     Log(LOG_LEVEL_VERBOSE, "Send failed in GetFile. (send: %s)", GetErrorStr());
-                    EVP_CIPHER_CTX_cleanup(&ctx);
+                    EVP_CIPHER_CTX_cleanup(ctx);
+                    EVP_CIPHER_CTX_free(ctx);
                     close(fd);
                     return;
                 }
@@ -666,14 +669,16 @@
                 {
                     Log(LOG_LEVEL_VERBOSE, "Send failed in GetFile. (send: %s)", GetErrorStr());
                     close(fd);
-                    EVP_CIPHER_CTX_cleanup(&ctx);
+                    EVP_CIPHER_CTX_cleanup(ctx);
+                    EVP_CIPHER_CTX_free(ctx);
                     return;
                 }
             }
         }
     }
 
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
     close(fd);
 }
 
--- a/cf-serverd/server_classic.c
+++ b/cf-serverd/server_classic.c
@@ -579,7 +579,11 @@
             "A public key was already known from %s/%s - no trust required",
             conn->hostname, conn->ipaddr);
 
-        if ((BN_cmp(savedkey->e, key->e) == 0) && (BN_cmp(savedkey->n, key->n) == 0))
+        const BIGNUM *s_n, *s_e, *s_d;
+        const BIGNUM *k_n, *k_e, *k_d;
+        RSA_get0_key(savedkey, &s_n, &s_e, &s_d);
+        RSA_get0_key(key, &k_n, &k_e, &k_d);
+        if ((BN_cmp(s_e, k_e) == 0) && (BN_cmp(s_n, k_n) == 0))
         {
             Log(LOG_LEVEL_VERBOSE,
                 "The public key identity was confirmed as %s@%s",
@@ -783,7 +787,9 @@
         return false;
     }
 
-    if ((newkey->n = BN_mpi2bn(recvbuffer, len_n, NULL)) == NULL)
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(newkey, &n, &e, &d);
+    if ((n = BN_mpi2bn(recvbuffer, len_n, NULL)) == NULL)
     {
         Log(LOG_LEVEL_ERR, "Authentication failure: "
             "private decrypt of received public key modulus failed "
@@ -804,7 +810,9 @@
         return false;
     }
 
-    if ((newkey->e = BN_mpi2bn(recvbuffer, len_e, NULL)) == NULL)
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(newkey, &n, &e, &d);
+    if ((e = BN_mpi2bn(recvbuffer, len_e, NULL)) == NULL)
     {
         Log(LOG_LEVEL_ERR, "Authentication failure: "
             "private decrypt of received public key exponent failed "
@@ -896,13 +904,15 @@
         Log(LOG_LEVEL_DEBUG, "Sending server's public key");
 
         char bignum_buf[CF_BUFSIZE] = { 0 };
+        const BIGNUM *n, *e, *d;
+        RSA_get0_key(PUBKEY, &n, &e, &d);
 
         /* proposition S4  - conditional */
-        int len_n = BN_bn2mpi(PUBKEY->n, bignum_buf);
+        int len_n = BN_bn2mpi(n, bignum_buf);
         SendTransaction(conn->conn_info, bignum_buf, len_n, CF_DONE);
 
         /* proposition S5  - conditional */
-        int len_e = BN_bn2mpi(PUBKEY->e, bignum_buf);
+        int len_e = BN_bn2mpi(e, bignum_buf);
         SendTransaction(conn->conn_info, bignum_buf, len_e, CF_DONE);
     }
 }
--- a/tests/unit/crypto_symmetric_test.c
+++ b/tests/unit/crypto_symmetric_test.c
@@ -30,11 +30,12 @@
 {
     unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
     unsigned char iv[] = {1,2,3,4,5,6,7,8};
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
-    EVP_CIPHER_CTX_init(&ctx);
-    EVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    EVP_EncryptInit_ex(ctx, EVP_bf_cbc(), NULL, key, iv);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 }
 
 static void test_symmetric_encrypt(void)
--- a/tests/unit/tls_generic_test.c
+++ b/tests/unit/tls_generic_test.c
@@ -780,12 +780,12 @@
 #define SSL_GET_PEER_CERTIFICATE_RETURN(x) \
     SSL_get_peer_certificate_result = x
 #define X509_GET_PUBKEY_RETURN(x)                    \
-    if (x) ((EVP_PKEY *) x)->references++;           \
+    if (x) EVP_PKEY_up_ref(x);           \
     X509_get_pubkey_result = x
 #define EVP_PKEY_TYPE_RETURN(x) \
     EVP_PKEY_type_result = x
 #define HAVEPUBLICKEY_RETURN(x)                 \
-    if (x) ((RSA *) x)->references++;           \
+    if (x) RSA_up_ref(x);           \
     HavePublicKey_result = x
 #define EVP_PKEY_CMP_RETURN(x) \
     EVP_PKEY_cmp_result = x
@@ -804,7 +804,7 @@
         return -1;
         }
 
-    if (s->shutdown & SSL_SENT_SHUTDOWN)
+    if (SSL_shutdown(s) & SSL_SENT_SHUTDOWN)
         {
         s->rwstate=SSL_NOTHING;
         SSLerr(SSL_F_SSL_WRITE,SSL_R_PROTOCOL_IS_SHUTDOWN);
@@ -831,20 +831,22 @@
 
 int original_SSL_get_shutdown(const SSL *ssl)
 {
-    return(ssl->shutdown);
+    return(SSL_get_shutdown(ssl));
 }
 X509 *original_SSL_get_peer_certificate(const SSL *ssl)
 {
     X509 *r;
 
-    if ((ssl == NULL) || (ssl->session == NULL))
+    if ((ssl == NULL) || (SSL_get_session(ssl) == NULL))
         r=NULL;
-    else
-        r=ssl->session->peer;
+    else {
+        SSL_SESSION *s = SSL_get_session(ssl);
+        r=SSL_SESSION_get0_peer(s);
+    }
 
     if (r == NULL) return(r);
 
-    CRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);
+    X509_up_ref(r)
 
     return(r);
 }
@@ -943,7 +945,9 @@
 
     fclose(fp);
 
-    if ((BN_num_bits(newkey->e) < 2) || (!BN_is_odd(newkey->e)))
+    const BIGNUM *n, *e, *d;
+    RSA_get0_key(newkey, &n, &e, &d);
+    if ((BN_num_bits(e) < 2) || (!BN_is_odd(e)))
     {
         Log(LOG_LEVEL_ERR, "RSA Exponent too small or not odd");
         RSA_free(newkey);
@@ -954,7 +958,7 @@
 }
 int original_EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
 {
-    if (a->type != b->type)
+    if (EVP_PKEY_base_id(a) != EVP_PKEY_base_id(b))
         return -1;
 
     if (EVP_PKEY_cmp_parameters(a, b) == 0)
@@ -963,8 +967,16 @@
     switch (a->type)
     {
     case EVP_PKEY_RSA:
-        if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0
-            || BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
+        const RSA *rsa_a = EVP_PKEY_get0_RSA(a);
+        const BIGNUM *a_n, *a_e, *a_d;
+        RSA_get0_key(rsa_a, &a_n, &a_e, &a_d);
+
+        const RSA *rsa_b = EVP_PKEY_get0_RSA(b);
+        const BIGNUM *b_n, *b_e, *b_d;
+        RSA_get0_key(rsa_b, &b_n, &b_e, &b_d);
+        
+        if (BN_cmp(b_n, a_n) != 0
+            || BN_cmp(b_e, a_e) != 0)
             return 0;
         break;
     default:
--- a/tests/unit/Makefile.am
+++ b/tests/unit/Makefile.am
@@ -394,18 +394,6 @@
 mon_processes_test_SOURCES = mon_processes_test.c ../../cf-monitord/mon.h ../../cf-monitord/mon_processes.c
 mon_processes_test_LDADD = ../../libpromises/libpromises.la libtest.la
 
-# tls_generic_test uses stub functions interposition which does not work (yet)
-# under OS X. Another way of stubbing functions from libpromises is needed.
-if !XNU
-check_PROGRAMS += tls_generic_test
-tls_generic_test_SOURCES = tls_generic_test.c
-tls_generic_test_LDADD = libtest.la \
-	../../libutils/libutils.la \
-	../../libpromises/libpromises.la \
-	../../libcfnet/libcfnet.la \
-	../../cf-serverd/libcf-serverd.la
-endif
-
 version_test_SOURCES = version_test.c
 
 hash_test_SOURCES = hash_test.c
